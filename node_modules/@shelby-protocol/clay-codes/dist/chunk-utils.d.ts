/**
 * Normalised view over the encoder's output: every chunk, plus convenience
 * slices for the systematic and parity portions.
 */
type ChunkCollection = {
    /** All chunks returned from Clay, systematic first then parity. */
    chunks: Uint8Array[];
    /** Convenience view over the first k chunks that correspond to input data. */
    systematic: Uint8Array[];
    /** Convenience view over the parity chunks Clay produced. */
    parity: Uint8Array[];
};
/**
 * Clay accepts either a flat buffer or an array of chunk-sized buffers.
 *
 * To avoid duplicating validation and slicing logic throughout the encoder/decoder code,
 * this helper enforces the expected shape/size and always returns a uniform array
 * view that downstream routines can consume safely.
 */
declare function normaliseChunkInput(input: Uint8Array[] | Uint8Array, expectedCount: number, chunkSize: number, label: string): Uint8Array[];
declare function buildChunkCollection(chunks: Uint8Array[], k: number): ChunkCollection;
/**
 * Flatten just the systematic portion of a chunk collection. Useful for hashing or streaming the
 * original data payload while ignoring parity chunks.
 */
declare function flattenSystematic(collection: Pick<ChunkCollection, "systematic">, chunkSize: number): Uint8Array;

export { type ChunkCollection, buildChunkCollection, flattenSystematic, normaliseChunkInput };
