import {
  createWasmWorkspace
} from "./chunk-ST33RHQN.js";
import {
  buildChunkCollection,
  normaliseChunkInput
} from "./chunk-22OVODFS.js";
import {
  CLAY_PARAMS_BYTES,
  DEFAULT_ALIGN_MASK,
  DEFAULT_PAGE_SIZE
} from "./chunk-N26WXNR7.js";
import {
  DuplicateChunkIndexError,
  InvalidChunkIndexError
} from "./chunk-XAN62WH2.js";

// src/decoder.ts
var MAX_WASM_MASK_BITS = 32;
var FULL_WASM_MASK = 4294967295;
function toMaskFromIndexes(indexes, totalChunks) {
  let mask = 0;
  for (const idx of indexes) {
    if (!Number.isInteger(idx) || idx < 0) {
      throw new InvalidChunkIndexError(idx, "not a valid non-negative integer");
    }
    if (idx >= totalChunks) {
      throw new InvalidChunkIndexError(
        idx,
        `exceeds total chunks (${totalChunks})`
      );
    }
    if (idx >= MAX_WASM_MASK_BITS) {
      throw new InvalidChunkIndexError(
        idx,
        `exceeds mask width (${MAX_WASM_MASK_BITS} bits)`
      );
    }
    const bit = 1 << idx;
    if (mask & bit) {
      throw new DuplicateChunkIndexError(idx);
    }
    mask |= bit;
  }
  return mask >>> 0;
}
function erasedMaskFromAvailable(availableIndexes, totalChunks) {
  const available = /* @__PURE__ */ new Set();
  for (const idx of availableIndexes) {
    if (!Number.isInteger(idx) || idx < 0) {
      throw new InvalidChunkIndexError(idx, "not a valid non-negative integer");
    }
    if (idx >= totalChunks) {
      throw new InvalidChunkIndexError(
        idx,
        `exceeds total chunks (${totalChunks})`
      );
    }
    if (idx >= MAX_WASM_MASK_BITS) {
      throw new InvalidChunkIndexError(
        idx,
        `exceeds mask width (${MAX_WASM_MASK_BITS} bits)`
      );
    }
    if (available.has(idx)) {
      throw new DuplicateChunkIndexError(idx);
    }
    available.add(idx);
  }
  let mask = 0;
  for (let idx = 0; idx < totalChunks; idx++) {
    if (!available.has(idx)) {
      mask |= 1 << idx;
    }
  }
  return mask >>> 0;
}
function convertToErasedMask(options, totalChunks) {
  if ("erasedChunksMask" in options) {
    return options.erasedChunksMask >>> 0;
  }
  if ("erasedChunkIndexes" in options) {
    return toMaskFromIndexes(options.erasedChunkIndexes, totalChunks);
  }
  return erasedMaskFromAvailable(options.availableChunkIndexes, totalChunks);
}
function makeDecoderAPI(instance, opts) {
  const exp = instance.exports;
  const workspace = createWasmWorkspace(exp.memory, exp.__heap_base.value, {
    alignMask: DEFAULT_ALIGN_MASK,
    pageSize: DEFAULT_PAGE_SIZE
  });
  const paramsPtr = workspace.alloc(CLAY_PARAMS_BYTES, DEFAULT_ALIGN_MASK);
  exp.clay_params_init(
    paramsPtr,
    opts.n,
    opts.k,
    opts.d,
    opts.chunkSizeBytes,
    /* SHA-256 */
    1
  );
  if (typeof exp.clay_decoder_footprint !== "function") {
    throw new Error(
      "Decoder footprint export not available in wasm module; bindings expect a dedicated decoder footprint entry point."
    );
  }
  const decoderSize = exp.clay_decoder_footprint(paramsPtr);
  const decoderPtr = workspace.alloc(decoderSize);
  const staging = workspace.createStagingBuffer(opts.chunkSizeBytes);
  const missingIndexes = /* @__PURE__ */ new Set();
  const availableIndexes = [];
  const staged = /* @__PURE__ */ new Set();
  const applyMask = (mask) => {
    missingIndexes.clear();
    availableIndexes.length = 0;
    for (let idx = 0; idx < opts.n; idx++) {
      if (mask >>> idx & 1) {
        missingIndexes.add(idx);
      } else {
        availableIndexes.push(idx);
      }
    }
  };
  const initialMask = convertToErasedMask(opts, opts.n);
  const returnedPtr = exp.clay_decoder_init_mds(
    decoderPtr,
    initialMask,
    paramsPtr
  );
  const activeDecoderPtr = returnedPtr || decoderPtr;
  applyMask(initialMask);
  let cachedMask = initialMask;
  const reset = () => {
    exp.clay_decoder_reset(activeDecoderPtr);
    staged.clear();
  };
  const setChunk = (idx, data) => {
    if (missingIndexes.has(idx)) {
      throw new Error(`Chunk ${idx} is marked erased and cannot be staged`);
    }
    if (data.byteLength !== opts.chunkSizeBytes) {
      throw new Error(
        `Chunk ${idx} length ${data.byteLength} does not match chunkSizeBytes ${opts.chunkSizeBytes}`
      );
    }
    staging.write(data);
    exp.clay_decoder_set_slice(
      activeDecoderPtr,
      idx,
      staging.pointer,
      opts.chunkSizeBytes
    );
    staged.add(idx);
  };
  const run = () => {
    if (staged.size < opts.k) {
      throw new Error(
        `Decoder requires at least ${opts.k} staged chunks but only ${staged.size} provided`
      );
    }
    exp.clay_decoder_run(activeDecoderPtr);
  };
  const getChunk = (idx) => {
    exp.clay_decoder_get_chunk(activeDecoderPtr, idx, staging.pointer);
    return staging.read();
  };
  const reconfigure = (erasurePattern) => {
    const mask = convertToErasedMask(erasurePattern, opts.n);
    reset();
    if (mask !== cachedMask) {
      const returned = exp.clay_decoder_init_mds(
        activeDecoderPtr,
        mask,
        paramsPtr
      );
      if (returned && returned !== activeDecoderPtr) {
        throw new Error(
          "Decoder reconfiguration returned unexpected pointer; multiple decoder instances are not supported in-place."
        );
      }
      applyMask(mask);
      cachedMask = mask;
    }
  };
  const decode = (available, erasurePattern) => {
    reconfigure(erasurePattern);
    const chunks = normaliseChunkInput(
      available,
      availableIndexes.length,
      opts.chunkSizeBytes,
      "decoder input"
    );
    for (let i = 0; i < availableIndexes.length; i++) {
      setChunk(availableIndexes[i], chunks[i]);
    }
    run();
    const outputs = new Array(opts.n);
    for (let idx = 0; idx < opts.n; idx++) {
      outputs[idx] = getChunk(idx);
    }
    return buildChunkCollection(outputs, opts.k);
  };
  const getChunkMerkleRoots = () => {
    exp.clay_decoder_get_merkle_root(
      activeDecoderPtr,
      staging.pointer + 32 * opts.n,
      staging.pointer
    );
    const array = staging.read().slice(0, 32 * opts.n);
    const chunkSize = 32;
    return Array.from(
      { length: opts.n },
      (_, i) => array.slice(i * chunkSize, (i + 1) * chunkSize)
    );
  };
  return { setChunk, run, getChunk, reset, decode, getChunkMerkleRoots };
}

export {
  MAX_WASM_MASK_BITS,
  FULL_WASM_MASK,
  convertToErasedMask,
  makeDecoderAPI
};
