// src/chunk-utils.ts
function normaliseChunkInput(input, expectedCount, chunkSize, label) {
  const total = expectedCount * chunkSize;
  const err = (msg) => new Error(`${label} ${msg}`);
  if (Array.isArray(input)) {
    if (input.length !== expectedCount) {
      throw err(
        `expected ${expectedCount} chunks but received ${input.length}`
      );
    }
    input.forEach((chunk, i) => {
      if (chunk.byteLength !== chunkSize) {
        throw err(
          `expected chunk ${i} to be ${chunkSize} bytes but received ${chunk.byteLength} bytes`
        );
      }
    });
    return input;
  }
  if (input.byteLength !== total) {
    throw err(
      `expected buffer to be ${total} bytes but received ${input.byteLength} bytes`
    );
  }
  const chunks = new Array(expectedCount);
  for (let i = 0; i < expectedCount; i++) {
    const start = i * chunkSize;
    const end = start + chunkSize;
    chunks[i] = input.subarray(start, end);
  }
  return chunks;
}
function buildChunkCollection(chunks, k) {
  return {
    chunks,
    systematic: chunks.slice(0, k),
    parity: chunks.slice(k)
  };
}
function flattenSystematic(collection, chunkSize) {
  const flat = new Uint8Array(collection.systematic.length * chunkSize);
  collection.systematic.forEach((chunk, idx) => {
    flat.set(chunk, idx * chunkSize);
  });
  return flat;
}

export {
  normaliseChunkInput,
  buildChunkCollection,
  flattenSystematic
};
