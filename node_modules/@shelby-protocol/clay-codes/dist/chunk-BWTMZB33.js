import {
  createWasmWorkspace
} from "./chunk-ST33RHQN.js";
import {
  buildChunkCollection,
  normaliseChunkInput
} from "./chunk-22OVODFS.js";
import {
  CLAY_PARAMS_BYTES,
  DEFAULT_ALIGN_MASK,
  DEFAULT_PAGE_SIZE
} from "./chunk-N26WXNR7.js";

// src/encoder.ts
function makeEncoderAPI(instance, opts) {
  const exp = instance.exports;
  const workspace = createWasmWorkspace(exp.memory, exp.__heap_base.value, {
    alignMask: DEFAULT_ALIGN_MASK,
    pageSize: DEFAULT_PAGE_SIZE
  });
  const paramsPtr = workspace.alloc(CLAY_PARAMS_BYTES, DEFAULT_ALIGN_MASK);
  exp.clay_params_init(
    paramsPtr,
    opts.n,
    opts.k,
    opts.d,
    opts.chunkSizeBytes,
    /* SHA-256 */
    1
  );
  const encPtr = workspace.alloc(exp.clay_encoder_footprint(paramsPtr));
  exp.clay_encoder_init(encPtr, paramsPtr);
  const staging = workspace.createStagingBuffer(opts.chunkSizeBytes);
  const setChunk = (idx, data) => {
    if (data.byteLength !== opts.chunkSizeBytes) {
      throw new Error(
        `Chunk ${idx} length ${data.byteLength} does not match chunkSizeBytes ${opts.chunkSizeBytes}`
      );
    }
    staging.write(data);
    exp.clay_encoder_set_data_chunk(encPtr, idx, staging.pointer);
  };
  const run = () => {
    exp.clay_encoder_run(encPtr);
  };
  const getChunk = (idx) => {
    exp.clay_encoder_get_chunk(encPtr, idx, staging.pointer);
    return staging.read();
  };
  const erasureCode = (input) => {
    exp.clay_decoder_reset(encPtr);
    const chunks = normaliseChunkInput(
      input,
      opts.k,
      opts.chunkSizeBytes,
      "encoder input"
    );
    for (let idx = 0; idx < chunks.length; idx++) {
      setChunk(idx, chunks[idx]);
    }
    run();
    const outputs = new Array(opts.n);
    for (let idx = 0; idx < opts.n; idx++) {
      outputs[idx] = getChunk(idx);
    }
    return buildChunkCollection(outputs, opts.k);
  };
  const getChunkMerkleRoots = () => {
    exp.clay_encoder_get_merkle_root(
      encPtr,
      staging.pointer + 32 * opts.n,
      staging.pointer
    );
    const array = staging.read().slice(0, 32 * opts.n);
    const chunkSize = 32;
    return Array.from(
      { length: opts.n },
      (_, i) => array.slice(i * chunkSize, (i + 1) * chunkSize)
    );
  };
  return { setChunk, run, getChunk, erasureCode, getChunkMerkleRoots };
}

export {
  makeEncoderAPI
};
