// src/memory.ts
var alignToMask = (value, mask) => value + mask & ~mask;
function createBumpAllocator(memory, initialHeap, alignMask, pageSize, onGrow) {
  let heap = alignToMask(initialHeap, alignMask);
  const ensureCapacity = (end) => {
    while (end > memory.buffer.byteLength) {
      const deficit = end - memory.buffer.byteLength;
      const pages = Math.ceil(deficit / pageSize);
      memory.grow(Math.max(pages, 1));
      onGrow();
    }
  };
  const allocate = (size, customAlignMask = alignMask) => {
    const ptr = alignToMask(heap, customAlignMask);
    heap = alignToMask(ptr + size, alignMask);
    ensureCapacity(heap);
    return ptr;
  };
  return allocate;
}
function createWasmWorkspace(memory, initialHeap, { alignMask, pageSize }) {
  let buffer = memory.buffer;
  const refreshCallbacks = /* @__PURE__ */ new Set();
  const refreshAll = () => {
    buffer = memory.buffer;
    for (const callback of refreshCallbacks) callback();
  };
  const alloc = createBumpAllocator(
    memory,
    initialHeap,
    alignMask,
    pageSize,
    refreshAll
  );
  const createStagingBuffer = (size) => {
    const pointer = alloc(size);
    let view = new Uint8Array(buffer, pointer, size);
    const refresh = () => {
      view = new Uint8Array(memory.buffer, pointer, size);
    };
    refreshCallbacks.add(refresh);
    return {
      get pointer() {
        return pointer;
      },
      write(data) {
        if (data.byteLength !== size) {
          throw new Error(
            `Staging buffer expected ${size} bytes but received ${data.byteLength}`
          );
        }
        view.set(data);
      },
      read() {
        return view.slice();
      }
    };
  };
  return { alloc, createStagingBuffer };
}

export {
  alignToMask,
  createWasmWorkspace
};
