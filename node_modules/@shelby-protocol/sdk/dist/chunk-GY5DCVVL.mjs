import {
  DEFAULT_CHUNKSET_SIZE_BYTES,
  DEFAULT_CHUNK_SIZE_BYTES
} from "./chunk-67F5YZ25.mjs";
import {
  DEFAULT_ERASURE_K,
  DEFAULT_ERASURE_N
} from "./chunk-ZPW742E7.mjs";

// src/core/layout.ts
import { AccountAddress } from "@aptos-labs/ts-sdk";
import { z } from "zod";
var BlobNameSchema = z.string().min(1, "Blob name path parameter cannot be empty.").max(1024, "Blob name cannot exceed 1024 characters.").refine((name) => !name.endsWith("/"), {
  message: "Blob name cannot end with a slash"
});
var ChunkKey = class _ChunkKey {
  constructor(account, blobName, chunksetIdx, chunkIdx) {
    this.account = account;
    this.blobName = blobName;
    this.chunksetIdx = chunksetIdx;
    this.chunkIdx = chunkIdx;
    if (chunkIdx >= DEFAULT_ERASURE_N) {
      throw new Error(
        `Cannot create a chunk with idx ${chunkIdx}. M+K=${DEFAULT_ERASURE_N}`
      );
    }
  }
  key() {
    return `${this.account.toString()}.${this.blobName}.${this.chunksetIdx}.${this.chunkIdx}`;
  }
  // Returns the range in the blob that this key represents, or "partity" if this is parity chunk.
  range() {
    if (this.chunkIdx >= DEFAULT_ERASURE_K) {
      return "parity";
    }
    const chunksetStart = this.chunksetIdx * DEFAULT_CHUNKSET_SIZE_BYTES;
    const chunkStart = chunksetStart + this.chunkIdx * DEFAULT_CHUNK_SIZE_BYTES;
    return {
      start: chunkStart,
      end: chunkStart + DEFAULT_CHUNK_SIZE_BYTES
    };
  }
  static fromJSON(json) {
    return new _ChunkKey(
      AccountAddress.fromString(json.account),
      json.blobName,
      json.chunksetIdx,
      json.chunkIdx
    );
  }
  toJSON() {
    return {
      account: this.account.toString(),
      blobName: this.blobName,
      chunksetIdx: this.chunksetIdx,
      chunkIdx: this.chunkIdx
    };
  }
};
function roundSize(size) {
  let ret = 0;
  let remain = size;
  while (remain > 0) {
    ret += DEFAULT_CHUNKSET_SIZE_BYTES;
    remain -= DEFAULT_CHUNKSET_SIZE_BYTES;
  }
  return ret;
}
function allChunksForBlob(account, blobName, _size) {
  const ret = [];
  const size = roundSize(_size);
  const nChunksets = size / DEFAULT_CHUNKSET_SIZE_BYTES;
  for (let chunksetIdx = 0; chunksetIdx < nChunksets; ++chunksetIdx) {
    for (let chunkIdx = 0; chunkIdx < DEFAULT_ERASURE_N; ++chunkIdx) {
      ret.push(new ChunkKey(account, blobName, chunksetIdx, chunkIdx));
    }
  }
  return ret;
}

export {
  BlobNameSchema,
  ChunkKey,
  roundSize,
  allChunksForBlob
};
