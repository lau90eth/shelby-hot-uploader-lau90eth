import {
  getShelbyIndexerClient
} from "./chunk-HFGEQP5N.mjs";
import {
  BlobNameSchema
} from "./chunk-GY5DCVVL.mjs";
import {
  sleep
} from "./chunk-I6NG5GNL.mjs";
import {
  buildRequestUrl
} from "./chunk-4JZO2D7T.mjs";
import {
  NetworkToShelbyRPCBaseUrl
} from "./chunk-SEXQTDX6.mjs";

// src/core/clients/ShelbyRPCClient.ts
import { AccountAddress } from "@aptos-labs/ts-sdk";
function encodeURIComponentKeepSlashes(str) {
  return encodeURIComponent(str).replace(/%2F/g, "/");
}
var ShelbyRPCClient = class {
  baseUrl;
  apiKey;
  rpcConfig;
  indexer;
  /**
   * Creates a new ShelbyRPCClient for interacting with Shelby RPC nodes.
   * This client handles blob storage operations including upload and download.
   *
   * @param config - The client configuration object.
   * @param config.network - The Shelby network to use.
   *
   * @example
   * ```typescript
   * const client = new ShelbyRPCClient({
   *   network: Network.SHELBYNET,
   *   apiKey: "AG-***",
   * });
   * ```
   */
  constructor(config) {
    this.baseUrl = config.rpc?.baseUrl ?? NetworkToShelbyRPCBaseUrl.shelbynet;
    this.apiKey = config.apiKey ?? config.rpc?.apiKey;
    this.rpcConfig = config.rpc ?? {};
    this.indexer = getShelbyIndexerClient(config);
  }
  async #uploadPart(uploadId, partIdx, partData) {
    const nRetries = 5;
    for (let i = 0; i < nRetries; ++i) {
      const partResponse = await fetch(
        buildRequestUrl(
          `/v1/multipart-uploads/${uploadId}/parts/${partIdx}`,
          this.baseUrl
        ),
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/octet-stream",
            ...this.apiKey ? { Authorization: `Bearer ${this.apiKey}` } : {}
          },
          body: partData
        }
      );
      if (partResponse.ok) return;
      if (i < nRetries - 1) {
        const delay = 2 ** i * 100;
        await sleep(delay);
      }
    }
    throw new Error(`Failed to upload part ${partIdx}.`);
  }
  async #putBlobMultipart(account, blobName, blobData, partSize = 5 * 1024 * 1024) {
    const startResponse = await fetch(
      buildRequestUrl("/v1/multipart-uploads", this.baseUrl),
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...this.apiKey ? { Authorization: `Bearer ${this.apiKey}` } : {}
        },
        body: JSON.stringify({
          rawAccount: account.toString(),
          rawBlobName: blobName,
          rawPartSize: partSize
        })
      }
    );
    if (!startResponse.ok) {
      let errorBodyText = "Could not read error body";
      try {
        errorBodyText = await startResponse.text();
      } catch (_e) {
      }
      throw new Error(
        `Failed to start multipart upload! status: ${startResponse.status}, body: ${errorBodyText}`
      );
    }
    const { uploadId } = await startResponse.json();
    const totalParts = Math.ceil(blobData.length / partSize);
    for (let partIdx = 0; partIdx < totalParts; partIdx++) {
      const start = partIdx * partSize;
      const end = Math.min(start + partSize, blobData.length);
      const partData = blobData.slice(start, end);
      await this.#uploadPart(uploadId, partIdx, partData);
    }
    const completeResponse = await fetch(
      buildRequestUrl(
        `/v1/multipart-uploads/${uploadId}/complete`,
        this.baseUrl
      ),
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...this.apiKey ? { Authorization: `Bearer ${this.apiKey}` } : {}
        }
      }
    );
    if (!completeResponse.ok) {
      let errorBodyText = "Could not read error body";
      try {
        errorBodyText = await completeResponse.text();
      } catch (_e) {
      }
      throw new Error(
        `Failed to complete multipart upload! status: ${completeResponse.status}, body: ${errorBodyText}`
      );
    }
  }
  /**
   * Uploads blob data to the Shelby RPC node for storage by storage providers.
   * This method should be called after blob commitments have been registered on the blockchain.
   * Uses multipart upload for efficient handling of large files.
   *
   * @param params.account - The account that owns the blob.
   * @param params.blobName - The name/path of the blob (e.g. "folder/file.txt").
   * @param params.blobData - The raw blob data as a Uint8Array.
   *
   * @example
   * ```typescript
   * const blobData = new TextEncoder().encode("Hello, world!");
   *
   * await client.putBlob({
   *   account: AccountAddress.from("0x1"),
   *   blobName: "greetings/hello.txt",
   *   blobData
   * });
   * ```
   */
  async putBlob(params) {
    BlobNameSchema.parse(params.blobName);
    await this.#putBlobMultipart(
      params.account,
      params.blobName,
      params.blobData
    );
  }
  // FIXME make this possible to stream in put ^^^
  /**
   * Downloads a blob from the Shelby RPC node.
   * Returns a streaming response with validation to ensure data integrity.
   *
   * @param params.account - The account that owns the blob.
   * @param params.blobName - The name/path of the blob (e.g. "folder/file.txt").
   * @param params.range - Optional byte range for partial downloads.
   * @param params.range.start - Starting byte position (inclusive).
   * @param params.range.end - Ending byte position (inclusive, optional).
   *
   * @returns A ShelbyBlob object containing the account, name, readable stream, and content length.
   *
   * @throws Error if the download fails or content length doesn't match.
   *
   * @example
   * ```typescript
   * // Download entire blob
   * const blob = await client.getBlob({
   *   account: AccountAddress.from("0x1"),
   *   blobName: "documents/report.pdf"
   * });
   *
   * // Download partial content (bytes 100-199)
   * const partial = await client.getBlob({
   *   account: AccountAddress.from("0x1"),
   *   blobName: "large-file.bin",
   *   range: { start: 100, end: 199 }
   * });
   * ```
   */
  async getBlob(params) {
    BlobNameSchema.parse(params.blobName);
    const url = buildRequestUrl(
      `/v1/blobs/${params.account.toString()}/${encodeURIComponentKeepSlashes(
        params.blobName
      )}`,
      this.baseUrl
    );
    const requestInit = {};
    if (params.range !== void 0) {
      const headers = new Headers();
      const { start, end } = params.range;
      if (end === void 0) {
        headers.set("Range", `bytes=${start}-`);
      } else {
        if (end < start) {
          throw new Error("Range end cannot be less than start.");
        }
        headers.set("Range", `bytes=${start}-${end}`);
      }
      requestInit.headers = headers;
    }
    const response = await fetch(url, {
      ...requestInit,
      headers: {
        ...requestInit.headers,
        ...this.apiKey ? { Authorization: `Bearer ${this.apiKey}` } : {}
      }
    });
    if (!response.ok) {
      throw new Error(
        `Failed to download blob: ${response.status} ${response.statusText}`
      );
    }
    if (!response.body) {
      throw new Error("Response body is null");
    }
    const contentLengthHeader = response.headers.get("content-length");
    if (contentLengthHeader === null) {
      throw new Error(
        "Response did not have content-length header, which is required"
      );
    }
    const expectedContentLength = Number.parseInt(contentLengthHeader, 10);
    if (Number.isNaN(expectedContentLength)) {
      throw new Error(
        `Invalid content-length header received: ${contentLengthHeader}`
      );
    }
    const validatingStream = new ReadableStream({
      start(controller) {
        const maybeReader = response.body?.getReader();
        if (!maybeReader) {
          controller.error(new Error("Response body reader is unavailable"));
          return;
        }
        const reader = maybeReader;
        let bytesReceived = 0;
        function pump() {
          return reader.read().then(({ done, value }) => {
            if (done) {
              if (bytesReceived !== expectedContentLength) {
                controller.error(
                  new Error(
                    `Downloaded data size (${bytesReceived} bytes) does not match content-length header (${expectedContentLength} bytes). This might indicate a partial or corrupted download.`
                  )
                );
                return;
              }
              controller.close();
              return;
            }
            bytesReceived += value.byteLength;
            controller.enqueue(value);
            return pump();
          }).catch((error) => {
            controller.error(error);
          });
        }
        return pump();
      }
    });
    return {
      account: AccountAddress.from(params.account),
      name: params.blobName,
      readable: validatingStream,
      contentLength: expectedContentLength
    };
  }
};

export {
  ShelbyRPCClient
};
