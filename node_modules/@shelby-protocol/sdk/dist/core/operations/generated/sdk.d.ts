import * as graphql from 'graphql';
import { GraphQLClient, RequestOptions } from 'graphql-request';

type Maybe<T> = T | null;
type InputMaybe<T> = Maybe<T>;
type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
type GraphQLClientRequestHeaders = RequestOptions['requestHeaders'];
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    bigint: {
        input: any;
        output: any;
    };
    numeric: {
        input: any;
        output: any;
    };
    timestamp: {
        input: any;
        output: any;
    };
};
/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
type String_Comparison_Exp = {
    _eq?: InputMaybe<Scalars['String']['input']>;
    _gt?: InputMaybe<Scalars['String']['input']>;
    _gte?: InputMaybe<Scalars['String']['input']>;
    /** does the column match the given case-insensitive pattern */
    _ilike?: InputMaybe<Scalars['String']['input']>;
    _in?: InputMaybe<Array<Scalars['String']['input']>>;
    /** does the column match the given POSIX regular expression, case insensitive */
    _iregex?: InputMaybe<Scalars['String']['input']>;
    _is_null?: InputMaybe<Scalars['Boolean']['input']>;
    /** does the column match the given pattern */
    _like?: InputMaybe<Scalars['String']['input']>;
    _lt?: InputMaybe<Scalars['String']['input']>;
    _lte?: InputMaybe<Scalars['String']['input']>;
    _neq?: InputMaybe<Scalars['String']['input']>;
    /** does the column NOT match the given case-insensitive pattern */
    _nilike?: InputMaybe<Scalars['String']['input']>;
    _nin?: InputMaybe<Array<Scalars['String']['input']>>;
    /** does the column NOT match the given POSIX regular expression, case insensitive */
    _niregex?: InputMaybe<Scalars['String']['input']>;
    /** does the column NOT match the given pattern */
    _nlike?: InputMaybe<Scalars['String']['input']>;
    /** does the column NOT match the given POSIX regular expression, case sensitive */
    _nregex?: InputMaybe<Scalars['String']['input']>;
    /** does the column NOT match the given SQL regular expression */
    _nsimilar?: InputMaybe<Scalars['String']['input']>;
    /** does the column match the given POSIX regular expression, case sensitive */
    _regex?: InputMaybe<Scalars['String']['input']>;
    /** does the column match the given SQL regular expression */
    _similar?: InputMaybe<Scalars['String']['input']>;
};
/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
type Bigint_Comparison_Exp = {
    _eq?: InputMaybe<Scalars['bigint']['input']>;
    _gt?: InputMaybe<Scalars['bigint']['input']>;
    _gte?: InputMaybe<Scalars['bigint']['input']>;
    _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
    _is_null?: InputMaybe<Scalars['Boolean']['input']>;
    _lt?: InputMaybe<Scalars['bigint']['input']>;
    _lte?: InputMaybe<Scalars['bigint']['input']>;
    _neq?: InputMaybe<Scalars['bigint']['input']>;
    _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};
/** columns and relationships of "blob_activities" */
type Blob_Activities = {
    __typename?: 'blob_activities';
    blob_name: Scalars['String']['output'];
    event_index: Scalars['numeric']['output'];
    event_type: Scalars['String']['output'];
    timestamp: Scalars['timestamp']['output'];
    transaction_hash: Scalars['String']['output'];
    transaction_version: Scalars['numeric']['output'];
};
/** aggregated selection of "blob_activities" */
type Blob_Activities_Aggregate = {
    __typename?: 'blob_activities_aggregate';
    aggregate?: Maybe<Blob_Activities_Aggregate_Fields>;
    nodes: Array<Blob_Activities>;
};
/** aggregate fields of "blob_activities" */
type Blob_Activities_Aggregate_Fields = {
    __typename?: 'blob_activities_aggregate_fields';
    avg?: Maybe<Blob_Activities_Avg_Fields>;
    count: Scalars['Int']['output'];
    max?: Maybe<Blob_Activities_Max_Fields>;
    min?: Maybe<Blob_Activities_Min_Fields>;
    stddev?: Maybe<Blob_Activities_Stddev_Fields>;
    stddev_pop?: Maybe<Blob_Activities_Stddev_Pop_Fields>;
    stddev_samp?: Maybe<Blob_Activities_Stddev_Samp_Fields>;
    sum?: Maybe<Blob_Activities_Sum_Fields>;
    var_pop?: Maybe<Blob_Activities_Var_Pop_Fields>;
    var_samp?: Maybe<Blob_Activities_Var_Samp_Fields>;
    variance?: Maybe<Blob_Activities_Variance_Fields>;
};
/** aggregate fields of "blob_activities" */
type Blob_Activities_Aggregate_FieldsCountArgs = {
    columns?: InputMaybe<Array<Blob_Activities_Select_Column>>;
    distinct?: InputMaybe<Scalars['Boolean']['input']>;
};
/** aggregate avg on columns */
type Blob_Activities_Avg_Fields = {
    __typename?: 'blob_activities_avg_fields';
    event_index?: Maybe<Scalars['Float']['output']>;
    transaction_version?: Maybe<Scalars['Float']['output']>;
};
/** Boolean expression to filter rows from the table "blob_activities". All fields are combined with a logical 'AND'. */
type Blob_Activities_Bool_Exp = {
    _and?: InputMaybe<Array<Blob_Activities_Bool_Exp>>;
    _not?: InputMaybe<Blob_Activities_Bool_Exp>;
    _or?: InputMaybe<Array<Blob_Activities_Bool_Exp>>;
    blob_name?: InputMaybe<String_Comparison_Exp>;
    event_index?: InputMaybe<Numeric_Comparison_Exp>;
    event_type?: InputMaybe<String_Comparison_Exp>;
    timestamp?: InputMaybe<Timestamp_Comparison_Exp>;
    transaction_hash?: InputMaybe<String_Comparison_Exp>;
    transaction_version?: InputMaybe<Numeric_Comparison_Exp>;
};
/** aggregate max on columns */
type Blob_Activities_Max_Fields = {
    __typename?: 'blob_activities_max_fields';
    blob_name?: Maybe<Scalars['String']['output']>;
    event_index?: Maybe<Scalars['numeric']['output']>;
    event_type?: Maybe<Scalars['String']['output']>;
    timestamp?: Maybe<Scalars['timestamp']['output']>;
    transaction_hash?: Maybe<Scalars['String']['output']>;
    transaction_version?: Maybe<Scalars['numeric']['output']>;
};
/** aggregate min on columns */
type Blob_Activities_Min_Fields = {
    __typename?: 'blob_activities_min_fields';
    blob_name?: Maybe<Scalars['String']['output']>;
    event_index?: Maybe<Scalars['numeric']['output']>;
    event_type?: Maybe<Scalars['String']['output']>;
    timestamp?: Maybe<Scalars['timestamp']['output']>;
    transaction_hash?: Maybe<Scalars['String']['output']>;
    transaction_version?: Maybe<Scalars['numeric']['output']>;
};
/** Ordering options when selecting data from "blob_activities". */
type Blob_Activities_Order_By = {
    blob_name?: InputMaybe<Order_By>;
    event_index?: InputMaybe<Order_By>;
    event_type?: InputMaybe<Order_By>;
    timestamp?: InputMaybe<Order_By>;
    transaction_hash?: InputMaybe<Order_By>;
    transaction_version?: InputMaybe<Order_By>;
};
/** select columns of table "blob_activities" */
declare enum Blob_Activities_Select_Column {
    /** column name */
    BlobName = "blob_name",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    EventType = "event_type",
    /** column name */
    Timestamp = "timestamp",
    /** column name */
    TransactionHash = "transaction_hash",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** aggregate stddev on columns */
type Blob_Activities_Stddev_Fields = {
    __typename?: 'blob_activities_stddev_fields';
    event_index?: Maybe<Scalars['Float']['output']>;
    transaction_version?: Maybe<Scalars['Float']['output']>;
};
/** aggregate stddev_pop on columns */
type Blob_Activities_Stddev_Pop_Fields = {
    __typename?: 'blob_activities_stddev_pop_fields';
    event_index?: Maybe<Scalars['Float']['output']>;
    transaction_version?: Maybe<Scalars['Float']['output']>;
};
/** aggregate stddev_samp on columns */
type Blob_Activities_Stddev_Samp_Fields = {
    __typename?: 'blob_activities_stddev_samp_fields';
    event_index?: Maybe<Scalars['Float']['output']>;
    transaction_version?: Maybe<Scalars['Float']['output']>;
};
/** Streaming cursor of the table "blob_activities" */
type Blob_Activities_Stream_Cursor_Input = {
    /** Stream column input with initial value */
    initial_value: Blob_Activities_Stream_Cursor_Value_Input;
    /** cursor ordering */
    ordering?: InputMaybe<Cursor_Ordering>;
};
/** Initial value of the column from where the streaming should start */
type Blob_Activities_Stream_Cursor_Value_Input = {
    blob_name?: InputMaybe<Scalars['String']['input']>;
    event_index?: InputMaybe<Scalars['numeric']['input']>;
    event_type?: InputMaybe<Scalars['String']['input']>;
    timestamp?: InputMaybe<Scalars['timestamp']['input']>;
    transaction_hash?: InputMaybe<Scalars['String']['input']>;
    transaction_version?: InputMaybe<Scalars['numeric']['input']>;
};
/** aggregate sum on columns */
type Blob_Activities_Sum_Fields = {
    __typename?: 'blob_activities_sum_fields';
    event_index?: Maybe<Scalars['numeric']['output']>;
    transaction_version?: Maybe<Scalars['numeric']['output']>;
};
/** aggregate var_pop on columns */
type Blob_Activities_Var_Pop_Fields = {
    __typename?: 'blob_activities_var_pop_fields';
    event_index?: Maybe<Scalars['Float']['output']>;
    transaction_version?: Maybe<Scalars['Float']['output']>;
};
/** aggregate var_samp on columns */
type Blob_Activities_Var_Samp_Fields = {
    __typename?: 'blob_activities_var_samp_fields';
    event_index?: Maybe<Scalars['Float']['output']>;
    transaction_version?: Maybe<Scalars['Float']['output']>;
};
/** aggregate variance on columns */
type Blob_Activities_Variance_Fields = {
    __typename?: 'blob_activities_variance_fields';
    event_index?: Maybe<Scalars['Float']['output']>;
    transaction_version?: Maybe<Scalars['Float']['output']>;
};
/** columns and relationships of "blobs" */
type Blobs = {
    __typename?: 'blobs';
    blob_commitment: Scalars['String']['output'];
    blob_name: Scalars['String']['output'];
    created_at: Scalars['numeric']['output'];
    expires_at: Scalars['numeric']['output'];
    is_deleted: Scalars['numeric']['output'];
    is_written: Scalars['numeric']['output'];
    num_chunksets: Scalars['numeric']['output'];
    owner: Scalars['String']['output'];
    placement_group: Scalars['String']['output'];
    /** An array relationship */
    placement_group_slots: Array<Placement_Group_Slots>;
    size: Scalars['numeric']['output'];
    slice_address: Scalars['String']['output'];
    updated_at: Scalars['numeric']['output'];
};
/** columns and relationships of "blobs" */
type BlobsPlacement_Group_SlotsArgs = {
    distinct_on?: InputMaybe<Array<Placement_Group_Slots_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Placement_Group_Slots_Order_By>>;
    where?: InputMaybe<Placement_Group_Slots_Bool_Exp>;
};
/** aggregated selection of "blobs" */
type Blobs_Aggregate = {
    __typename?: 'blobs_aggregate';
    aggregate?: Maybe<Blobs_Aggregate_Fields>;
    nodes: Array<Blobs>;
};
/** aggregate fields of "blobs" */
type Blobs_Aggregate_Fields = {
    __typename?: 'blobs_aggregate_fields';
    avg?: Maybe<Blobs_Avg_Fields>;
    count: Scalars['Int']['output'];
    max?: Maybe<Blobs_Max_Fields>;
    min?: Maybe<Blobs_Min_Fields>;
    stddev?: Maybe<Blobs_Stddev_Fields>;
    stddev_pop?: Maybe<Blobs_Stddev_Pop_Fields>;
    stddev_samp?: Maybe<Blobs_Stddev_Samp_Fields>;
    sum?: Maybe<Blobs_Sum_Fields>;
    var_pop?: Maybe<Blobs_Var_Pop_Fields>;
    var_samp?: Maybe<Blobs_Var_Samp_Fields>;
    variance?: Maybe<Blobs_Variance_Fields>;
};
/** aggregate fields of "blobs" */
type Blobs_Aggregate_FieldsCountArgs = {
    columns?: InputMaybe<Array<Blobs_Select_Column>>;
    distinct?: InputMaybe<Scalars['Boolean']['input']>;
};
/** aggregate avg on columns */
type Blobs_Avg_Fields = {
    __typename?: 'blobs_avg_fields';
    created_at?: Maybe<Scalars['Float']['output']>;
    expires_at?: Maybe<Scalars['Float']['output']>;
    is_deleted?: Maybe<Scalars['Float']['output']>;
    is_written?: Maybe<Scalars['Float']['output']>;
    num_chunksets?: Maybe<Scalars['Float']['output']>;
    size?: Maybe<Scalars['Float']['output']>;
    updated_at?: Maybe<Scalars['Float']['output']>;
};
/** Boolean expression to filter rows from the table "blobs". All fields are combined with a logical 'AND'. */
type Blobs_Bool_Exp = {
    _and?: InputMaybe<Array<Blobs_Bool_Exp>>;
    _not?: InputMaybe<Blobs_Bool_Exp>;
    _or?: InputMaybe<Array<Blobs_Bool_Exp>>;
    blob_commitment?: InputMaybe<String_Comparison_Exp>;
    blob_name?: InputMaybe<String_Comparison_Exp>;
    created_at?: InputMaybe<Numeric_Comparison_Exp>;
    expires_at?: InputMaybe<Numeric_Comparison_Exp>;
    is_deleted?: InputMaybe<Numeric_Comparison_Exp>;
    is_written?: InputMaybe<Numeric_Comparison_Exp>;
    num_chunksets?: InputMaybe<Numeric_Comparison_Exp>;
    owner?: InputMaybe<String_Comparison_Exp>;
    placement_group?: InputMaybe<String_Comparison_Exp>;
    placement_group_slots?: InputMaybe<Placement_Group_Slots_Bool_Exp>;
    size?: InputMaybe<Numeric_Comparison_Exp>;
    slice_address?: InputMaybe<String_Comparison_Exp>;
    updated_at?: InputMaybe<Numeric_Comparison_Exp>;
};
/** aggregate max on columns */
type Blobs_Max_Fields = {
    __typename?: 'blobs_max_fields';
    blob_commitment?: Maybe<Scalars['String']['output']>;
    blob_name?: Maybe<Scalars['String']['output']>;
    created_at?: Maybe<Scalars['numeric']['output']>;
    expires_at?: Maybe<Scalars['numeric']['output']>;
    is_deleted?: Maybe<Scalars['numeric']['output']>;
    is_written?: Maybe<Scalars['numeric']['output']>;
    num_chunksets?: Maybe<Scalars['numeric']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    placement_group?: Maybe<Scalars['String']['output']>;
    size?: Maybe<Scalars['numeric']['output']>;
    slice_address?: Maybe<Scalars['String']['output']>;
    updated_at?: Maybe<Scalars['numeric']['output']>;
};
/** aggregate min on columns */
type Blobs_Min_Fields = {
    __typename?: 'blobs_min_fields';
    blob_commitment?: Maybe<Scalars['String']['output']>;
    blob_name?: Maybe<Scalars['String']['output']>;
    created_at?: Maybe<Scalars['numeric']['output']>;
    expires_at?: Maybe<Scalars['numeric']['output']>;
    is_deleted?: Maybe<Scalars['numeric']['output']>;
    is_written?: Maybe<Scalars['numeric']['output']>;
    num_chunksets?: Maybe<Scalars['numeric']['output']>;
    owner?: Maybe<Scalars['String']['output']>;
    placement_group?: Maybe<Scalars['String']['output']>;
    size?: Maybe<Scalars['numeric']['output']>;
    slice_address?: Maybe<Scalars['String']['output']>;
    updated_at?: Maybe<Scalars['numeric']['output']>;
};
/** Ordering options when selecting data from "blobs". */
type Blobs_Order_By = {
    blob_commitment?: InputMaybe<Order_By>;
    blob_name?: InputMaybe<Order_By>;
    created_at?: InputMaybe<Order_By>;
    expires_at?: InputMaybe<Order_By>;
    is_deleted?: InputMaybe<Order_By>;
    is_written?: InputMaybe<Order_By>;
    num_chunksets?: InputMaybe<Order_By>;
    owner?: InputMaybe<Order_By>;
    placement_group?: InputMaybe<Order_By>;
    placement_group_slots_aggregate?: InputMaybe<Placement_Group_Slots_Aggregate_Order_By>;
    size?: InputMaybe<Order_By>;
    slice_address?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** select columns of table "blobs" */
declare enum Blobs_Select_Column {
    /** column name */
    BlobCommitment = "blob_commitment",
    /** column name */
    BlobName = "blob_name",
    /** column name */
    CreatedAt = "created_at",
    /** column name */
    ExpiresAt = "expires_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    IsWritten = "is_written",
    /** column name */
    NumChunksets = "num_chunksets",
    /** column name */
    Owner = "owner",
    /** column name */
    PlacementGroup = "placement_group",
    /** column name */
    Size = "size",
    /** column name */
    SliceAddress = "slice_address",
    /** column name */
    UpdatedAt = "updated_at"
}
/** aggregate stddev on columns */
type Blobs_Stddev_Fields = {
    __typename?: 'blobs_stddev_fields';
    created_at?: Maybe<Scalars['Float']['output']>;
    expires_at?: Maybe<Scalars['Float']['output']>;
    is_deleted?: Maybe<Scalars['Float']['output']>;
    is_written?: Maybe<Scalars['Float']['output']>;
    num_chunksets?: Maybe<Scalars['Float']['output']>;
    size?: Maybe<Scalars['Float']['output']>;
    updated_at?: Maybe<Scalars['Float']['output']>;
};
/** aggregate stddev_pop on columns */
type Blobs_Stddev_Pop_Fields = {
    __typename?: 'blobs_stddev_pop_fields';
    created_at?: Maybe<Scalars['Float']['output']>;
    expires_at?: Maybe<Scalars['Float']['output']>;
    is_deleted?: Maybe<Scalars['Float']['output']>;
    is_written?: Maybe<Scalars['Float']['output']>;
    num_chunksets?: Maybe<Scalars['Float']['output']>;
    size?: Maybe<Scalars['Float']['output']>;
    updated_at?: Maybe<Scalars['Float']['output']>;
};
/** aggregate stddev_samp on columns */
type Blobs_Stddev_Samp_Fields = {
    __typename?: 'blobs_stddev_samp_fields';
    created_at?: Maybe<Scalars['Float']['output']>;
    expires_at?: Maybe<Scalars['Float']['output']>;
    is_deleted?: Maybe<Scalars['Float']['output']>;
    is_written?: Maybe<Scalars['Float']['output']>;
    num_chunksets?: Maybe<Scalars['Float']['output']>;
    size?: Maybe<Scalars['Float']['output']>;
    updated_at?: Maybe<Scalars['Float']['output']>;
};
/** Streaming cursor of the table "blobs" */
type Blobs_Stream_Cursor_Input = {
    /** Stream column input with initial value */
    initial_value: Blobs_Stream_Cursor_Value_Input;
    /** cursor ordering */
    ordering?: InputMaybe<Cursor_Ordering>;
};
/** Initial value of the column from where the streaming should start */
type Blobs_Stream_Cursor_Value_Input = {
    blob_commitment?: InputMaybe<Scalars['String']['input']>;
    blob_name?: InputMaybe<Scalars['String']['input']>;
    created_at?: InputMaybe<Scalars['numeric']['input']>;
    expires_at?: InputMaybe<Scalars['numeric']['input']>;
    is_deleted?: InputMaybe<Scalars['numeric']['input']>;
    is_written?: InputMaybe<Scalars['numeric']['input']>;
    num_chunksets?: InputMaybe<Scalars['numeric']['input']>;
    owner?: InputMaybe<Scalars['String']['input']>;
    placement_group?: InputMaybe<Scalars['String']['input']>;
    size?: InputMaybe<Scalars['numeric']['input']>;
    slice_address?: InputMaybe<Scalars['String']['input']>;
    updated_at?: InputMaybe<Scalars['numeric']['input']>;
};
/** aggregate sum on columns */
type Blobs_Sum_Fields = {
    __typename?: 'blobs_sum_fields';
    created_at?: Maybe<Scalars['numeric']['output']>;
    expires_at?: Maybe<Scalars['numeric']['output']>;
    is_deleted?: Maybe<Scalars['numeric']['output']>;
    is_written?: Maybe<Scalars['numeric']['output']>;
    num_chunksets?: Maybe<Scalars['numeric']['output']>;
    size?: Maybe<Scalars['numeric']['output']>;
    updated_at?: Maybe<Scalars['numeric']['output']>;
};
/** aggregate var_pop on columns */
type Blobs_Var_Pop_Fields = {
    __typename?: 'blobs_var_pop_fields';
    created_at?: Maybe<Scalars['Float']['output']>;
    expires_at?: Maybe<Scalars['Float']['output']>;
    is_deleted?: Maybe<Scalars['Float']['output']>;
    is_written?: Maybe<Scalars['Float']['output']>;
    num_chunksets?: Maybe<Scalars['Float']['output']>;
    size?: Maybe<Scalars['Float']['output']>;
    updated_at?: Maybe<Scalars['Float']['output']>;
};
/** aggregate var_samp on columns */
type Blobs_Var_Samp_Fields = {
    __typename?: 'blobs_var_samp_fields';
    created_at?: Maybe<Scalars['Float']['output']>;
    expires_at?: Maybe<Scalars['Float']['output']>;
    is_deleted?: Maybe<Scalars['Float']['output']>;
    is_written?: Maybe<Scalars['Float']['output']>;
    num_chunksets?: Maybe<Scalars['Float']['output']>;
    size?: Maybe<Scalars['Float']['output']>;
    updated_at?: Maybe<Scalars['Float']['output']>;
};
/** aggregate variance on columns */
type Blobs_Variance_Fields = {
    __typename?: 'blobs_variance_fields';
    created_at?: Maybe<Scalars['Float']['output']>;
    expires_at?: Maybe<Scalars['Float']['output']>;
    is_deleted?: Maybe<Scalars['Float']['output']>;
    is_written?: Maybe<Scalars['Float']['output']>;
    num_chunksets?: Maybe<Scalars['Float']['output']>;
    size?: Maybe<Scalars['Float']['output']>;
    updated_at?: Maybe<Scalars['Float']['output']>;
};
/** ordering argument of a cursor */
declare enum Cursor_Ordering {
    /** ascending ordering of the cursor */
    Asc = "ASC",
    /** descending ordering of the cursor */
    Desc = "DESC"
}
/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
type Numeric_Comparison_Exp = {
    _eq?: InputMaybe<Scalars['numeric']['input']>;
    _gt?: InputMaybe<Scalars['numeric']['input']>;
    _gte?: InputMaybe<Scalars['numeric']['input']>;
    _in?: InputMaybe<Array<Scalars['numeric']['input']>>;
    _is_null?: InputMaybe<Scalars['Boolean']['input']>;
    _lt?: InputMaybe<Scalars['numeric']['input']>;
    _lte?: InputMaybe<Scalars['numeric']['input']>;
    _neq?: InputMaybe<Scalars['numeric']['input']>;
    _nin?: InputMaybe<Array<Scalars['numeric']['input']>>;
};
/** column ordering options */
declare enum Order_By {
    /** in ascending order, nulls last */
    Asc = "asc",
    /** in ascending order, nulls first */
    AscNullsFirst = "asc_nulls_first",
    /** in ascending order, nulls last */
    AscNullsLast = "asc_nulls_last",
    /** in descending order, nulls first */
    Desc = "desc",
    /** in descending order, nulls first */
    DescNullsFirst = "desc_nulls_first",
    /** in descending order, nulls last */
    DescNullsLast = "desc_nulls_last"
}
/** columns and relationships of "placement_group_slots" */
type Placement_Group_Slots = {
    __typename?: 'placement_group_slots';
    placement_group: Scalars['String']['output'];
    slot_index: Scalars['numeric']['output'];
    status: Scalars['String']['output'];
    storage_provider: Scalars['String']['output'];
    updated_at: Scalars['numeric']['output'];
};
/** order by aggregate values of table "placement_group_slots" */
type Placement_Group_Slots_Aggregate_Order_By = {
    avg?: InputMaybe<Placement_Group_Slots_Avg_Order_By>;
    count?: InputMaybe<Order_By>;
    max?: InputMaybe<Placement_Group_Slots_Max_Order_By>;
    min?: InputMaybe<Placement_Group_Slots_Min_Order_By>;
    stddev?: InputMaybe<Placement_Group_Slots_Stddev_Order_By>;
    stddev_pop?: InputMaybe<Placement_Group_Slots_Stddev_Pop_Order_By>;
    stddev_samp?: InputMaybe<Placement_Group_Slots_Stddev_Samp_Order_By>;
    sum?: InputMaybe<Placement_Group_Slots_Sum_Order_By>;
    var_pop?: InputMaybe<Placement_Group_Slots_Var_Pop_Order_By>;
    var_samp?: InputMaybe<Placement_Group_Slots_Var_Samp_Order_By>;
    variance?: InputMaybe<Placement_Group_Slots_Variance_Order_By>;
};
/** order by avg() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Avg_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** Boolean expression to filter rows from the table "placement_group_slots". All fields are combined with a logical 'AND'. */
type Placement_Group_Slots_Bool_Exp = {
    _and?: InputMaybe<Array<Placement_Group_Slots_Bool_Exp>>;
    _not?: InputMaybe<Placement_Group_Slots_Bool_Exp>;
    _or?: InputMaybe<Array<Placement_Group_Slots_Bool_Exp>>;
    placement_group?: InputMaybe<String_Comparison_Exp>;
    slot_index?: InputMaybe<Numeric_Comparison_Exp>;
    status?: InputMaybe<String_Comparison_Exp>;
    storage_provider?: InputMaybe<String_Comparison_Exp>;
    updated_at?: InputMaybe<Numeric_Comparison_Exp>;
};
/** order by max() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Max_Order_By = {
    placement_group?: InputMaybe<Order_By>;
    slot_index?: InputMaybe<Order_By>;
    status?: InputMaybe<Order_By>;
    storage_provider?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** order by min() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Min_Order_By = {
    placement_group?: InputMaybe<Order_By>;
    slot_index?: InputMaybe<Order_By>;
    status?: InputMaybe<Order_By>;
    storage_provider?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** Ordering options when selecting data from "placement_group_slots". */
type Placement_Group_Slots_Order_By = {
    placement_group?: InputMaybe<Order_By>;
    slot_index?: InputMaybe<Order_By>;
    status?: InputMaybe<Order_By>;
    storage_provider?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** select columns of table "placement_group_slots" */
declare enum Placement_Group_Slots_Select_Column {
    /** column name */
    PlacementGroup = "placement_group",
    /** column name */
    SlotIndex = "slot_index",
    /** column name */
    Status = "status",
    /** column name */
    StorageProvider = "storage_provider",
    /** column name */
    UpdatedAt = "updated_at"
}
/** order by stddev() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Stddev_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** order by stddev_pop() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Stddev_Pop_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** order by stddev_samp() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Stddev_Samp_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** Streaming cursor of the table "placement_group_slots" */
type Placement_Group_Slots_Stream_Cursor_Input = {
    /** Stream column input with initial value */
    initial_value: Placement_Group_Slots_Stream_Cursor_Value_Input;
    /** cursor ordering */
    ordering?: InputMaybe<Cursor_Ordering>;
};
/** Initial value of the column from where the streaming should start */
type Placement_Group_Slots_Stream_Cursor_Value_Input = {
    placement_group?: InputMaybe<Scalars['String']['input']>;
    slot_index?: InputMaybe<Scalars['numeric']['input']>;
    status?: InputMaybe<Scalars['String']['input']>;
    storage_provider?: InputMaybe<Scalars['String']['input']>;
    updated_at?: InputMaybe<Scalars['numeric']['input']>;
};
/** order by sum() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Sum_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** order by var_pop() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Var_Pop_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** order by var_samp() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Var_Samp_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** order by variance() on columns of table "placement_group_slots" */
type Placement_Group_Slots_Variance_Order_By = {
    slot_index?: InputMaybe<Order_By>;
    updated_at?: InputMaybe<Order_By>;
};
/** columns and relationships of "processor_status" */
type Processor_Status = {
    __typename?: 'processor_status';
    last_success_version: Scalars['bigint']['output'];
    last_transaction_timestamp?: Maybe<Scalars['timestamp']['output']>;
    last_updated: Scalars['timestamp']['output'];
};
/** Boolean expression to filter rows from the table "processor_status". All fields are combined with a logical 'AND'. */
type Processor_Status_Bool_Exp = {
    _and?: InputMaybe<Array<Processor_Status_Bool_Exp>>;
    _not?: InputMaybe<Processor_Status_Bool_Exp>;
    _or?: InputMaybe<Array<Processor_Status_Bool_Exp>>;
    last_success_version?: InputMaybe<Bigint_Comparison_Exp>;
    last_transaction_timestamp?: InputMaybe<Timestamp_Comparison_Exp>;
    last_updated?: InputMaybe<Timestamp_Comparison_Exp>;
};
/** Ordering options when selecting data from "processor_status". */
type Processor_Status_Order_By = {
    last_success_version?: InputMaybe<Order_By>;
    last_transaction_timestamp?: InputMaybe<Order_By>;
    last_updated?: InputMaybe<Order_By>;
};
/** select columns of table "processor_status" */
declare enum Processor_Status_Select_Column {
    /** column name */
    LastSuccessVersion = "last_success_version",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastUpdated = "last_updated"
}
/** Streaming cursor of the table "processor_status" */
type Processor_Status_Stream_Cursor_Input = {
    /** Stream column input with initial value */
    initial_value: Processor_Status_Stream_Cursor_Value_Input;
    /** cursor ordering */
    ordering?: InputMaybe<Cursor_Ordering>;
};
/** Initial value of the column from where the streaming should start */
type Processor_Status_Stream_Cursor_Value_Input = {
    last_success_version?: InputMaybe<Scalars['bigint']['input']>;
    last_transaction_timestamp?: InputMaybe<Scalars['timestamp']['input']>;
    last_updated?: InputMaybe<Scalars['timestamp']['input']>;
};
type Query_Root = {
    __typename?: 'query_root';
    /** fetch data from the table: "blob_activities" */
    blob_activities: Array<Blob_Activities>;
    /** fetch aggregated fields from the table: "blob_activities" */
    blob_activities_aggregate: Blob_Activities_Aggregate;
    /** fetch data from the table: "blob_activities" using primary key columns */
    blob_activities_by_pk?: Maybe<Blob_Activities>;
    /** fetch data from the table: "blobs" */
    blobs: Array<Blobs>;
    /** fetch aggregated fields from the table: "blobs" */
    blobs_aggregate: Blobs_Aggregate;
    /** fetch data from the table: "blobs" using primary key columns */
    blobs_by_pk?: Maybe<Blobs>;
    /** An array relationship */
    placement_group_slots: Array<Placement_Group_Slots>;
    /** fetch data from the table: "placement_group_slots" using primary key columns */
    placement_group_slots_by_pk?: Maybe<Placement_Group_Slots>;
    /** fetch data from the table: "processor_status" */
    processor_status: Array<Processor_Status>;
};
type Query_RootBlob_ActivitiesArgs = {
    distinct_on?: InputMaybe<Array<Blob_Activities_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blob_Activities_Order_By>>;
    where?: InputMaybe<Blob_Activities_Bool_Exp>;
};
type Query_RootBlob_Activities_AggregateArgs = {
    distinct_on?: InputMaybe<Array<Blob_Activities_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blob_Activities_Order_By>>;
    where?: InputMaybe<Blob_Activities_Bool_Exp>;
};
type Query_RootBlob_Activities_By_PkArgs = {
    event_index: Scalars['numeric']['input'];
    event_type: Scalars['String']['input'];
    transaction_hash: Scalars['String']['input'];
};
type Query_RootBlobsArgs = {
    distinct_on?: InputMaybe<Array<Blobs_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blobs_Order_By>>;
    where?: InputMaybe<Blobs_Bool_Exp>;
};
type Query_RootBlobs_AggregateArgs = {
    distinct_on?: InputMaybe<Array<Blobs_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blobs_Order_By>>;
    where?: InputMaybe<Blobs_Bool_Exp>;
};
type Query_RootBlobs_By_PkArgs = {
    blob_name: Scalars['String']['input'];
};
type Query_RootPlacement_Group_SlotsArgs = {
    distinct_on?: InputMaybe<Array<Placement_Group_Slots_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Placement_Group_Slots_Order_By>>;
    where?: InputMaybe<Placement_Group_Slots_Bool_Exp>;
};
type Query_RootPlacement_Group_Slots_By_PkArgs = {
    placement_group: Scalars['String']['input'];
    slot_index: Scalars['numeric']['input'];
};
type Query_RootProcessor_StatusArgs = {
    distinct_on?: InputMaybe<Array<Processor_Status_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Processor_Status_Order_By>>;
    where?: InputMaybe<Processor_Status_Bool_Exp>;
};
type Subscription_Root = {
    __typename?: 'subscription_root';
    /** fetch data from the table: "blob_activities" */
    blob_activities: Array<Blob_Activities>;
    /** fetch aggregated fields from the table: "blob_activities" */
    blob_activities_aggregate: Blob_Activities_Aggregate;
    /** fetch data from the table: "blob_activities" using primary key columns */
    blob_activities_by_pk?: Maybe<Blob_Activities>;
    /** fetch data from the table in a streaming manner: "blob_activities" */
    blob_activities_stream: Array<Blob_Activities>;
    /** fetch data from the table: "blobs" */
    blobs: Array<Blobs>;
    /** fetch aggregated fields from the table: "blobs" */
    blobs_aggregate: Blobs_Aggregate;
    /** fetch data from the table: "blobs" using primary key columns */
    blobs_by_pk?: Maybe<Blobs>;
    /** fetch data from the table in a streaming manner: "blobs" */
    blobs_stream: Array<Blobs>;
    /** An array relationship */
    placement_group_slots: Array<Placement_Group_Slots>;
    /** fetch data from the table: "placement_group_slots" using primary key columns */
    placement_group_slots_by_pk?: Maybe<Placement_Group_Slots>;
    /** fetch data from the table in a streaming manner: "placement_group_slots" */
    placement_group_slots_stream: Array<Placement_Group_Slots>;
    /** fetch data from the table: "processor_status" */
    processor_status: Array<Processor_Status>;
    /** fetch data from the table in a streaming manner: "processor_status" */
    processor_status_stream: Array<Processor_Status>;
};
type Subscription_RootBlob_ActivitiesArgs = {
    distinct_on?: InputMaybe<Array<Blob_Activities_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blob_Activities_Order_By>>;
    where?: InputMaybe<Blob_Activities_Bool_Exp>;
};
type Subscription_RootBlob_Activities_AggregateArgs = {
    distinct_on?: InputMaybe<Array<Blob_Activities_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blob_Activities_Order_By>>;
    where?: InputMaybe<Blob_Activities_Bool_Exp>;
};
type Subscription_RootBlob_Activities_By_PkArgs = {
    event_index: Scalars['numeric']['input'];
    event_type: Scalars['String']['input'];
    transaction_hash: Scalars['String']['input'];
};
type Subscription_RootBlob_Activities_StreamArgs = {
    batch_size: Scalars['Int']['input'];
    cursor: Array<InputMaybe<Blob_Activities_Stream_Cursor_Input>>;
    where?: InputMaybe<Blob_Activities_Bool_Exp>;
};
type Subscription_RootBlobsArgs = {
    distinct_on?: InputMaybe<Array<Blobs_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blobs_Order_By>>;
    where?: InputMaybe<Blobs_Bool_Exp>;
};
type Subscription_RootBlobs_AggregateArgs = {
    distinct_on?: InputMaybe<Array<Blobs_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Blobs_Order_By>>;
    where?: InputMaybe<Blobs_Bool_Exp>;
};
type Subscription_RootBlobs_By_PkArgs = {
    blob_name: Scalars['String']['input'];
};
type Subscription_RootBlobs_StreamArgs = {
    batch_size: Scalars['Int']['input'];
    cursor: Array<InputMaybe<Blobs_Stream_Cursor_Input>>;
    where?: InputMaybe<Blobs_Bool_Exp>;
};
type Subscription_RootPlacement_Group_SlotsArgs = {
    distinct_on?: InputMaybe<Array<Placement_Group_Slots_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Placement_Group_Slots_Order_By>>;
    where?: InputMaybe<Placement_Group_Slots_Bool_Exp>;
};
type Subscription_RootPlacement_Group_Slots_By_PkArgs = {
    placement_group: Scalars['String']['input'];
    slot_index: Scalars['numeric']['input'];
};
type Subscription_RootPlacement_Group_Slots_StreamArgs = {
    batch_size: Scalars['Int']['input'];
    cursor: Array<InputMaybe<Placement_Group_Slots_Stream_Cursor_Input>>;
    where?: InputMaybe<Placement_Group_Slots_Bool_Exp>;
};
type Subscription_RootProcessor_StatusArgs = {
    distinct_on?: InputMaybe<Array<Processor_Status_Select_Column>>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<Array<Processor_Status_Order_By>>;
    where?: InputMaybe<Processor_Status_Bool_Exp>;
};
type Subscription_RootProcessor_Status_StreamArgs = {
    batch_size: Scalars['Int']['input'];
    cursor: Array<InputMaybe<Processor_Status_Stream_Cursor_Input>>;
    where?: InputMaybe<Processor_Status_Bool_Exp>;
};
/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
type Timestamp_Comparison_Exp = {
    _eq?: InputMaybe<Scalars['timestamp']['input']>;
    _gt?: InputMaybe<Scalars['timestamp']['input']>;
    _gte?: InputMaybe<Scalars['timestamp']['input']>;
    _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
    _is_null?: InputMaybe<Scalars['Boolean']['input']>;
    _lt?: InputMaybe<Scalars['timestamp']['input']>;
    _lte?: InputMaybe<Scalars['timestamp']['input']>;
    _neq?: InputMaybe<Scalars['timestamp']['input']>;
    _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};
type GetBlobsQueryVariables = Exact<{
    where?: InputMaybe<Blobs_Bool_Exp>;
    orderBy?: InputMaybe<Array<Blobs_Order_By> | Blobs_Order_By>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
}>;
type GetBlobsQuery = {
    __typename?: 'query_root';
    blobs: Array<{
        __typename?: 'blobs';
        owner: string;
        blob_commitment: string;
        blob_name: string;
        created_at: any;
        expires_at: any;
        num_chunksets: any;
        is_deleted: any;
        is_written: any;
        placement_group: string;
        size: any;
        updated_at: any;
        slice_address: string;
    }>;
};
type GetBlobActivitiesQueryVariables = Exact<{
    where?: InputMaybe<Blob_Activities_Bool_Exp>;
    orderBy?: InputMaybe<Array<Blob_Activities_Order_By> | Blob_Activities_Order_By>;
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
}>;
type GetBlobActivitiesQuery = {
    __typename?: 'query_root';
    blob_activities: Array<{
        __typename?: 'blob_activities';
        blob_name: string;
        event_index: any;
        event_type: string;
        transaction_hash: string;
        transaction_version: any;
        timestamp: any;
    }>;
};
type GetBlobsCountQueryVariables = Exact<{
    where?: InputMaybe<Blobs_Bool_Exp>;
}>;
type GetBlobsCountQuery = {
    __typename?: 'query_root';
    blobs_aggregate: {
        __typename?: 'blobs_aggregate';
        aggregate?: {
            __typename?: 'blobs_aggregate_fields';
            count: number;
        } | null;
    };
};
type GetBlobActivitiesCountQueryVariables = Exact<{
    where?: InputMaybe<Blob_Activities_Bool_Exp>;
}>;
type GetBlobActivitiesCountQuery = {
    __typename?: 'query_root';
    blob_activities_aggregate: {
        __typename?: 'blob_activities_aggregate';
        aggregate?: {
            __typename?: 'blob_activities_aggregate_fields';
            count: number;
        } | null;
    };
};
declare const GetBlobsDocument: graphql.DocumentNode;
declare const GetBlobActivitiesDocument: graphql.DocumentNode;
declare const GetBlobsCountDocument: graphql.DocumentNode;
declare const GetBlobActivitiesCountDocument: graphql.DocumentNode;
type SdkFunctionWrapper = <T>(action: (requestHeaders?: Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;
declare function getSdk(client: GraphQLClient, withWrapper?: SdkFunctionWrapper): {
    getBlobs(variables?: GetBlobsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders, signal?: RequestInit["signal"]): Promise<GetBlobsQuery>;
    getBlobActivities(variables?: GetBlobActivitiesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders, signal?: RequestInit["signal"]): Promise<GetBlobActivitiesQuery>;
    getBlobsCount(variables?: GetBlobsCountQueryVariables, requestHeaders?: GraphQLClientRequestHeaders, signal?: RequestInit["signal"]): Promise<GetBlobsCountQuery>;
    getBlobActivitiesCount(variables?: GetBlobActivitiesCountQueryVariables, requestHeaders?: GraphQLClientRequestHeaders, signal?: RequestInit["signal"]): Promise<GetBlobActivitiesCountQuery>;
};
type Sdk = ReturnType<typeof getSdk>;

export { type Bigint_Comparison_Exp, type Blob_Activities, type Blob_Activities_Aggregate, type Blob_Activities_Aggregate_Fields, type Blob_Activities_Aggregate_FieldsCountArgs, type Blob_Activities_Avg_Fields, type Blob_Activities_Bool_Exp, type Blob_Activities_Max_Fields, type Blob_Activities_Min_Fields, type Blob_Activities_Order_By, Blob_Activities_Select_Column, type Blob_Activities_Stddev_Fields, type Blob_Activities_Stddev_Pop_Fields, type Blob_Activities_Stddev_Samp_Fields, type Blob_Activities_Stream_Cursor_Input, type Blob_Activities_Stream_Cursor_Value_Input, type Blob_Activities_Sum_Fields, type Blob_Activities_Var_Pop_Fields, type Blob_Activities_Var_Samp_Fields, type Blob_Activities_Variance_Fields, type Blobs, type BlobsPlacement_Group_SlotsArgs, type Blobs_Aggregate, type Blobs_Aggregate_Fields, type Blobs_Aggregate_FieldsCountArgs, type Blobs_Avg_Fields, type Blobs_Bool_Exp, type Blobs_Max_Fields, type Blobs_Min_Fields, type Blobs_Order_By, Blobs_Select_Column, type Blobs_Stddev_Fields, type Blobs_Stddev_Pop_Fields, type Blobs_Stddev_Samp_Fields, type Blobs_Stream_Cursor_Input, type Blobs_Stream_Cursor_Value_Input, type Blobs_Sum_Fields, type Blobs_Var_Pop_Fields, type Blobs_Var_Samp_Fields, type Blobs_Variance_Fields, Cursor_Ordering, type Exact, GetBlobActivitiesCountDocument, type GetBlobActivitiesCountQuery, type GetBlobActivitiesCountQueryVariables, GetBlobActivitiesDocument, type GetBlobActivitiesQuery, type GetBlobActivitiesQueryVariables, GetBlobsCountDocument, type GetBlobsCountQuery, type GetBlobsCountQueryVariables, GetBlobsDocument, type GetBlobsQuery, type GetBlobsQueryVariables, type Incremental, type InputMaybe, type MakeEmpty, type MakeMaybe, type MakeOptional, type Maybe, type Numeric_Comparison_Exp, Order_By, type Placement_Group_Slots, type Placement_Group_Slots_Aggregate_Order_By, type Placement_Group_Slots_Avg_Order_By, type Placement_Group_Slots_Bool_Exp, type Placement_Group_Slots_Max_Order_By, type Placement_Group_Slots_Min_Order_By, type Placement_Group_Slots_Order_By, Placement_Group_Slots_Select_Column, type Placement_Group_Slots_Stddev_Order_By, type Placement_Group_Slots_Stddev_Pop_Order_By, type Placement_Group_Slots_Stddev_Samp_Order_By, type Placement_Group_Slots_Stream_Cursor_Input, type Placement_Group_Slots_Stream_Cursor_Value_Input, type Placement_Group_Slots_Sum_Order_By, type Placement_Group_Slots_Var_Pop_Order_By, type Placement_Group_Slots_Var_Samp_Order_By, type Placement_Group_Slots_Variance_Order_By, type Processor_Status, type Processor_Status_Bool_Exp, type Processor_Status_Order_By, Processor_Status_Select_Column, type Processor_Status_Stream_Cursor_Input, type Processor_Status_Stream_Cursor_Value_Input, type Query_Root, type Query_RootBlob_ActivitiesArgs, type Query_RootBlob_Activities_AggregateArgs, type Query_RootBlob_Activities_By_PkArgs, type Query_RootBlobsArgs, type Query_RootBlobs_AggregateArgs, type Query_RootBlobs_By_PkArgs, type Query_RootPlacement_Group_SlotsArgs, type Query_RootPlacement_Group_Slots_By_PkArgs, type Query_RootProcessor_StatusArgs, type Scalars, type Sdk, type SdkFunctionWrapper, type String_Comparison_Exp, type Subscription_Root, type Subscription_RootBlob_ActivitiesArgs, type Subscription_RootBlob_Activities_AggregateArgs, type Subscription_RootBlob_Activities_By_PkArgs, type Subscription_RootBlob_Activities_StreamArgs, type Subscription_RootBlobsArgs, type Subscription_RootBlobs_AggregateArgs, type Subscription_RootBlobs_By_PkArgs, type Subscription_RootBlobs_StreamArgs, type Subscription_RootPlacement_Group_SlotsArgs, type Subscription_RootPlacement_Group_Slots_By_PkArgs, type Subscription_RootPlacement_Group_Slots_StreamArgs, type Subscription_RootProcessor_StatusArgs, type Subscription_RootProcessor_Status_StreamArgs, type Timestamp_Comparison_Exp, getSdk };
