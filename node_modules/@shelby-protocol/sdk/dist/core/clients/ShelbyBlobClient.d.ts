import { Aptos, AccountAddress, AccountAddressInput, Account, InputGenerateTransactionOptions, PendingTransactionResponse, InputGenerateTransactionPayloadData } from '@aptos-labs/ts-sdk';
import { BlobName } from '../layout.js';
import { BlobMetadata, BlobActivity, StorageProviderAck } from '../types/blobs.js';
import { ShelbyIndexerClient } from '../operations/index.js';
import { Blobs_Order_By, Blobs_Bool_Exp, Blob_Activities_Bool_Exp, Blob_Activities_Order_By } from '../operations/generated/sdk.js';
import { ShelbyClientConfig } from './ShelbyClientConfig.js';
import 'zod';
import '../../clay-codes-pdZFxI_B.js';
import '@shelby-protocol/clay-codes';
import 'graphql-request';
import 'graphql';
import '../networks.js';

interface WriteBlobCommitmentsOptions {
    build?: {
        options?: InputGenerateTransactionOptions;
    };
    chunksetSizeBytes?: number;
}
interface AckTransactionOptions {
    build?: {
        options?: InputGenerateTransactionOptions;
    };
}
declare class ShelbyBlobClient {
    readonly aptos: Aptos;
    readonly deployer: AccountAddress;
    readonly indexer: ShelbyIndexerClient;
    /**
     * The ShelbyBlobClient is used to interact with the Shelby contract on the Aptos blockchain. This
     * includes functions for registering blob commitments and retrieving blob metadata.
     *
     * @param config - The client configuration object.
     * @param config.network - The Shelby network to use.
     *
     * @example
     * ```typescript
     * const blobClient = new ShelbyBlobClient({
     *   aptos: {
     *     network: Network.SHELBYNET,
     *     clientConfig: {
     *       API_KEY: "AG-***",
     *     },
     *   },
     * });
     * ```
     */
    constructor(config: ShelbyClientConfig);
    /**
     * Retrieves the blob metadata from the blockchain. If it does not exist,
     * returns `undefined`.
     *
     * @param params.account - The account namespace the blob is stored in (e.g. "0x1")
     * @param params.name - The name of the blob (e.g. "foo/bar")
     * @returns The blob metadata.
     *
     * @example
     * ```typescript
     * const metadata = await client.getBlobMetadata({
     *   account: AccountAddress.fromString("0x1"),
     *   name: "foo/bar.txt",
     * });
     * ```
     */
    getBlobMetadata(params: {
        account: AccountAddressInput;
        name: BlobName;
    }): Promise<BlobMetadata | undefined>;
    /**
     * Retrieves all the blobs and their metadata for an account from the
     * blockchain.
     *
     * @param params.account - The account namespace the blobs are stored in (e.g. "0x1")
     * @param params.pagination (optional) - The pagination options.
     * @param params.orderBy (optional) - The order by clause to sort the blobs by.
     * @returns The blob metadata for all the blobs for the account.
     *
     * @example
     * ```typescript
     * // BlobMetadata[]
     * const blobs = await client.getAccountBlobs({
     *   account: AccountAddress.fromString("0x1"),
     * });
     * ```
     */
    getAccountBlobs(params: {
        account: AccountAddressInput;
        pagination?: {
            limit?: number;
            offset?: number;
        };
        orderBy?: Blobs_Order_By;
        where?: Omit<Blobs_Bool_Exp, "owner">;
    }): Promise<BlobMetadata[]>;
    /**
     * Retrieves blobs and their metadata from the blockchain.
     *
     * @param params.where (optional) - The where clause to filter the blobs by.
     * @param params.pagination (optional) - The pagination options.
     * @param params.orderBy (optional) - The order by clause to sort the blobs by.
     * @returns The blob metadata for all the blobs that match the where clause.
     *
     * @example
     * ```typescript
     * // BlobMetadata[]
     * const blobs = await client.getBlobs({
     *   where: { owner: { _eq: AccountAddress.fromString("0x1").toString() } },
     * });
     * ```
     */
    getBlobs(params?: {
        where?: Blobs_Bool_Exp;
        pagination?: {
            limit?: number;
            offset?: number;
        };
        orderBy?: Blobs_Order_By;
    }): Promise<BlobMetadata[]>;
    getBlobActivities(params: {
        where?: Blob_Activities_Bool_Exp;
        pagination?: {
            limit?: number;
            offset?: number;
        };
        orderBy?: Blob_Activities_Order_By;
    }): Promise<BlobActivity[]>;
    /**
     * Retrieves the total number of blobs from the blockchain.
     *
     * @param params.where (optional) - The where clause to filter the blobs by.
     * @returns The total number of blobs.
     *
     * @example
     * ```typescript
     * const count = await client.getBlobsCount();
     * ```
     */
    getBlobsCount(params: {
        where?: Blobs_Bool_Exp;
    }): Promise<number>;
    /**
     * Retrieves the total number of blob activities from the blockchain.
     *
     * @param params.where (optional) - The where clause to filter the blob activities by.
     * @returns The total number of blob activities.
     *
     * @example
     * ```typescript
     * const count = await client.getBlobActivitiesCount();
     * ```
     */
    getBlobActivitiesCount(params: {
        where?: Blob_Activities_Bool_Exp;
    }): Promise<number>;
    /**
     * Registers a blob on the blockchain by writing its merkle root and metadata.
     *
     * @param params.account - The account that is signing and paying for the transaction.
     * @param params.blobName - The name/path of the blob (e.g. "foo/bar.txt").
     * @param params.blobMerkleRoot - The merkle root of the blob commitments.
     * @param params.size - The size of the blob in bytes.
     * @param params.expirationMicros - The expiration time of the blob in microseconds.
     * @param params.options - Optional transaction building options.
     * @param params.options.chunksetSizeBytes - Custom chunkset size (defaults to DEFAULT_CHUNKSET_SIZE_BYTES).
     * @param params.options.build - Additional Aptos transaction building options.
     *
     * @returns An object containing the pending transaction.
     *
     * @example
     * ```typescript
     * const provider = await ClayErasureCodingProvider.create();
     * const blobCommitments = await generateCommitments(provider, data);
     *
     * const { transaction } = await client.registerBlob({
     *   account: signer,
     *   blobName: "foo/bar.txt",
     *   blobMerkleRoot: blobCommitments.blob_merkle_root,
     *   size: data.length,
     *   expirationMicros: Date.now() * 1000 + 3600_000_000, // 1 hour from now in microseconds
     * });
     * ```
     */
    registerBlob(params: {
        account: Account;
        blobName: BlobName;
        blobMerkleRoot: string;
        size: number;
        expirationMicros: number;
        options?: WriteBlobCommitmentsOptions;
    }): Promise<{
        transaction: PendingTransactionResponse;
    }>;
    /**
     * Acks the blob chunksets on-chain. If each chunkset meets the necessary threshold, the entire blob will be marked as written.
     *
     * @param params.account - The account that is signing the transaction.
     * @param params.blobOwner - The account that owns the blob.
     * @param params.blobName - The name of the blob (e.g. "foo/bar")
     * @param params.creationMicros - The creation time of the blob in microseconds.
     * @param params.chunksetIdx - The index of the chunkset being acknowledged.
     * @param params.storageProviderChunksetAcks - The signatures
     * @param params.options - Additional options for transaction building and encoding.
     *
     * @returns The blob commitments and the pending transaction.
     *
     * @example
     * ```typescript
     * const { transaction } = await client.addChunksetAcknowledgements({
     *   account: signer,
     *   blobOwner: owner,
     *   blobName: "foo/bar.txt",
     *   creationMicros, // Taken from the blob metadata at registration time.
     *   chunksetIdx,
     *   storageProviderAcks: An array of StorageProviderAck types, each having the slot index and signature from the SP.
     * });
     * ```
     */
    addChunksetAcknowledgements(params: {
        account: Account;
        blobOwner: AccountAddress;
        blobName: BlobName;
        creationMicros: number;
        chunksetIdx: number;
        storageProviderAcks: StorageProviderAck[];
        options?: AckTransactionOptions;
    }): Promise<{
        transaction: PendingTransactionResponse;
    }>;
    /**
     * Registers multiple blobs on the blockchain by writing their merkle roots and metadata.
     *
     * @param params.account - The account that is signing and paying for the transaction.
     * @param params.expirationMicros - The expiration time of the blobs in microseconds.
     * @param params.blobs - The blobs to register.
     * @param params.blobs.blobName - The name/path of the blob (e.g. "foo/bar.txt").
     * @param params.blobs.blobSize - The size of the blob in bytes.
     * @param params.blobs.blobMerkleRoot - The merkle root of the blob commitments as a hex string.
     * @param params.options - Optional transaction building options.
     * @param params.options.chunksetSizeBytes - Custom chunkset size (defaults to DEFAULT_CHUNKSET_SIZE_BYTES).
     * @param params.options.build - Additional Aptos transaction building options.
     *
     * @returns An object containing the pending transaction.
     *
     * @example
     * ```typescript
     * const provider = await ClayErasureCodingProvider.create();
     * const blobCommitments = await generateCommitments(provider, data);
     *
     * const { transaction } = await client.batchRegisterBlobs({
     *   account: signer,
     *   expirationMicros: Date.now() * 1000 + 3600_000_000, // 1 hour from now in microseconds
     *   blobs: [
     *     {
     *       blobName: "foo/bar.txt",
     *       blobSize: data.length,
     *       blobMerkleRoot: blobCommitments.blob_merkle_root,
     *     },
     *   ],
     * });
     * ```
     */
    batchRegisterBlobs(params: {
        account: Account;
        expirationMicros: number;
        blobs: {
            blobName: BlobName;
            blobSize: number;
            blobMerkleRoot: string;
        }[];
        options?: WriteBlobCommitmentsOptions;
    }): Promise<{
        transaction: PendingTransactionResponse;
    }>;
    /**
     * Creates a transaction payload to register a blob on the blockchain.
     * This is a static helper method for constructing the Move function call payload.
     *
     * @param params.deployer - Optional deployer account address. Defaults to SHELBY_DEPLOYER.
     * @param params.account - The account that will own the blob.
     * @param params.blobName - The name/path of the blob (e.g. "foo/bar.txt").
     * @param params.blobSize - The size of the blob in bytes.
     * @param params.blobMerkleRoot - The merkle root of the blob commitments as a hex string.
     * @param params.expirationMicros - The expiration time of the blob in microseconds.
     * @param params.numChunksets - The total number of chunksets in the blob.
     *
     * @returns An Aptos transaction payload data object for the register_blob Move function.
     *
     * @see https://github.com/shelby/shelby/blob/e08e84742cf2b80ad8bb7227deb3013398076d53/move/shelby_contract/sources/global_metadata.move#L357
     */
    static createRegisterBlobPayload(params: {
        deployer?: AccountAddress;
        account: AccountAddress;
        blobName: BlobName;
        blobSize: number;
        blobMerkleRoot: string;
        expirationMicros: number;
        numChunksets: number;
    }): InputGenerateTransactionPayloadData;
    /**
     * Creates a transaction payload to register multiple blobs on the blockchain.
     * This is a static helper method for constructing the Move function call payload.
     *
     * @param params.deployer - Optional deployer account address. Defaults to SHELBY_DEPLOYER.
     * @param params.account - The account that will own the blobs.
     * @param params.expirationMicros - The expiration time of the blobs in microseconds.
     * @param params.blobs - The blobs to register.
     * @param params.blobs.blobName - The name/path of the blob (e.g. "foo/bar.txt").
     * @param params.blobs.blobSize - The size of the blob in bytes.
     * @param params.blobs.blobMerkleRoot - The merkle root of the blob commitments as a hex string.
     * @param params.blobs.numChunksets - The total number of chunksets in the blob.
     *
     * @returns An Aptos transaction payload data object for the register_multiple_blobs Move function.
     *
     * @see https://github.com/shelby/shelby/blob/e08e84742cf2b80ad8bb7227deb3013398076d53/move/shelby_contract/sources/global_metadata.move#L357
     */
    static createBatchRegisterBlobsPayload(params: {
        deployer?: AccountAddress;
        account: AccountAddress;
        expirationMicros: number;
        blobs: {
            blobName: BlobName;
            blobSize: number;
            blobMerkleRoot: string;
            numChunksets: number;
        }[];
    }): InputGenerateTransactionPayloadData;
    /**
     * Creates a transaction payload to delete a blob on the blockchain.
     * This is a static helper method for constructing the Move function call payload.
     *
     * @param params.deployer - Optional deployer account address. Defaults to SHELBY_DEPLOYER.
     * @param params.blobNameSuffix - The blob name suffix (e.g. "bar.txt").
     *
     * @returns An Aptos transaction payload data object for the delete_blob Move function.
     *
     * @see https://github.com/shelby/shelby/blob/64e9d7b4f0005e586faeb1e4085c79159234b6b6/move/shelby_contract/sources/global_metadata.move#L616
     */
    static createDeleteBlobPayload(params: {
        deployer?: AccountAddress;
        blobNameSuffix: string;
    }): InputGenerateTransactionPayloadData;
    static createChunksetAcknowledgementsPayload(params: {
        blobOwner: AccountAddress;
        blobName: BlobName;
        creationMicros: number;
        chunksetIdx: number;
        storageProviderAcks: StorageProviderAck[];
    }): InputGenerateTransactionPayloadData;
}

export { type AckTransactionOptions, ShelbyBlobClient, type WriteBlobCommitmentsOptions };
