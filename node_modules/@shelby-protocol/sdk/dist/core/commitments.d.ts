import { Hex } from '@aptos-labs/ts-sdk';
import { z } from 'zod';
import { a as ErasureCodingProvider } from '../clay-codes-pdZFxI_B.js';
import '@shelby-protocol/clay-codes';

/**
 * Defines the schema for the commitment format in commitments.json
 * This is used for `shelby encode` and oher commands
 *
 * We use a binary merkle tree of the samples of the blob's chunksets.
 *
 * Definitions:
 * - P = H(C0//C1) (concatenate the two children, and use H to form a parent node)
 *       H currently SHA256
 * - If the right child doesn't exist, use zeros.
 * - blob_merkle_root = the P of the final two children
 * - // indicates binary concatenation
 * ```
 */
/**
 * Represents the (serializable) commitment schema for a single chunkset.
 */
declare const ChunksetCommitmentSchema: z.ZodEffects<z.ZodObject<{
    chunkset_root: z.ZodString;
    chunk_commitments: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    chunkset_root: string;
    chunk_commitments: string[];
}, {
    chunkset_root: string;
    chunk_commitments: string[];
}>, {
    chunkset_root: string;
    chunk_commitments: string[];
}, {
    chunkset_root: string;
    chunk_commitments: string[];
}>;
type ChunksetCommitment = z.infer<typeof ChunksetCommitmentSchema>;
declare function expectedTotalChunksets(rawSize: number, chunksetSize?: number): number;
/**
 * Represents the (serializable) commitment schema for a single blob.
 */
declare const BlobCommitmentsSchema: z.ZodEffects<z.ZodObject<{
    schema_version: z.ZodString;
    raw_data_size: z.ZodNumber;
    blob_merkle_root: z.ZodString;
    chunkset_commitments: z.ZodArray<z.ZodEffects<z.ZodObject<{
        chunkset_root: z.ZodString;
        chunk_commitments: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        chunkset_root: string;
        chunk_commitments: string[];
    }, {
        chunkset_root: string;
        chunk_commitments: string[];
    }>, {
        chunkset_root: string;
        chunk_commitments: string[];
    }, {
        chunkset_root: string;
        chunk_commitments: string[];
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    schema_version: string;
    raw_data_size: number;
    blob_merkle_root: string;
    chunkset_commitments: {
        chunkset_root: string;
        chunk_commitments: string[];
    }[];
}, {
    schema_version: string;
    raw_data_size: number;
    blob_merkle_root: string;
    chunkset_commitments: {
        chunkset_root: string;
        chunk_commitments: string[];
    }[];
}>, {
    schema_version: string;
    raw_data_size: number;
    blob_merkle_root: string;
    chunkset_commitments: {
        chunkset_root: string;
        chunk_commitments: string[];
    }[];
}, {
    schema_version: string;
    raw_data_size: number;
    blob_merkle_root: string;
    chunkset_commitments: {
        chunkset_root: string;
        chunk_commitments: string[];
    }[];
}>;
type BlobCommitments = z.infer<typeof BlobCommitmentsSchema>;
interface GenerateCommitmentsOptions {
    /**
     * When true (default) chunksets are zero padded before encoding.
     * Disable only when the incoming data already matches the provider's
     * systematic capacity and you need to preserve raw byte layout.
     */
    pad?: boolean;
}
/**
 * Create the merkle root of the tree based on the hashes in the parameter. Non-existent siblings use the zero hash.
 *
 * @param leafHashes The hashes forming the leaves of the merkle tree.
 * @returns The root of the Merkle tree.
 */
declare function generateMerkleRoot(leafHashes: Hex[]): Promise<Hex>;
/**
 * Generates the blob commitments for a given data stream.
 *
 * @param provider - Erasure coding backend that will expand chunksets.
 * @param fullData - The data stream to generate commitments for.
 * @param onChunk - A callback that is called for each chunk of data.
 * @param options - Optional overrides for padding behaviour.
 *
 * @returns The blob commitments.
 *
 * @example
 * ```typescript
 * const buffer = new TextEncoder().encode("Hello, world!");
 * const provider = await createDefaultErasureCodingProvider();
 * const commitments = await generateCommitments(provider, buffer);
 * ```
 */
declare function generateCommitments(provider: ErasureCodingProvider, fullData: ReadableStream<Uint8Array> | Uint8Array, onChunk?: (chunksetIdx: number, chunkIdx: number, chunkData: Uint8Array) => Promise<void> | void, options?: GenerateCommitmentsOptions): Promise<BlobCommitments>;

export { type BlobCommitments, BlobCommitmentsSchema, type ChunksetCommitment, ChunksetCommitmentSchema, type GenerateCommitmentsOptions, expectedTotalChunksets, generateCommitments, generateMerkleRoot };
