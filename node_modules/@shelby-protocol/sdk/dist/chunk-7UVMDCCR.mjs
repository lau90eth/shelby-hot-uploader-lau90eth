import {
  getShelbyIndexerClient
} from "./chunk-HFGEQP5N.mjs";
import {
  getAptosConfig
} from "./chunk-RBFWGDMY.mjs";
import {
  createBlobKey
} from "./chunk-OTBLZL2S.mjs";
import {
  expectedTotalChunksets
} from "./chunk-XWAPNLU6.mjs";
import {
  getBlobNameSuffix
} from "./chunk-4JZO2D7T.mjs";
import {
  DEFAULT_CHUNKSET_SIZE_BYTES,
  ERASURE_CODE_AND_CHUNK_MAPPING
} from "./chunk-67F5YZ25.mjs";
import {
  ERASURE_CODE_PARAMS
} from "./chunk-ZPW742E7.mjs";
import {
  SHELBY_DEPLOYER
} from "./chunk-SEXQTDX6.mjs";

// src/core/clients/ShelbyBlobClient.ts
import {
  AccountAddress,
  Aptos,
  AptosConfig,
  Hex,
  MoveVector,
  U32
} from "@aptos-labs/ts-sdk";
var ShelbyBlobClient = class _ShelbyBlobClient {
  aptos;
  deployer;
  indexer;
  /**
   * The ShelbyBlobClient is used to interact with the Shelby contract on the Aptos blockchain. This
   * includes functions for registering blob commitments and retrieving blob metadata.
   *
   * @param config - The client configuration object.
   * @param config.network - The Shelby network to use.
   *
   * @example
   * ```typescript
   * const blobClient = new ShelbyBlobClient({
   *   aptos: {
   *     network: Network.SHELBYNET,
   *     clientConfig: {
   *       API_KEY: "AG-***",
   *     },
   *   },
   * });
   * ```
   */
  constructor(config) {
    const baseAptosConfig = getAptosConfig(config);
    const aptosConfig = new AptosConfig({
      ...baseAptosConfig,
      clientConfig: {
        ...baseAptosConfig.clientConfig,
        // Only use top-level apiKey if no API_KEY is already provided in Aptos settings
        API_KEY: baseAptosConfig.clientConfig?.API_KEY ?? config.apiKey
      }
    });
    this.aptos = new Aptos(aptosConfig);
    this.deployer = config.deployer ?? AccountAddress.fromString(SHELBY_DEPLOYER);
    this.indexer = getShelbyIndexerClient(config);
  }
  /**
   * Retrieves the blob metadata from the blockchain. If it does not exist,
   * returns `undefined`.
   *
   * @param params.account - The account namespace the blob is stored in (e.g. "0x1")
   * @param params.name - The name of the blob (e.g. "foo/bar")
   * @returns The blob metadata.
   *
   * @example
   * ```typescript
   * const metadata = await client.getBlobMetadata({
   *   account: AccountAddress.fromString("0x1"),
   *   name: "foo/bar.txt",
   * });
   * ```
   */
  async getBlobMetadata(params) {
    try {
      const rawMetadata = await this.aptos.view({
        payload: {
          function: `${this.deployer.toString()}::blob_metadata::get_blob_metadata`,
          functionArguments: [
            createBlobKey({
              account: params.account,
              blobName: params.name
            })
          ]
        }
      });
      if (!rawMetadata?.[0]?.vec?.[0]) {
        return void 0;
      }
      const metadata = rawMetadata[0].vec[0];
      let encoding;
      if (metadata.encoding.__variant__ === "ClayCode_16Total_10Data_13Helper") {
        encoding = {
          variant: "clay",
          ...ERASURE_CODE_PARAMS[metadata.encoding.__variant__],
          ...ERASURE_CODE_AND_CHUNK_MAPPING[metadata.encoding.__variant__]
        };
      } else {
        throw new Error(
          "Could not parse encoding from Shelby Smart Contract, this SDK is out of date."
        );
      }
      return {
        blobMerkleRoot: Hex.fromHexInput(
          metadata.blob_commitment
        ).toUint8Array(),
        owner: AccountAddress.fromString(metadata.owner),
        name: params.name,
        blobNameSuffix: getBlobNameSuffix(params.name),
        size: Number(metadata.blob_size),
        encoding,
        expirationMicros: Number(metadata.expiration_micros),
        creationMicros: Number(metadata.creation_micros),
        sliceAddress: AccountAddress.fromString(metadata.slice.inner),
        isWritten: metadata.is_written
      };
    } catch (error) {
      if (error instanceof Error && // Depending on the network, the error message may show up differently.
      (error.message?.includes("sub_status: Some(404)") || error.message?.includes("EBLOB_NOT_FOUND"))) {
        return void 0;
      }
      throw error;
    }
  }
  /**
   * Retrieves all the blobs and their metadata for an account from the
   * blockchain.
   *
   * @param params.account - The account namespace the blobs are stored in (e.g. "0x1")
   * @param params.pagination (optional) - The pagination options.
   * @param params.orderBy (optional) - The order by clause to sort the blobs by.
   * @returns The blob metadata for all the blobs for the account.
   *
   * @example
   * ```typescript
   * // BlobMetadata[]
   * const blobs = await client.getAccountBlobs({
   *   account: AccountAddress.fromString("0x1"),
   * });
   * ```
   */
  getAccountBlobs(params) {
    const { where, ...rest } = params;
    return this.getBlobs({
      where: {
        ...where ?? {},
        owner: { _eq: AccountAddress.from(params.account).toString() }
      },
      pagination: rest.pagination,
      orderBy: rest.orderBy
    });
  }
  /**
   * Retrieves blobs and their metadata from the blockchain.
   *
   * @param params.where (optional) - The where clause to filter the blobs by.
   * @param params.pagination (optional) - The pagination options.
   * @param params.orderBy (optional) - The order by clause to sort the blobs by.
   * @returns The blob metadata for all the blobs that match the where clause.
   *
   * @example
   * ```typescript
   * // BlobMetadata[]
   * const blobs = await client.getBlobs({
   *   where: { owner: { _eq: AccountAddress.fromString("0x1").toString() } },
   * });
   * ```
   */
  async getBlobs(params = {}) {
    const { limit, offset } = params.pagination ?? {};
    const { orderBy, where } = params;
    const currentMicros = Date.now() * 1e3;
    const defaultActiveFilter = {
      expires_at: { _gte: currentMicros },
      is_deleted: { _eq: "0" }
    };
    const finalWhere = where !== void 0 ? { ...defaultActiveFilter, ...where } : defaultActiveFilter;
    const { blobs } = await this.indexer.getBlobs({
      where: finalWhere,
      limit,
      offset,
      orderBy
    });
    return blobs.map(
      (blob) => ({
        owner: AccountAddress.from(blob.owner),
        name: blob.blob_name,
        blobNameSuffix: getBlobNameSuffix(blob.blob_name),
        blobMerkleRoot: Hex.fromHexInput(blob.blob_commitment).toUint8Array(),
        size: Number(blob.size),
        // TODO: Add encoding when supported in NCI
        encoding: {
          variant: "clay",
          ...ERASURE_CODE_PARAMS.ClayCode_16Total_10Data_13Helper,
          ...ERASURE_CODE_AND_CHUNK_MAPPING.ClayCode_16Total_10Data_13Helper
        },
        expirationMicros: Number(blob.expires_at),
        creationMicros: Number(blob.created_at),
        sliceAddress: AccountAddress.from(blob.slice_address),
        isWritten: Boolean(Number(blob.is_written))
      })
    );
  }
  async getBlobActivities(params) {
    const { limit, offset } = params.pagination ?? {};
    const { orderBy, where } = params;
    const { blob_activities } = await this.indexer.getBlobActivities({
      where,
      limit,
      offset,
      orderBy
    });
    const activityTypeMapping = {
      [`${this.deployer.toStringLong()}::blob_metadata::BlobRegisteredEvent`]: "register_blob",
      [`${this.deployer.toStringLong()}::blob_metadata::BlobDeletedEvent`]: "delete_blob",
      [`${this.deployer.toStringLong()}::blob_metadata::BlobExpirationExtendedEvent`]: "extend_blob_expiration",
      [`${this.deployer.toStringLong()}::blob_metadata::BlobWrittenEvent`]: "write_blob"
    };
    return blob_activities.map(
      (activity) => ({
        blobName: activity.blob_name,
        accountAddress: AccountAddress.from(
          activity.blob_name.substring(1, 65)
        ),
        type: activityTypeMapping[activity.event_type] ?? "unknown",
        eventType: activity.event_type,
        eventIndex: activity.event_index,
        transactionHash: activity.transaction_hash,
        transactionVersion: activity.transaction_version,
        timestamp: activity.timestamp
      })
    );
  }
  /**
   * Retrieves the total number of blobs from the blockchain.
   *
   * @param params.where (optional) - The where clause to filter the blobs by.
   * @returns The total number of blobs.
   *
   * @example
   * ```typescript
   * const count = await client.getBlobsCount();
   * ```
   */
  async getBlobsCount(params) {
    const { where } = params;
    const { blobs_aggregate } = await this.indexer.getBlobsCount({ where });
    return blobs_aggregate?.aggregate?.count ?? 0;
  }
  /**
   * Retrieves the total number of blob activities from the blockchain.
   *
   * @param params.where (optional) - The where clause to filter the blob activities by.
   * @returns The total number of blob activities.
   *
   * @example
   * ```typescript
   * const count = await client.getBlobActivitiesCount();
   * ```
   */
  async getBlobActivitiesCount(params) {
    const { where } = params;
    const { blob_activities_aggregate } = await this.indexer.getBlobActivitiesCount({ where });
    return blob_activities_aggregate?.aggregate?.count ?? 0;
  }
  /**
   * Registers a blob on the blockchain by writing its merkle root and metadata.
   *
   * @param params.account - The account that is signing and paying for the transaction.
   * @param params.blobName - The name/path of the blob (e.g. "foo/bar.txt").
   * @param params.blobMerkleRoot - The merkle root of the blob commitments.
   * @param params.size - The size of the blob in bytes.
   * @param params.expirationMicros - The expiration time of the blob in microseconds.
   * @param params.options - Optional transaction building options.
   * @param params.options.chunksetSizeBytes - Custom chunkset size (defaults to DEFAULT_CHUNKSET_SIZE_BYTES).
   * @param params.options.build - Additional Aptos transaction building options.
   *
   * @returns An object containing the pending transaction.
   *
   * @example
   * ```typescript
   * const provider = await ClayErasureCodingProvider.create();
   * const blobCommitments = await generateCommitments(provider, data);
   *
   * const { transaction } = await client.registerBlob({
   *   account: signer,
   *   blobName: "foo/bar.txt",
   *   blobMerkleRoot: blobCommitments.blob_merkle_root,
   *   size: data.length,
   *   expirationMicros: Date.now() * 1000 + 3600_000_000, // 1 hour from now in microseconds
   * });
   * ```
   */
  async registerBlob(params) {
    const chunksetSize = params.options?.chunksetSizeBytes ?? DEFAULT_CHUNKSET_SIZE_BYTES;
    const transaction = await this.aptos.transaction.build.simple({
      ...params.options?.build,
      data: _ShelbyBlobClient.createRegisterBlobPayload({
        deployer: this.deployer,
        account: params.account.accountAddress,
        blobName: params.blobName,
        blobSize: params.size,
        blobMerkleRoot: params.blobMerkleRoot,
        numChunksets: expectedTotalChunksets(params.size, chunksetSize),
        expirationMicros: params.expirationMicros
      }),
      sender: params.account.accountAddress
    });
    return {
      transaction: await this.aptos.signAndSubmitTransaction({
        signer: params.account,
        transaction
      })
    };
  }
  /**
   * Acks the blob chunksets on-chain. If each chunkset meets the necessary threshold, the entire blob will be marked as written.
   *
   * @param params.account - The account that is signing the transaction.
   * @param params.blobOwner - The account that owns the blob.
   * @param params.blobName - The name of the blob (e.g. "foo/bar")
   * @param params.creationMicros - The creation time of the blob in microseconds.
   * @param params.chunksetIdx - The index of the chunkset being acknowledged.
   * @param params.storageProviderChunksetAcks - The signatures
   * @param params.options - Additional options for transaction building and encoding.
   *
   * @returns The blob commitments and the pending transaction.
   *
   * @example
   * ```typescript
   * const { transaction } = await client.addChunksetAcknowledgements({
   *   account: signer,
   *   blobOwner: owner,
   *   blobName: "foo/bar.txt",
   *   creationMicros, // Taken from the blob metadata at registration time.
   *   chunksetIdx,
   *   storageProviderAcks: An array of StorageProviderAck types, each having the slot index and signature from the SP.
   * });
   * ```
   */
  async addChunksetAcknowledgements(params) {
    const transaction = await this.aptos.transaction.build.simple({
      ...params.options?.build,
      data: _ShelbyBlobClient.createChunksetAcknowledgementsPayload({
        blobOwner: params.blobOwner,
        blobName: params.blobName,
        creationMicros: params.creationMicros,
        chunksetIdx: params.chunksetIdx,
        storageProviderAcks: params.storageProviderAcks
      }),
      sender: params.account.accountAddress
    });
    return {
      transaction: await this.aptos.signAndSubmitTransaction({
        signer: params.account,
        transaction
      })
    };
  }
  /**
   * Registers multiple blobs on the blockchain by writing their merkle roots and metadata.
   *
   * @param params.account - The account that is signing and paying for the transaction.
   * @param params.expirationMicros - The expiration time of the blobs in microseconds.
   * @param params.blobs - The blobs to register.
   * @param params.blobs.blobName - The name/path of the blob (e.g. "foo/bar.txt").
   * @param params.blobs.blobSize - The size of the blob in bytes.
   * @param params.blobs.blobMerkleRoot - The merkle root of the blob commitments as a hex string.
   * @param params.options - Optional transaction building options.
   * @param params.options.chunksetSizeBytes - Custom chunkset size (defaults to DEFAULT_CHUNKSET_SIZE_BYTES).
   * @param params.options.build - Additional Aptos transaction building options.
   *
   * @returns An object containing the pending transaction.
   *
   * @example
   * ```typescript
   * const provider = await ClayErasureCodingProvider.create();
   * const blobCommitments = await generateCommitments(provider, data);
   *
   * const { transaction } = await client.batchRegisterBlobs({
   *   account: signer,
   *   expirationMicros: Date.now() * 1000 + 3600_000_000, // 1 hour from now in microseconds
   *   blobs: [
   *     {
   *       blobName: "foo/bar.txt",
   *       blobSize: data.length,
   *       blobMerkleRoot: blobCommitments.blob_merkle_root,
   *     },
   *   ],
   * });
   * ```
   */
  async batchRegisterBlobs(params) {
    const chunksetSize = params.options?.chunksetSizeBytes ?? DEFAULT_CHUNKSET_SIZE_BYTES;
    const transaction = await this.aptos.transaction.build.simple({
      ...params.options?.build,
      sender: params.account.accountAddress,
      data: _ShelbyBlobClient.createBatchRegisterBlobsPayload({
        deployer: this.deployer,
        account: params.account.accountAddress,
        expirationMicros: params.expirationMicros,
        blobs: params.blobs.map((blob) => ({
          blobName: blob.blobName,
          blobSize: blob.blobSize,
          blobMerkleRoot: blob.blobMerkleRoot,
          numChunksets: expectedTotalChunksets(blob.blobSize, chunksetSize)
        }))
      })
    });
    return {
      transaction: await this.aptos.signAndSubmitTransaction({
        signer: params.account,
        transaction
      })
    };
  }
  /**
   * Creates a transaction payload to register a blob on the blockchain.
   * This is a static helper method for constructing the Move function call payload.
   *
   * @param params.deployer - Optional deployer account address. Defaults to SHELBY_DEPLOYER.
   * @param params.account - The account that will own the blob.
   * @param params.blobName - The name/path of the blob (e.g. "foo/bar.txt").
   * @param params.blobSize - The size of the blob in bytes.
   * @param params.blobMerkleRoot - The merkle root of the blob commitments as a hex string.
   * @param params.expirationMicros - The expiration time of the blob in microseconds.
   * @param params.numChunksets - The total number of chunksets in the blob.
   *
   * @returns An Aptos transaction payload data object for the register_blob Move function.
   *
   * @see https://github.com/shelby/shelby/blob/e08e84742cf2b80ad8bb7227deb3013398076d53/move/shelby_contract/sources/global_metadata.move#L357
   */
  static createRegisterBlobPayload(params) {
    return {
      function: `${(params.deployer ?? SHELBY_DEPLOYER).toString()}::blob_metadata::register_blob`,
      functionArguments: [
        params.blobName,
        params.expirationMicros,
        MoveVector.U8(params.blobMerkleRoot),
        params.numChunksets,
        params.blobSize,
        // TODO
        0,
        // payment tier
        0
        // encoding
      ]
    };
  }
  /**
   * Creates a transaction payload to register multiple blobs on the blockchain.
   * This is a static helper method for constructing the Move function call payload.
   *
   * @param params.deployer - Optional deployer account address. Defaults to SHELBY_DEPLOYER.
   * @param params.account - The account that will own the blobs.
   * @param params.expirationMicros - The expiration time of the blobs in microseconds.
   * @param params.blobs - The blobs to register.
   * @param params.blobs.blobName - The name/path of the blob (e.g. "foo/bar.txt").
   * @param params.blobs.blobSize - The size of the blob in bytes.
   * @param params.blobs.blobMerkleRoot - The merkle root of the blob commitments as a hex string.
   * @param params.blobs.numChunksets - The total number of chunksets in the blob.
   *
   * @returns An Aptos transaction payload data object for the register_multiple_blobs Move function.
   *
   * @see https://github.com/shelby/shelby/blob/e08e84742cf2b80ad8bb7227deb3013398076d53/move/shelby_contract/sources/global_metadata.move#L357
   */
  static createBatchRegisterBlobsPayload(params) {
    const blobNames = [];
    const blobMerkleRoots = [];
    const blobNumChunksets = [];
    const blobSizes = [];
    params.blobs.forEach((blob) => {
      blobNames.push(blob.blobName);
      blobMerkleRoots.push(MoveVector.U8(blob.blobMerkleRoot));
      blobNumChunksets.push(blob.numChunksets);
      blobSizes.push(blob.blobSize);
    });
    return {
      function: `${(params.deployer ?? SHELBY_DEPLOYER).toString()}::blob_metadata::register_multiple_blobs`,
      functionArguments: [
        blobNames,
        params.expirationMicros,
        blobMerkleRoots,
        blobNumChunksets,
        blobSizes,
        // TODO
        0,
        0
      ]
    };
  }
  /**
   * Creates a transaction payload to delete a blob on the blockchain.
   * This is a static helper method for constructing the Move function call payload.
   *
   * @param params.deployer - Optional deployer account address. Defaults to SHELBY_DEPLOYER.
   * @param params.blobNameSuffix - The blob name suffix (e.g. "bar.txt").
   *
   * @returns An Aptos transaction payload data object for the delete_blob Move function.
   *
   * @see https://github.com/shelby/shelby/blob/64e9d7b4f0005e586faeb1e4085c79159234b6b6/move/shelby_contract/sources/global_metadata.move#L616
   */
  static createDeleteBlobPayload(params) {
    return {
      function: `${(params.deployer ?? SHELBY_DEPLOYER).toString()}::blob_metadata::delete_blob`,
      functionArguments: [params.blobNameSuffix]
    };
  }
  static createChunksetAcknowledgementsPayload(params) {
    const ackBitMask = params.storageProviderAcks.reduce(
      (acc, ack) => acc | 1 << ack.slot,
      0
    );
    const signatures = new MoveVector(params.storageProviderAcks.map((ack) => MoveVector.U8(ack.signature)));
    return {
      function: `${SHELBY_DEPLOYER}::blob_metadata::add_chunkset_acknowledgements`,
      functionArguments: [
        createBlobKey({
          account: params.blobOwner,
          blobName: params.blobName
        }),
        params.chunksetIdx,
        params.creationMicros,
        new U32(Number(ackBitMask)),
        signatures
      ]
    };
  }
};

export {
  ShelbyBlobClient
};
