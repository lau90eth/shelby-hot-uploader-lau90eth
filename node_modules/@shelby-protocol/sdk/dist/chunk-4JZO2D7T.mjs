// src/core/utils.ts
import { Hex } from "@aptos-labs/ts-sdk";
async function* readInChunks(input, chunkSize) {
  let idx = 0;
  if (isReadableStream(input)) {
    const reader = input.getReader();
    let buffer = new Uint8Array(chunkSize);
    let bufferWriteOffset = 0;
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        if (value === void 0) continue;
        let srcOffset = 0;
        while (srcOffset < value.length) {
          const remainingCapacity = chunkSize - bufferWriteOffset;
          const bytesToCopy = Math.min(
            remainingCapacity,
            value.length - srcOffset
          );
          buffer.set(
            value.subarray(srcOffset, srcOffset + bytesToCopy),
            bufferWriteOffset
          );
          bufferWriteOffset += bytesToCopy;
          srcOffset += bytesToCopy;
          if (bufferWriteOffset >= chunkSize) {
            yield [idx++, buffer];
            buffer = new Uint8Array(chunkSize);
            bufferWriteOffset = 0;
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    if (bufferWriteOffset > 0) {
      yield [idx++, buffer.subarray(0, bufferWriteOffset)];
    }
    return;
  }
  const view = toUint8Array(input);
  for (let offset = 0; offset < view.byteLength; offset += chunkSize) {
    yield [
      idx++,
      view.subarray(offset, Math.min(offset + chunkSize, view.byteLength))
    ];
  }
}
function zeroPadBytes(buffer, desiredLength) {
  if (buffer.byteLength === desiredLength) {
    return buffer;
  }
  if (buffer.byteLength > desiredLength) {
    return buffer.subarray(0, desiredLength);
  }
  const paddedBuffer = new Uint8Array(desiredLength);
  paddedBuffer.set(buffer);
  return paddedBuffer;
}
async function concatHashes(parts) {
  const chunks = parts.map((part) => Hex.fromHexInput(part).toUint8Array());
  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
  const combined = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    combined.set(chunk, offset);
    offset += chunk.byteLength;
  }
  return Hex.fromHexInput(
    new Uint8Array(await crypto.subtle.digest("SHA-256", combined))
  );
}
function isReadableStream(value) {
  return typeof value === "object" && value !== null && "getReader" in value && typeof value.getReader === "function";
}
function toUint8Array(view) {
  return view instanceof Uint8Array ? view : new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
}
function buildRequestUrl(path, baseUrl) {
  const baseHasSlash = baseUrl.endsWith("/");
  const safeBase = baseHasSlash ? baseUrl : `${baseUrl}/`;
  const safePath = path.replace(/^\/+/, "");
  return new URL(safePath, safeBase);
}
function getBlobNameSuffix(blobName) {
  const parts = blobName.split("/");
  return parts.slice(1).join("/") || "";
}

export {
  readInChunks,
  zeroPadBytes,
  concatHashes,
  buildRequestUrl,
  getBlobNameSuffix
};
