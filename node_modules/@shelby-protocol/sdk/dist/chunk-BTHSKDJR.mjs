import {
  ShelbyBlobClient
} from "./chunk-7UVMDCCR.mjs";
import {
  ClayErasureCodingProvider
} from "./chunk-NLPIHQ7K.mjs";
import {
  ShelbyRPCClient
} from "./chunk-5I3MBJGN.mjs";
import {
  getAptosConfig
} from "./chunk-RBFWGDMY.mjs";
import {
  createBlobKey
} from "./chunk-OTBLZL2S.mjs";
import {
  generateCommitments
} from "./chunk-XWAPNLU6.mjs";
import {
  NetworkToShelbyRPCBaseUrl
} from "./chunk-SEXQTDX6.mjs";

// src/core/clients/ShelbyClient.ts
import {
  AccountAddress,
  Aptos,
  DEFAULT_TXN_TIMEOUT_SEC,
  TransactionResponseType
} from "@aptos-labs/ts-sdk";
import pLimit from "p-limit";
var ShelbyClient = class {
  /**
   * The coordination client is used to interact with the Aptos blockchain which handles the commitments
   * and metadata for blobs.
   */
  coordination;
  /**
   * The RPC client is used to interact with the Shelby RPC node which can be responsible for storing,
   * confirming, and retrieving blobs from the storage layer.
   *
   * If not provided, the default RPC client will be created.
   */
  rpc;
  /**
   * The configuration for the Shelby client.
   */
  config;
  /**
   * The Aptos client.
   *
   * If not provided, a default Aptos client will be created.
   */
  aptos;
  /**
   * The erasure coding provider used for encoding/decoding operations.
   * Lazily initialized on first use if not provided.
   */
  _provider;
  /**
   * Creates a new ShelbyClient instance for interacting with the Shelby Protocol.
   * This client combines blockchain operations (via coordination) and storage operations (via RPC).
   *
   * @param config - The client configuration object.
   * @param config.aptos.config - The Aptos network configuration.
   * @param config.shelby.rpc.baseUrl - The base URL of the Shelby RPC node (optional, defaults to devnet).
   * @param config.shelby.indexer - The indexer configuration for GraphQL queries.
   * @param provider - Optional erasure coding provider for encoding/decoding operations.
   *                   If not provided, a ClayErasureCodingProvider will be created on first use.
   *                   Pass a shared provider to reuse across multiple clients.
   *
   * @example
   * ```typescript
   * // Basic usage (provider created automatically)
   * const client = new ShelbyClient({
   *   network: Network.SHELBYNET,
   * });
   *
   * // Advanced: Share provider across multiple clients
   * const provider = await ClayErasureCodingProvider.create();
   * const mainnetClient = new ShelbyClient(mainnetConfig, provider);
   * const devnetClient = new ShelbyClient(devnetConfig, provider);
   * ```
   */
  constructor(config, provider) {
    this.config = config;
    this.aptos = new Aptos(getAptosConfig(config));
    this.coordination = new ShelbyBlobClient(config);
    this.rpc = new ShelbyRPCClient(config);
    this._provider = provider;
  }
  /**
   * Get the erasure coding provider, creating it if necessary.
   * This allows lazy initialization for users who don't provide a provider.
   */
  async getProvider() {
    if (!this._provider) {
      this._provider = await ClayErasureCodingProvider.create();
    }
    return this._provider;
  }
  /**
   * The base URL for the Shelby RPC node.
   */
  get baseUrl() {
    return this.config.rpc?.baseUrl ?? NetworkToShelbyRPCBaseUrl.shelbynet;
  }
  /**
   * Uploads a blob to the Shelby network.
   * This method handles the complete upload flow including commitment generation,
   * blockchain registration, and storage upload.
   *
   * @param params.blobData - The raw data to upload as a Uint8Array.
   * @param params.signer - The account that signs and pays for the transaction.
   * @param params.blobName - The name/path of the blob (e.g. "folder/file.txt").
   * @param params.expirationMicros - The expiration time in microseconds since Unix epoch.
   * @param params.options - Optional upload configuration.
   * @param params.options.chunksetSizeBytes - Custom chunkset size.
   * @param params.options.build - Additional Aptos transaction options.
   *
   * @returns The transaction and generated blob commitments (when implemented).
   *
   * @example
   * ```typescript
   * await client.upload({
   *   blobData: Buffer.from("Hello, World!"),
   *   signer: account,
   *   blobName: "hello.txt",
   *   expirationMicros: Date.now() * 1000 + 86400_000_000 // 24 hours from now
   * });
   * ```
   */
  async upload(params) {
    const existingBlobMetadata = await this.coordination.getBlobMetadata({
      account: params.signer.accountAddress,
      name: params.blobName
    });
    if (!existingBlobMetadata) {
      const provider = await this.getProvider();
      const blobCommitments = await generateCommitments(
        provider,
        params.blobData
      );
      const { transaction: pendingRegisterBlobTransaction } = await this.coordination.registerBlob({
        account: params.signer,
        blobName: params.blobName,
        blobMerkleRoot: blobCommitments.blob_merkle_root,
        size: params.blobData.length,
        expirationMicros: params.expirationMicros,
        options: params.options
      });
      await this.coordination.aptos.waitForTransaction({
        transactionHash: pendingRegisterBlobTransaction.hash
      });
    }
    await this.rpc.putBlob({
      account: params.signer.accountAddress,
      blobName: params.blobName,
      blobData: params.blobData
    });
  }
  /**
   * Uploads a batch of blobs to the Shelby network.
   * This method handles the complete upload flow including commitment generation,
   * blockchain registration, and storage upload.
   *
   * @param params.blobs - The blobs to upload.
   * @param params.blobs.blobData - The raw data to upload as a Uint8Array.
   * @param params.blobs.blobName - The name/path of the blob (e.g. "folder/file.txt").
   * @param params.expirationMicros - The expiration time in microseconds since Unix epoch.
   * @param params.signer - The account that signs and pays for the transaction.
   * @param params.options - Optional upload configuration.
   * @param params.options.chunksetSizeBytes - Custom chunkset size.
   * @param params.options.build - Additional Aptos transaction options.
   *
   * @returns The transaction and generated blob commitments (when implemented).
   *
   * @example
   * ```typescript
   * await client.batchUpload({
   *   blobs: [
   *     { blobData: Buffer.from("Hello, World!"), blobName: "hello.txt" },
   *     { blobData: Buffer.from("Hello, World 2!"), blobName: "hello2.txt" },
   *   ],
   *   expirationMicros: Date.now() * 1000 + 86400_000_000 // 24 hours from now
   * });
   * ```
   */
  async batchUpload(params) {
    const existingBlobs = await this.coordination.getBlobs({
      where: {
        blob_name: {
          _in: params.blobs.map(
            (blob) => createBlobKey({
              account: params.signer.accountAddress,
              blobName: blob.blobName
            })
          )
        }
      }
    });
    const blobsToRegister = params.blobs.filter(
      (blob) => !existingBlobs.some(
        (existingBlob) => existingBlob.name === createBlobKey({
          account: params.signer.accountAddress,
          blobName: blob.blobName
        })
      )
    );
    if (blobsToRegister.length > 0) {
      const provider = await this.getProvider();
      const blobCommitments = await Promise.all(
        blobsToRegister.map(
          async (blob) => generateCommitments(provider, blob.blobData)
        )
      );
      const { transaction: pendingRegisterBlobTransaction } = await this.coordination.batchRegisterBlobs({
        account: params.signer,
        expirationMicros: params.expirationMicros,
        blobs: blobsToRegister.map((blob, index) => ({
          blobName: blob.blobName,
          blobSize: blob.blobData.length,
          blobMerkleRoot: blobCommitments[index].blob_merkle_root
        })),
        options: params.options
      });
      await this.coordination.aptos.waitForTransaction({
        transactionHash: pendingRegisterBlobTransaction.hash,
        options: { waitForIndexer: true }
      });
    }
    const limit = pLimit(3);
    await Promise.all(
      params.blobs.map(
        (blob) => limit(
          () => this.rpc.putBlob({
            account: params.signer.accountAddress,
            blobName: blob.blobName,
            blobData: blob.blobData
          })
        )
      )
    );
  }
  /**
   * Downloads a blob from the Shelby RPC node.
   *
   * @param params.account - The account namespace the blob is stored in (e.g. "0x1")
   * @param params.blobName - The name of the blob (e.g. "foo/bar")
   * @param params.range - The range of the blob to download.
   *
   * @returns A `ShelbyBlob` object containing the blob data.
   *
   * @example
   * ```typescript
   * const blob = await client.download({
   *   account,
   *   blobName: "foo/bar.txt",
   * });
   * ```
   */
  async download(params) {
    return await this.rpc.getBlob(params);
  }
  /**
   *
   * Funds an account with ShelbyUSD tokens.
   *
   * @param params.address - The address to fund.
   * @param params.amount - The amount to fund.
   * @returns The transaction hash of the funded account.
   *
   * @example
   * ```typescript
   * const hash = await client.fundAccountWithShelbyUSD({
   *   address: "0x1",
   *   amount: 100000000,
   * });
   * ```
   */
  async fundAccountWithShelbyUSD(params) {
    const { address, amount } = params;
    try {
      const faucet = this.config.faucet ?? "https://faucet.shelbynet.shelby.xyz/fund?asset=shelbyusd";
      const response = await fetch(`${faucet}`, {
        method: "POST",
        body: JSON.stringify({
          address: AccountAddress.from(address).toString(),
          amount
        }),
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        throw new Error("Failed to fund account");
      }
      const json = await response.json();
      const res = await this.aptos.waitForTransaction({
        transactionHash: json.txn_hashes[0],
        options: {
          timeoutSecs: DEFAULT_TXN_TIMEOUT_SEC,
          checkSuccess: true
        }
      });
      if (res.type === TransactionResponseType.User) {
        return res.hash;
      }
      throw new Error(
        `Unexpected transaction received for fund account: ${res.type}`
      );
    } catch (error) {
      throw new Error(`Failed to fund account: ${error}`);
    }
  }
  /**
   * Fund an account with APT tokens
   *
   * @param params.address - The address to fund
   * @param params.amount - The amount to fund
   * @returns The transaction hash of the funded account
   *
   * @example
   * ```typescript
   * const hash = await client.fundAccountWithAPT({
   *   address: "0x1",
   *   amount: 100000000,
   * });
   * ```
   */
  async fundAccountWithAPT(params) {
    const transaction = await this.aptos.fundAccount({
      accountAddress: params.address,
      amount: params.amount
    });
    return transaction.hash;
  }
};

export {
  ShelbyClient
};
