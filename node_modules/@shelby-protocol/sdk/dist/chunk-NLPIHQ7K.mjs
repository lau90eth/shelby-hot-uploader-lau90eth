import {
  DEFAULT_CHUNK_SIZE_BYTES
} from "./chunk-67F5YZ25.mjs";
import {
  DEFAULT_ERASURE_D,
  DEFAULT_ERASURE_K,
  DEFAULT_ERASURE_N
} from "./chunk-ZPW742E7.mjs";

// src/core/erasure/clay-codes.ts
import {
  createDecoder,
  createEncoder
} from "@shelby-protocol/clay-codes";
function getTotalChunks(config) {
  return config.erasure_n;
}
var ClayErasureCodingProvider = class _ClayErasureCodingProvider {
  config;
  encoderCache;
  decoderCache;
  lastFunction;
  constructor(config) {
    this.config = config;
    this.lastFunction = "none" /* NONE */;
  }
  /**
   * Static factory method to create an initialized ClayErasureCodingProvider
   */
  static async create(options) {
    const config = buildClayConfig({
      erasure_n: options?.erasure_n ?? DEFAULT_ERASURE_N,
      erasure_k: options?.erasure_k ?? DEFAULT_ERASURE_K,
      erasure_d: options?.erasure_d ?? DEFAULT_ERASURE_D,
      chunkSizeBytes: options?.chunkSizeBytes ?? DEFAULT_CHUNK_SIZE_BYTES
    });
    const provider = new _ClayErasureCodingProvider(config);
    [provider.encoderCache, provider.decoderCache] = await Promise.all([
      createEncoder({
        n: getTotalChunks(config),
        k: config.erasure_k,
        d: config.erasure_d,
        chunkSizeBytes: config.chunkSizeBytes
      }),
      createDecoder({
        n: getTotalChunks(config),
        k: config.erasure_k,
        d: config.erasure_d,
        chunkSizeBytes: config.chunkSizeBytes,
        erasedChunksMask: 0
        // No chunks erased initially; will be reconfigured on decode
      })
    ]);
    return provider;
  }
  encode(data) {
    const { erasure_k, chunkSizeBytes } = this.config;
    if (!this.encoderCache) {
      throw new Error("Encoder cache is missing");
    }
    const systematicCapacity = erasure_k * chunkSizeBytes;
    if (data.byteLength > systematicCapacity) {
      throw new Error(
        `Data size ${data.byteLength} bytes exceeds systematic capacity ${systematicCapacity} bytes (erasure_k=${erasure_k} * chunkSizeBytes=${chunkSizeBytes}).`
      );
    }
    if (this.requiresPadding(data.length)) {
      throw new Error(
        `Data size ${data.length} bytes does not match systematic capacity ${systematicCapacity} bytes (erasure_k=${erasure_k} * chunkSizeBytes=${chunkSizeBytes}). Provide pre-padded data before encoding.`
      );
    }
    this.lastFunction = "encoded" /* ENCODED */;
    return this.encoderCache.erasureCode(data);
  }
  decode(available, config) {
    if (!this.decoderCache) {
      throw new Error("Decoder cache is missing");
    }
    const { erasure_k, chunkSizeBytes } = this.config;
    if (available.length < erasure_k) {
      throw new Error(
        `Insufficient available chunks: need at least ${erasure_k}, received ${available.length}.`
      );
    }
    for (let i = 0; i < available.length; i++) {
      const chunk = available[i];
      if (chunk.length !== chunkSizeBytes) {
        throw new Error(
          `Chunk ${i} size ${chunk.length} bytes does not match expected chunkSizeBytes ${chunkSizeBytes}.`
        );
      }
    }
    this.lastFunction = "decoded" /* DECODED */;
    return this.decoderCache.decode(available, config);
  }
  getChunkMerkleRoots() {
    if (this.decoderCache && this.lastFunction === "decoded" /* DECODED */)
      return this.decoderCache.getChunkMerkleRoots();
    if (this.encoderCache && this.lastFunction === "encoded" /* ENCODED */)
      return this.encoderCache.getChunkMerkleRoots();
    throw new Error(
      "You must call encode or decode before calling getChunkMerkleRoots"
    );
  }
  /**
   * Determines if data can be erasure coded as-is or requires padding.
   *
   * Data can be erasure coded without padding if its size exactly matches
   * the total systematic data capacity (k * chunkSizeBytes).
   *
   * @param dataSize - Size of the data in bytes
   * @returns true if data needs padding, false if it can be coded as-is
   */
  requiresPadding(dataSize) {
    const { erasure_k, chunkSizeBytes } = this.config;
    const systematicCapacity = erasure_k * chunkSizeBytes;
    return dataSize !== systematicCapacity;
  }
};
function buildClayConfig(input) {
  const { erasure_n, erasure_k, erasure_d, chunkSizeBytes } = input;
  if (erasure_n <= 0)
    throw new Error("erasure_n (total number of chunks) must be > 0");
  if (erasure_k <= 0)
    throw new Error("erasure_k (number of data chunks) must be > 0");
  if (erasure_k >= erasure_n)
    throw new Error(
      `erasure_k (${erasure_k}) must be < erasure_n (${erasure_n})`
    );
  if (erasure_d <= erasure_k)
    throw new Error(
      `erasure_d (${erasure_d}) must be > erasure_k (${erasure_k})`
    );
  if (erasure_d >= erasure_n)
    throw new Error(
      `erasure_d (${erasure_d}) must be < erasure_n (${erasure_n})`
    );
  if (chunkSizeBytes <= 0) throw new Error("chunkSizeBytes must be > 0");
  return {
    erasure_n,
    erasure_k,
    erasure_d,
    chunkSizeBytes
  };
}

export {
  ClayErasureCodingProvider
};
