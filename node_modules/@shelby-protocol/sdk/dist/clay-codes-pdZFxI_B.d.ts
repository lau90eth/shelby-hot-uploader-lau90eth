import { ChunkCollection, DecoderReconfigureOptions } from '@shelby-protocol/clay-codes';

interface ReedSolomonConfig extends ErasureCodingConfig {
}
type ReedSolomonProviderOptions = Partial<ReedSolomonConfig>;
declare class ReedSolomonErasureCodingProvider implements ErasureCodingProvider {
    readonly config: ReedSolomonConfig;
    constructor(options?: ReedSolomonProviderOptions);
    encode(data: Uint8Array): ChunkCollection;
    decode(_available: Uint8Array[], _config: DecodeConfig): ChunkCollection;
    getChunkMerkleRoots(): Uint8Array[];
}

/**
 * Erasure coding provider abstraction for the SDK.
 *
 * Providers implement different erasure coding schemes (Clay, Reed-Solomon, etc.)
 * while maintaining a consistent interface for encoding and decoding operations.
 */

/**
 * Base configuration shared by all erasure coding schemes.
 *
 * All schemes must specify:
 * - `chunkSizeBytes`: Size in bytes of each chunk
 */
interface ErasureCodingConfig {
    /** Number of total chunks. */
    erasure_n: number;
    /** Number of data chunks. */
    erasure_k: number;
    /** Size in bytes of every chunk. */
    chunkSizeBytes: number;
}
/**
 * Union of all supported erasure coding configurations.
 */
type InitConfig = ReedSolomonConfig | ClayConfig;
/**
 * Base marker type for decode configuration.
 *
 * Specific providers extend this with their erasure pattern specification options.
 * The configuration indicates which chunks are available/missing in the decode operation.
 */
type DecodeConfig = Record<string, unknown>;
/**
 * Contract for pluggable erasure coding backends.
 *
 * Implementations provide encode/decode operations for different erasure
 * coding schemes while maintaining consistent semantics:
 *
 * - **Encode**: Takes raw data and produces n = k + m chunks
 * - **Decode**: Takes n chunks (some may be missing/undefined) and recovers all chunks
 *
 * All implementations must support both array and flat buffer inputs.
 */
interface ErasureCodingProvider {
    /** Configuration for this erasure coding instance. */
    readonly config: ErasureCodingConfig;
    /**
     * Encode data into systematic and parity chunks.
     *
     * @param data - Raw data buffer that will be split into k chunks
     * @returns Collection containing all n chunks (k systematic + m parity)
     */
    encode(data: Uint8Array): ChunkCollection;
    /**
     * Decode available chunks back to original data, recovering any missing chunks.
     *
     * @param available - Array of available chunks (must have at least k chunks)
     * @param config - Decode configuration specifying which chunk indexes are available
     * @returns Recovered chunk collection with all n chunks reconstructed
     * @throws Error if fewer than k chunks are available
     */
    decode(available: Uint8Array[], config: DecodeConfig): ChunkCollection;
    /**
     * Get chunk roots.
     */
    getChunkMerkleRoots(): Uint8Array[];
}

interface ClayConfig extends ErasureCodingConfig, ClayErasureCodeParams {
}
/**
 * Parameters that define a Clay erasure coding scheme.
 *
 * These values specify only the coding characteristics, not
 * implementation details like chunk size or storage layout.
 *
 * - `erasure_n`: Total number of chunks (data + parity)
 * - `erasure_k`: Number of data chunks
 * - `erasure_d`: Number of helper nodes participating in reconstruction
 */
interface ClayErasureCodeParams {
    erasure_n: number;
    erasure_k: number;
    erasure_d: number;
}
type ClayProviderOptions = Partial<ClayErasureCodeParams & ErasureCodingConfig>;
/**
 * Clay-specific decode configuration.
 *
 * Supports flexible erasure pattern specification in any of three formats:
 * - availableChunkIndexes: Array of available chunk positions
 * - erasedChunkIndexes: Array of missing chunk positions
 * - erasedChunksMask: Bitmask where bit i=1 means chunk i is missing
 *
 * Exactly one of these three options must be provided.
 */
type ClayDecodeConfig = DecoderReconfigureOptions;
declare class ClayErasureCodingProvider implements ErasureCodingProvider {
    readonly config: ClayConfig;
    private encoderCache?;
    private decoderCache?;
    private lastFunction;
    private constructor();
    /**
     * Static factory method to create an initialized ClayErasureCodingProvider
     */
    static create<T extends ClayProviderOptions>(options?: T): Promise<ClayErasureCodingProvider>;
    encode(data: Uint8Array): ChunkCollection;
    decode(available: Uint8Array[], config: ClayDecodeConfig): ChunkCollection;
    getChunkMerkleRoots(): Uint8Array[];
    /**
     * Determines if data can be erasure coded as-is or requires padding.
     *
     * Data can be erasure coded without padding if its size exactly matches
     * the total systematic data capacity (k * chunkSizeBytes).
     *
     * @param dataSize - Size of the data in bytes
     * @returns true if data needs padding, false if it can be coded as-is
     */
    requiresPadding(dataSize: number): boolean;
}

export { ClayErasureCodingProvider as C, type DecodeConfig as D, type ErasureCodingConfig as E, type InitConfig as I, ReedSolomonErasureCodingProvider as R, type ErasureCodingProvider as a, type ClayProviderOptions as b, type ReedSolomonConfig as c, type ReedSolomonProviderOptions as d, type ClayConfig as e, type ClayErasureCodeParams as f, type ClayDecodeConfig as g };
