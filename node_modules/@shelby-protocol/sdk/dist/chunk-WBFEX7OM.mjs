import {
  getAptosConfig
} from "./chunk-RBFWGDMY.mjs";
import {
  SHELBY_DEPLOYER
} from "./chunk-SEXQTDX6.mjs";

// src/node/clients/ShelbyMetadataClient.ts
import {
  AccountAddress,
  Aptos,
  Hex
} from "@aptos-labs/ts-sdk";
var ShelbyMetadataClient = class {
  aptos;
  deployer;
  /**
   * The ShelbyMetadataClient is used to interact with the Shelby contract on the Aptos blockchain. This
   * includes functions like gathering basic details about the Shelby system, including storage provider information.
   *
   * @param config.aptos.config - The Aptos config.
   * @param config.shelbyDeployer - The deployer account address of the Shelby contract. If not provided, the default deployer address will be used.
   *
   * @example
   * ```typescript
   * const aptos = new Aptos(new AptosConfig({ network: Network.TESTNET }));
   * const metadataClient = new ShelbyMetadataClient({ aptos });
   * ```
   */
  constructor(config) {
    this.aptos = new Aptos(getAptosConfig(config));
    this.deployer = config.deployer ?? AccountAddress.fromString(SHELBY_DEPLOYER);
  }
  /**
   * Retrieves storage provider list from the blockchain.
   *
   * @returns A list of storage providers, or empty array if none exist.
   *
   * @example
   * ```typescript
   * const spList = await client.getStorageProviders();
   * ```
   */
  async getStorageProviders() {
    try {
      const rawMetadata = await this.aptos.view({
        payload: {
          function: `${this.deployer.toString()}::global_metadata::get_all_storage_providers`,
          functionArguments: []
        }
      });
      const metadata = rawMetadata[0];
      return metadata.map((provider) => ({
        address: AccountAddress.fromString(provider.address),
        ipAddress: provider.ip_address,
        port: provider.port,
        blsPublicKey: Hex.fromHexInput(provider.bls_public_key).toUint8Array(),
        failureDomain: provider.failure_domain
      }));
    } catch (error) {
      if (error instanceof Error && // Depending on the network, the error message may show up differently.
      error.message?.includes("sub_status: Some(404)")) {
        return [];
      }
      throw error;
    }
  }
  /**
   * Retrieves the list of placement group addresses.
   *
   * @returns The placement group address list, or an empty array if none exist.
   *
   * @example
   * ```typescript
   * const pgList = await client.getPlacementGroupAddresses();
   * ```
   */
  async getPlacementGroupAddresses() {
    try {
      const pgSizeMetadata = await this.aptos.view({
        payload: {
          function: `${this.deployer.toString()}::global_metadata::get_number_of_placement_groups`,
          functionArguments: []
        }
      });
      const finalPlacementGroupIndex = pgSizeMetadata[0] - 1;
      const addressMetadataArray = await this.aptos.view({
        payload: {
          function: `${this.deployer.toString()}::global_metadata::get_placement_group_addresses`,
          functionArguments: [0, finalPlacementGroupIndex]
        }
      });
      const metadata = addressMetadataArray[0];
      return metadata.map((pg) => AccountAddress.fromString(pg));
    } catch (error) {
      if (error instanceof Error && // Depending on the network, the error message may show up differently.
      (error.message?.includes("sub_status: Some(404)") || error.message?.includes("E_PLACEMENT_GROUP_NOT_FOUND"))) {
        return [];
      }
      throw error;
    }
  }
  /**
   * Retrieves the list of slice addresses.
   *
   * @returns The slice group list, or an empty array if none exist.
   *
   * @example
   * ```typescript
   * const pgList = await client.getSliceAddresses();
   * ```
   */
  async getSliceAddresses() {
    try {
      const sliceSizeMetadata = await this.aptos.view({
        payload: {
          function: `${this.deployer.toString()}::slice_registry::get_number_of_slices`,
          functionArguments: []
        }
      });
      const finalSliceIndex = sliceSizeMetadata[0] - 1;
      const addressMetadataArray = await this.aptos.view({
        payload: {
          function: `${this.deployer.toString()}::slice_registry::get_slice_addresses`,
          functionArguments: [0, finalSliceIndex]
        }
      });
      const metadata = addressMetadataArray[0];
      return metadata.map((slice) => AccountAddress.fromString(slice));
    } catch (error) {
      if (error instanceof Error && // Depending on the network, the error message may show up differently.
      (error.message?.includes("sub_status: Some(404)") || error.message?.includes("E_SLICE_NOT_FOUND"))) {
        return [];
      }
      throw error;
    }
  }
  /**
   * Retrieves the storage providers assigned to a slice, through a placement group.
   *
   * @param params.account - The address of the slice account.
   * @returns The list of storage providers for the slice, or an empty array if none exist.
   *
   * @example
   * ```typescript
   * const pgInfo = await client.getStorageProvidersForSlice();
   * ```
   */
  async getStorageProvidersForSlice(params) {
    const sliceMetadata = await this.aptos.view({
      payload: {
        function: `${this.deployer.toString()}::slice::get_slice_info`,
        functionArguments: [params.account.toString()]
      }
    });
    const placementGroupAddress = sliceMetadata[0].placement_group_assignments[0].placement_group_address;
    const rawMetadata = await this.aptos.view({
      payload: {
        function: `${this.deployer.toString()}::placement_group::get_placement_group_info`,
        functionArguments: [placementGroupAddress]
      }
    });
    const members = rawMetadata[0].members;
    const keys = members.flatMap((m) => {
      const active = m.active?.vec.map((a) => a.address) ?? [];
      const others = m.others?.data.map((o) => o.key) ?? [];
      return [...active, ...others];
    });
    return keys.map((k) => AccountAddress.fromString(k));
  }
};

export {
  ShelbyMetadataClient
};
