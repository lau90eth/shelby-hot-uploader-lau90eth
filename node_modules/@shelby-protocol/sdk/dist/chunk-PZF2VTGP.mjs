// src/core/erasure/reed-solomon.ts
import { createWasmReedSolomonBinding } from "@shelby-protocol/reed-solomon";
var DEFAULT_ERASURE_K = 10;
var DEFAULT_ERASURE_N = 16;
var DEFAULT_CHUNK_SIZE_BYTES = 2 * 1024 * 1024;
var ReedSolomonErasureCodingProvider = class {
  config;
  constructor(options) {
    const erasure_k = options?.erasure_k ?? DEFAULT_ERASURE_K;
    const erasure_n = options?.erasure_n ?? DEFAULT_ERASURE_N;
    const chunkSizeBytes = options?.chunkSizeBytes ?? DEFAULT_CHUNK_SIZE_BYTES;
    if (erasure_k <= 0)
      throw new Error("erasure_k (number of data chunks) must be > 0");
    if (erasure_n <= erasure_k)
      throw new Error(
        `erasure_n (${erasure_n}) must be > erasure_k (${erasure_k})`
      );
    if (chunkSizeBytes <= 0) throw new Error("chunkSizeBytes must be > 0");
    this.config = {
      erasure_n,
      erasure_k,
      chunkSizeBytes
    };
  }
  encode(data) {
    const { erasure_k, erasure_n, chunkSizeBytes } = this.config;
    const erasure_m = erasure_n - erasure_k;
    const systematicCapacity = erasure_k * chunkSizeBytes;
    if (data.byteLength > systematicCapacity) {
      throw new Error(
        `Data size ${data.byteLength} bytes exceeds systematic capacity ${systematicCapacity} bytes (erasure_k=${erasure_k} * chunkSizeBytes=${chunkSizeBytes}).`
      );
    }
    if (data.byteLength !== systematicCapacity) {
      throw new Error(
        `Data size ${data.byteLength} bytes does not match systematic capacity ${systematicCapacity} bytes (erasure_k=${erasure_k} * chunkSizeBytes=${chunkSizeBytes}). Provide pre-padded data before encoding.`
      );
    }
    const reedSolomon = createWasmReedSolomonBinding();
    const shards = new Uint8Array(
      systematicCapacity + erasure_m * chunkSizeBytes
    );
    shards.set(data, 0);
    reedSolomon.encode(shards, erasure_k, erasure_m);
    const chunks = new Array(erasure_n);
    for (let idx = 0; idx < erasure_n; idx++) {
      const start = idx * chunkSizeBytes;
      chunks[idx] = shards.slice(start, start + chunkSizeBytes);
    }
    return {
      chunks,
      systematic: chunks.slice(0, erasure_k),
      parity: chunks.slice(erasure_k)
    };
  }
  decode(_available, _config) {
    throw new Error(
      "ReedSolomonErasureCodingProvider does not implement decode"
    );
  }
  getChunkMerkleRoots() {
    throw new Error(
      "ReedSolomonErasureCodingProvider does not implement getChunkMerkleRoots"
    );
  }
};

export {
  ReedSolomonErasureCodingProvider
};
