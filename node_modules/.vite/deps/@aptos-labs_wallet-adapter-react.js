import {
  getWallets,
  require_nacl_fast
} from "./chunk-JJPFH2JR.js";
import {
  Ae,
  AxiosError,
  B,
  Dt,
  E5 as E,
  Gn,
  Gt,
  O4 as O,
  Se,
  U4 as U,
  Ur,
  V,
  W3 as W,
  Wn,
  _e,
  a,
  a3 as a2,
  axios_default,
  e,
  f4 as f,
  h3 as h,
  isAxiosError,
  k2 as k,
  l2 as l,
  n,
  o5 as o,
  ot,
  pa,
  pe,
  qs,
  r5 as r,
  s4 as s,
  sha3_256,
  t4 as t,
  ut,
  z2 as z
} from "./chunk-SSZPPV2N.js";
import "./chunk-5GFRP27I.js";
import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  __commonJS,
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l3 = handlers.length, ee2 = new Array(l3); i4 < l3; i4++) {
        ee2[i4] = handlers[i4].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i4;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42, a52), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners[i4].once) this.removeListener(event, listeners[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i4].fn.call(listeners[i4].context);
              break;
            case 2:
              listeners[i4].fn.call(listeners[i4].context, a1);
              break;
            case 3:
              listeners[i4].fn.call(listeners[i4].context, a1, a22);
              break;
            case 4:
              listeners[i4].fn.call(listeners[i4].context, a1, a22, a32);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners[i4].fn.apply(listeners[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners.length; i4 < length; i4++) {
          if (listeners[i4].fn !== fn || once && !listeners[i4].once || context && listeners[i4].context !== context) {
            events.push(listeners[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/ed2curve/ed2curve.js
var require_ed2curve = __commonJS({
  "node_modules/ed2curve/ed2curve.js"(exports, module) {
    (function(root, f7) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) module.exports = f7(require_nacl_fast());
      else root.ed2curve = f7(root.nacl);
    })(exports, function(nacl3) {
      "use strict";
      if (!nacl3) throw new Error("tweetnacl not loaded");
      var gf = function(init) {
        var i4, r10 = new Float64Array(16);
        if (init) for (i4 = 0; i4 < init.length; i4++) r10[i4] = init[i4];
        return r10;
      };
      var gf0 = gf(), gf1 = gf([1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I3 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function car25519(o13) {
        var c3;
        var i4;
        for (i4 = 0; i4 < 16; i4++) {
          o13[i4] += 65536;
          c3 = Math.floor(o13[i4] / 65536);
          o13[(i4 + 1) * (i4 < 15 ? 1 : 0)] += c3 - 1 + 37 * (c3 - 1) * (i4 === 15 ? 1 : 0);
          o13[i4] -= c3 * 65536;
        }
      }
      function sel25519(p5, q3, b3) {
        var t11, c3 = ~(b3 - 1);
        for (var i4 = 0; i4 < 16; i4++) {
          t11 = c3 & (p5[i4] ^ q3[i4]);
          p5[i4] ^= t11;
          q3[i4] ^= t11;
        }
      }
      function unpack25519(o13, n16) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o13[i4] = n16[2 * i4] + (n16[2 * i4 + 1] << 8);
        o13[15] &= 32767;
      }
      function A5(o13, a8, b3) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o13[i4] = a8[i4] + b3[i4] | 0;
      }
      function Z3(o13, a8, b3) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o13[i4] = a8[i4] - b3[i4] | 0;
      }
      function M3(o13, a8, b3) {
        var i4, j3, t11 = new Float64Array(31);
        for (i4 = 0; i4 < 31; i4++) t11[i4] = 0;
        for (i4 = 0; i4 < 16; i4++) {
          for (j3 = 0; j3 < 16; j3++) {
            t11[i4 + j3] += a8[i4] * b3[j3];
          }
        }
        for (i4 = 0; i4 < 15; i4++) {
          t11[i4] += 38 * t11[i4 + 16];
        }
        for (i4 = 0; i4 < 16; i4++) o13[i4] = t11[i4];
        car25519(o13);
        car25519(o13);
      }
      function S2(o13, a8) {
        M3(o13, a8, a8);
      }
      function inv25519(o13, i4) {
        var c3 = gf();
        var a8;
        for (a8 = 0; a8 < 16; a8++) c3[a8] = i4[a8];
        for (a8 = 253; a8 >= 0; a8--) {
          S2(c3, c3);
          if (a8 !== 2 && a8 !== 4) M3(c3, c3, i4);
        }
        for (a8 = 0; a8 < 16; a8++) o13[a8] = c3[a8];
      }
      function pack25519(o13, n16) {
        var i4, j3, b3;
        var m2 = gf(), t11 = gf();
        for (i4 = 0; i4 < 16; i4++) t11[i4] = n16[i4];
        car25519(t11);
        car25519(t11);
        car25519(t11);
        for (j3 = 0; j3 < 2; j3++) {
          m2[0] = t11[0] - 65517;
          for (i4 = 1; i4 < 15; i4++) {
            m2[i4] = t11[i4] - 65535 - (m2[i4 - 1] >> 16 & 1);
            m2[i4 - 1] &= 65535;
          }
          m2[15] = t11[15] - 32767 - (m2[14] >> 16 & 1);
          b3 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t11, m2, 1 - b3);
        }
        for (i4 = 0; i4 < 16; i4++) {
          o13[2 * i4] = t11[i4] & 255;
          o13[2 * i4 + 1] = t11[i4] >> 8;
        }
      }
      function par25519(a8) {
        var d8 = new Uint8Array(32);
        pack25519(d8, a8);
        return d8[0] & 1;
      }
      function vn(x3, xi, y2, yi, n16) {
        var i4, d8 = 0;
        for (i4 = 0; i4 < n16; i4++) d8 |= x3[xi + i4] ^ y2[yi + i4];
        return (1 & d8 - 1 >>> 8) - 1;
      }
      function crypto_verify_32(x3, xi, y2, yi) {
        return vn(x3, xi, y2, yi, 32);
      }
      function neq25519(a8, b3) {
        var c3 = new Uint8Array(32), d8 = new Uint8Array(32);
        pack25519(c3, a8);
        pack25519(d8, b3);
        return crypto_verify_32(c3, 0, d8, 0);
      }
      function pow2523(o13, i4) {
        var c3 = gf();
        var a8;
        for (a8 = 0; a8 < 16; a8++) c3[a8] = i4[a8];
        for (a8 = 250; a8 >= 0; a8--) {
          S2(c3, c3);
          if (a8 !== 1) M3(c3, c3, i4);
        }
        for (a8 = 0; a8 < 16; a8++) o13[a8] = c3[a8];
      }
      function set25519(r10, a8) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) r10[i4] = a8[i4] | 0;
      }
      function unpackneg(r10, p5) {
        var t11 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r10[2], gf1);
        unpack25519(r10[1], p5);
        S2(num, r10[1]);
        M3(den, num, D2);
        Z3(num, num, r10[2]);
        A5(den, r10[2], den);
        S2(den2, den);
        S2(den4, den2);
        M3(den6, den4, den2);
        M3(t11, den6, num);
        M3(t11, t11, den);
        pow2523(t11, t11);
        M3(t11, t11, num);
        M3(t11, t11, den);
        M3(t11, t11, den);
        M3(r10[0], t11, den);
        S2(chk, r10[0]);
        M3(chk, chk, den);
        if (neq25519(chk, num)) M3(r10[0], r10[0], I3);
        S2(chk, r10[0]);
        M3(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r10[0]) === p5[31] >> 7) Z3(r10[0], gf0, r10[0]);
        M3(r10[3], r10[0], r10[1]);
        return 0;
      }
      function convertPublicKey(pk) {
        var z4 = new Uint8Array(32), q3 = [gf(), gf(), gf(), gf()], a8 = gf(), b3 = gf();
        if (unpackneg(q3, pk)) return null;
        var y2 = q3[1];
        A5(a8, gf1, y2);
        Z3(b3, gf1, y2);
        inv25519(b3, b3);
        M3(a8, a8, b3);
        pack25519(z4, a8);
        return z4;
      }
      function convertSecretKey(sk) {
        var d8 = new Uint8Array(64), o13 = new Uint8Array(32), i4;
        nacl3.lowlevel.crypto_hash(d8, sk, 32);
        d8[0] &= 248;
        d8[31] &= 127;
        d8[31] |= 64;
        for (i4 = 0; i4 < 32; i4++) o13[i4] = d8[i4];
        for (i4 = 0; i4 < 64; i4++) d8[i4] = 0;
        return o13;
      }
      function convertKeyPair(edKeyPair) {
        var publicKey = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey) return null;
        return {
          publicKey,
          secretKey: convertSecretKey(edKeyPair.secretKey)
        };
      }
      return {
        convertPublicKey,
        convertSecretKey,
        convertKeyPair
      };
    });
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// node_modules/@wallet-standard/errors/lib/esm/codes.js
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND = 3834e3;
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND = 3834001;
var WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED = 4001e3;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED = 616e4;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED = 6160001;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED = 6160002;

// node_modules/@wallet-standard/errors/lib/esm/messages.js
var WalletStandardErrorMessages = {
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED]: "The wallet account $address does not support the chain `$chain`",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED]: "The wallet account $address does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED]: "The wallet '$walletName' does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND]: "No account with address $address could be found in the '$walletName' wallet",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND]: "No underlying Wallet Standard wallet could be found for this handle. This can happen if the wallet associated with the handle has been unregistered.",
  [WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED]: "The user rejected the request"
};

// node_modules/@wallet-standard/errors/lib/esm/message-formatter.js
var StateType;
(function(StateType2) {
  StateType2[StateType2["EscapeSequence"] = 0] = "EscapeSequence";
  StateType2[StateType2["Text"] = 1] = "Text";
  StateType2[StateType2["Variable"] = 2] = "Variable";
})(StateType || (StateType = {}));

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7OMCNXQ7.mjs
var n2 = ["aptos:account", "aptos:connect", "aptos:disconnect", "aptos:network", "aptos:onAccountChange", "aptos:onNetworkChange", "aptos:signMessage", "aptos:signTransaction"];
function i(t11, e14 = []) {
  return [...n2, ...e14].every((s5) => s5 in t11.features);
}
function d() {
  let { get: t11, on: e14 } = getWallets(), s5 = t11(), a8 = [];
  return s5.map((l3) => {
    i(l3) && a8.push(l3);
  }), { aptosWallets: a8, on: e14 };
}

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-J4LEOBAE.mjs
var a3 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(a3 || {});
var r2 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r3 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r3 || {});

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-N2SQW5WO.mjs
var n7 = "aptos:signAndSubmitTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MECB2PDY.mjs
var n8 = "aptos:signIn";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-BIF2XL2R.mjs
var e6 = "aptos:signMessage";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FOFHRLON.mjs
var n9 = "aptos:signTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-OYMA2PWW.mjs
var o5 = "aptos:connect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7KTK52MK.mjs
var o6 = "aptos:disconnect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-EKJ7Y4LP.mjs
var t5 = "aptos:account";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FTTDX4QF.mjs
var t6 = "aptos:network";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MNFE4AOY.mjs
var n10 = "aptos:onAccountChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MJDSOKP4.mjs
var e7 = "aptos:onNetworkChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-GQXE77Y5.mjs
var d3 = class o7 extends B {
  constructor({ address: e14, publicKey: n16, ansName: t11 }) {
    super(), this.address = l.from(e14), this.publicKey = n16, this.ansName = t11;
  }
  serialize(e14) {
    if (this.address.serialize(e14), this.publicKey instanceof f) e14.serializeU32AsUleb128(E.Ed25519);
    else if (this.publicKey instanceof Dt) e14.serializeU32AsUleb128(E.MultiEd25519);
    else if (this.publicKey instanceof k) e14.serializeU32AsUleb128(E.SingleKey);
    else if (this.publicKey instanceof Se) e14.serializeU32AsUleb128(E.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e14), e14.serializeStr(this.ansName ?? "");
  }
  static deserialize(e14) {
    let n16 = l.deserialize(e14), t11 = e14.deserializeUleb128AsU32(), s5;
    switch (t11) {
      case E.Ed25519:
        s5 = f.deserialize(e14);
        break;
      case E.MultiEd25519:
        s5 = Dt.deserialize(e14);
        break;
      case E.SingleKey:
        s5 = k.deserialize(e14);
        break;
      case E.MultiKey:
        s5 = Se.deserialize(e14);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t11}`);
    }
    let b3 = e14.deserializeStr() || void 0;
    return new o7({ address: n16, publicKey: s5, ansName: b3 });
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
var t7 = "aptos:devnet";
var o8 = "aptos:testnet";
var A2 = "aptos:localnet";
var T2 = "aptos:mainnet";
var e8 = [t7, o8, A2, T2];

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-J4LEOBAE.mjs
var a4 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(a4 || {});
var r4 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });
var s3 = class n11 extends Error {
  constructor(t11, o13) {
    var _a, _b;
    super(o13 ?? ((_a = r4[t11]) == null ? void 0 : _a.message) ?? "Unknown error occurred"), this.code = t11, this.status = ((_b = r4[t11]) == null ? void 0 : _b.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, n11.prototype);
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r5 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r5 || {});

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-GQXE77Y5.mjs
var d5 = class o9 extends B {
  constructor({ address: e14, publicKey: n16, ansName: t11 }) {
    super(), this.address = l.from(e14), this.publicKey = n16, this.ansName = t11;
  }
  serialize(e14) {
    if (this.address.serialize(e14), this.publicKey instanceof f) e14.serializeU32AsUleb128(E.Ed25519);
    else if (this.publicKey instanceof Dt) e14.serializeU32AsUleb128(E.MultiEd25519);
    else if (this.publicKey instanceof k) e14.serializeU32AsUleb128(E.SingleKey);
    else if (this.publicKey instanceof Se) e14.serializeU32AsUleb128(E.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e14), e14.serializeStr(this.ansName ?? "");
  }
  static deserialize(e14) {
    let n16 = l.deserialize(e14), t11 = e14.deserializeUleb128AsU32(), s5;
    switch (t11) {
      case E.Ed25519:
        s5 = f.deserialize(e14);
        break;
      case E.MultiEd25519:
        s5 = Dt.deserialize(e14);
        break;
      case E.SingleKey:
        s5 = k.deserialize(e14);
        break;
      case E.MultiKey:
        s5 = Se.deserialize(e14);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t11}`);
    }
    let b3 = e14.deserializeStr() || void 0;
    return new o9({ address: n16, publicKey: s5, ansName: b3 });
  }
};

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-J4LEOBAE.mjs
var a5 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(a5 || {});
var r6 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r7 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r7 || {});

// node_modules/@aptos-connect/wallet-api/dist/index.mjs
function base64ToBytes(base64) {
  const binaryString = atob(base64);
  return Uint8Array.from(binaryString, (m2) => m2.charCodeAt(0));
}
function bytesToBase64(bytes) {
  const binaryString = String.fromCharCode(...bytes);
  return btoa(binaryString);
}
function bytesToBase64url(bytes) {
  return bytesToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function serializeAccountAuthenticatorInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serialize(value.authenticator);
}
function deserializeAccountAuthenticatorInput(deserializer) {
  const address = deserializer.deserialize(l);
  const authenticator = deserializer.deserialize(V);
  return { address, authenticator };
}
function serializePublicKey(serializer, value) {
  if (value instanceof f) {
    serializer.serializeU32AsUleb128(E.Ed25519);
  } else if (value instanceof Dt) {
    serializer.serializeU32AsUleb128(E.MultiEd25519);
  } else if (value instanceof k) {
    serializer.serializeU32AsUleb128(E.SingleKey);
  } else if (value instanceof Se) {
    serializer.serializeU32AsUleb128(E.MultiKey);
  } else {
    throw new Error("Unexpected public key type");
  }
  serializer.serialize(value);
}
function deserializePublicKey(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case E.Ed25519:
      return deserializer.deserialize(f);
    case E.MultiEd25519:
      return deserializer.deserialize(Dt);
    case E.SingleKey:
      return deserializer.deserialize(k);
    case E.MultiKey:
      return deserializer.deserialize(Se);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
function serializeAccountInfo(serializer, value) {
  serializer.serialize(value.address);
  serializePublicKey(serializer, value.publicKey);
  serializer.serializeStr(value.name ?? "");
}
function deserializeAccountInfo(deserializer) {
  const address = deserializer.deserialize(l);
  const publicKey = deserializePublicKey(deserializer);
  const name = deserializer.deserializeStr();
  return {
    address,
    publicKey,
    ...name.length > 0 ? { name } : void 0
  };
}
function serializeAccountInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serializeBool(value.publicKey !== void 0);
  if (value.publicKey) {
    serializePublicKey(serializer, value.publicKey);
  }
}
function deserializeAccountInput(deserializer) {
  const address = deserializer.deserialize(l);
  const hasPublicKey = deserializer.deserializeBool();
  const publicKey = hasPublicKey ? deserializePublicKey(deserializer) : void 0;
  return { address, publicKey };
}
function serializeDappInfo(serializer, value) {
  serializer.serializeStr(value.domain);
  serializer.serializeStr(value.name);
  serializer.serializeBool(value.imageURI !== void 0);
  if (value.imageURI !== void 0) {
    serializer.serializeStr(value.imageURI);
  }
}
function deserializeDappInfo(deserializer) {
  const domain = deserializer.deserializeStr();
  const name = deserializer.deserializeStr();
  const hasImageUri = deserializer.deserializeBool();
  const imageURI = hasImageUri ? deserializer.deserializeStr() : void 0;
  return { domain, imageURI, name };
}
var EntryFunctionArgumentVariant = ((EntryFunctionArgumentVariant2) => {
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Undefined"] = 0] = "Undefined";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Array"] = 1] = "Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["String"] = 2] = "String";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Uint8Array"] = 3] = "Uint8Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["AccountAddress"] = 4] = "AccountAddress";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["FixedBytes"] = 5] = "FixedBytes";
  return EntryFunctionArgumentVariant2;
})(EntryFunctionArgumentVariant || {});
function serializeEntryFunctionArgument(serializer, argument) {
  if (argument === void 0 || argument === null) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    return;
  }
  if (Array.isArray(argument)) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.length);
    for (const subArgument of argument) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || typeof argument === "bigint") {
    serializer.serializeU32AsUleb128(
      2
      /* String */
    );
    serializer.serializeStr(argument.toString());
    return;
  }
  if (argument instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(argument);
    return;
  }
  if (argument instanceof ArrayBuffer) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(new Uint8Array(argument));
    return;
  }
  if ("values" in argument) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.values.length);
    for (const subArgument of argument.values) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if ("data" in argument) {
    serializer.serializeU32AsUleb128(
      4
      /* AccountAddress */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value === void 0) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      5
      /* FixedBytes */
    );
    serializer.serializeBytes(argument.value);
    return;
  }
  serializer.serializeU32AsUleb128(
    2
    /* String */
  );
  serializer.serializeStr(argument.value.toString());
}
function deserializeEntryFunctionArgument(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 0: {
      return void 0;
    }
    case 1: {
      const length = deserializer.deserializeUleb128AsU32();
      const args = [];
      for (let i4 = 0; i4 < length; i4 += 1) {
        const argument = deserializeEntryFunctionArgument(deserializer);
        args.push(argument);
      }
      return args;
    }
    case 3: {
      return deserializer.deserializeBytes();
    }
    case 4: {
      return deserializer.deserialize(l);
    }
    case 2: {
      return deserializer.deserializeStr();
    }
    case 5: {
      const bytes = deserializer.deserializeBytes();
      return new t(bytes);
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
var devnetBaseUrl = "https://api.devnet.aptoslabs.com";
var shelbynetBaseUrl = "https://api.shelbynet.aptoslabs.com";
var shelbynet = {
  // This is not reliable and might change in future releases, but it's useful to keep around as "unique id" for
  // the frontend
  chainId: 59,
  faucetUrl: "https://faucet.shelbynet.shelby.xyz",
  indexerUrl: `${shelbynetBaseUrl}/v1/graphql`,
  name: "shelbynet",
  nodeUrl: `${shelbynetBaseUrl}/v1`,
  // Note: using devnet's keyless services, so we don't have to spin up separate ones
  pepperUrl: `${devnetBaseUrl}/keyless/pepper/v0`,
  proverUrl: `${devnetBaseUrl}/keyless/prover/v0`
};
function serializeSignature(serializer, value) {
  if (value instanceof h) {
    serializer.serializeU32AsUleb128(E.Ed25519);
  } else if (value instanceof _e) {
    serializer.serializeU32AsUleb128(E.MultiEd25519);
  } else if (value instanceof O) {
    serializer.serializeU32AsUleb128(E.SingleKey);
  } else {
    throw new Error("Unexpected signature type");
  }
  serializer.serialize(value);
}
function deserializeSignature(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case E.Ed25519:
      return deserializer.deserialize(h);
    case E.MultiEd25519:
      return deserializer.deserialize(_e);
    case E.SingleKey:
      return deserializer.deserialize(O);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
var TransactionPayloadInputVariant = ((TransactionPayloadInputVariant2) => {
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["EntryFunction"] = 0] = "EntryFunction";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Script"] = 1] = "Script";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Multisig"] = 2] = "Multisig";
  return TransactionPayloadInputVariant2;
})(TransactionPayloadInputVariant || {});
function serializeTypeArguments(serializer, typeArguments) {
  serializer.serializeU32AsUleb128(typeArguments.length);
  for (const typeArgument of typeArguments) {
    const typeTag = typeof typeArgument === "string" ? Ae(typeArgument, { allowGenerics: true }) : typeArgument;
    serializer.serialize(typeTag);
  }
}
function deserializeTypeArguments(deserializer) {
  const typeArguments = [];
  const typeArgumentsLength = deserializer.deserializeUleb128AsU32();
  for (let i4 = 0; i4 < typeArgumentsLength; i4 += 1) {
    const typeTag = deserializer.deserialize(U);
    typeArguments.push(typeTag);
  }
  return typeArguments;
}
function serializeEntryFunctionArguments(serializer, functionArguments) {
  serializer.serializeU32AsUleb128(functionArguments.length);
  for (const functionArgument of functionArguments) {
    serializeEntryFunctionArgument(serializer, functionArgument);
  }
}
function deserializeEntryFunctionArguments(deserializer) {
  const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
  const functionArguments = [];
  for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
    const functionArgument = deserializeEntryFunctionArgument(deserializer);
    functionArguments.push(functionArgument);
  }
  return functionArguments;
}
function serializeTransactionPayloadInput(serializer, value) {
  if ("multisigAddress" in value) {
    serializer.serializeU32AsUleb128(
      2
      /* Multisig */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
    const multisigAddress = l.from(value.multisigAddress);
    serializer.serialize(multisigAddress);
  } else if ("function" in value) {
    serializer.serializeU32AsUleb128(
      0
      /* EntryFunction */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  } else {
    serializer.serializeU32AsUleb128(
      1
      /* Script */
    );
    const bytecode = a.fromHexInput(value.bytecode);
    serializer.serializeBytes(bytecode.toUint8Array());
    serializer.serializeU32AsUleb128(value.functionArguments.length);
    for (const argument of value.functionArguments) {
      argument.serializeForScriptFunction(serializer);
    }
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  }
}
function deserializeTransactionPayloadInput(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 2: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      const multisigAddress = deserializer.deserialize(l);
      return {
        function: functionId,
        functionArguments,
        multisigAddress,
        typeArguments
      };
    }
    case 0: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        function: functionId,
        functionArguments,
        typeArguments
      };
    }
    case 1: {
      const bytecode = deserializer.deserializeBytes();
      const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
      const functionArguments = [];
      for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
        const argument = qs(deserializer);
        functionArguments.push(argument);
      }
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        bytecode,
        functionArguments,
        typeArguments
      };
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function chainIdToNetwork(chainId) {
  if (chainId === r.mainnet) {
    return e.MAINNET;
  }
  if (chainId === r.testnet) {
    return e.TESTNET;
  }
  if (chainId >= 50 && chainId < 100 || chainId >= 100 && chainId < 125) {
    return shelbynet.name;
  }
  return e.DEVNET;
}
function isSupportedNetwork(network) {
  return [
    e.MAINNET,
    e.TESTNET,
    e.DEVNET,
    shelbynet.name
  ].includes(network);
}
function serializeWalletRequest({
  dappInfo,
  name,
  version
}) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  const data = serializer.toUint8Array();
  return { data, name, version };
}
function deserializeWalletRequest({
  data,
  name,
  version
}) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  return { dappInfo, name, version };
}
function serializeWalletRequestWithArgs({
  args,
  dappInfo,
  name,
  version
}, serializeArgsFn) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  serializeArgsFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data, name, version };
}
function deserializeWalletRequestWithArgs({ data, name, version }, deserializeArgsFn) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  const args = deserializeArgsFn(deserializer);
  return { args, dappInfo, name, version };
}
var ConnectRequest;
((ConnectRequest2) => {
  ConnectRequest2.name = "connect";
  ConnectRequest2.supportedVersions = [1, 2, 3, 4];
  ConnectRequest2.currentVersion = 4;
  function serializeArgs(serializer, value) {
    serializer.serializeOptionStr(value.dappId);
    serializer.serializeOptionStr(value.dappEd25519PublicKeyB64);
    serializer.serializeOptionStr(value.preferredWalletName);
    serializer.serializeBool(value.claimOptions !== void 0);
    if (value.claimOptions) {
      serializer.serialize(value.claimOptions.secretKey);
      serializer.serializeStr(value.claimOptions.network);
      serializer.serializeOptionStr(value.claimOptions.asset);
      if (!isSupportedNetwork(value.claimOptions.network)) {
        throw new Error(`Unsupported network '${value.claimOptions.network}'`);
      }
    }
  }
  ConnectRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version) {
    if (version === 1) {
      return {};
    }
    const dappId = deserializer.deserializeOption("string");
    const dappEd25519PublicKeyB64 = deserializer.deserializeOption("string");
    const preferredWalletName = version >= 3 ? deserializer.deserializeOption("string") : void 0;
    const hasClaimOptions = version >= 4 ? deserializer.deserializeBool() : false;
    let claimOptions;
    if (hasClaimOptions) {
      const secretKey = deserializer.deserialize(z);
      const network = deserializer.deserializeStr();
      const asset = deserializer.deserializeOption("string");
      if (!isSupportedNetwork(network) || network === shelbynet.name) {
        throw new Error(`Unsupported network '${network}'`);
      }
      claimOptions = { asset, network, secretKey };
    }
    return {
      claimOptions,
      dappEd25519PublicKeyB64,
      dappId,
      preferredWalletName
    };
  }
  ConnectRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args = {}) {
    return serializeWalletRequestWithArgs(
      { args, dappInfo, name: ConnectRequest2.name, version: ConnectRequest2.currentVersion },
      serializeArgs
    );
  }
  ConnectRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequestWithArgs(
      request,
      (d8) => deserializeArgs(d8, request.version)
    );
  }
  ConnectRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === ConnectRequest2.name && ConnectRequest2.supportedVersions.includes(request.version);
  }
  ConnectRequest2.isSerialized = isSerialized;
})(ConnectRequest || (ConnectRequest = {}));
function makeUserApproval(args) {
  return { args, status: "approved" };
}
function makeUserResponseSerializeFn(serializeArgs) {
  return (serializer, value) => {
    serializer.serializeBool(value.status === "approved");
    if (value.status === "approved") {
      serializeArgs(serializer, value.args);
    }
  };
}
function makeUserResponseDeserializeFn(deserializeArgs) {
  return (deserializer) => {
    const isApproved = deserializer.deserializeBool();
    return isApproved ? { args: deserializeArgs(deserializer), status: "approved" } : { status: "dismissed" };
  };
}
function serializeWalletResponse(args, serializeFn) {
  const serializer = new n();
  serializeFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data };
}
function deserializeWalletResponse({ data }, deserializeFn) {
  const deserializer = new a2(data);
  const args = deserializeFn(deserializer);
  return { args };
}
var ConnectResponse;
((ConnectResponse2) => {
  ConnectResponse2.supportedVersions = [1, 2];
  ConnectResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAccountInfo(serializer, value.account);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAccountInfo(serializer, value.account);
    serializer.serializeOptionStr(
      value.pairing !== void 0 ? JSON.stringify(value.pairing) : void 0
    );
  }
  function deserializeApprovalArgs(deserializer) {
    const account = deserializeAccountInfo(deserializer);
    const serializedPairing = deserializer.deserializeOption("string");
    const pairing = serializedPairing !== void 0 ? JSON.parse(serializedPairing) : void 0;
    return { account, pairing };
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args, version = ConnectResponse2.currentVersion) {
    return serializeWalletResponse(
      args,
      version === 1 ? serializeArgsV1 : serializeArgs
    );
  }
  ConnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  ConnectResponse2.deserialize = deserialize;
})(ConnectResponse || (ConnectResponse = {}));
var DisconnectRequest;
((DisconnectRequest2) => {
  DisconnectRequest2.name = "disconnect";
  DisconnectRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: DisconnectRequest2.name, version: DisconnectRequest2.currentVersion });
  }
  DisconnectRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  DisconnectRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === DisconnectRequest2.name && request.version === DisconnectRequest2.currentVersion;
  }
  DisconnectRequest2.isSerialized = isSerialized;
})(DisconnectRequest || (DisconnectRequest = {}));
var DisconnectResponse;
((DisconnectResponse2) => {
  function serialize(args) {
    return serializeWalletResponse(args, () => {
    });
  }
  DisconnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, () => ({}));
  }
  DisconnectResponse2.deserialize = deserialize;
})(DisconnectResponse || (DisconnectResponse = {}));
var GetConnectedAccountsRequest;
((GetConnectedAccountsRequest2) => {
  GetConnectedAccountsRequest2.name = "getConnectedAccounts";
  GetConnectedAccountsRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: GetConnectedAccountsRequest2.name, version: GetConnectedAccountsRequest2.currentVersion });
  }
  GetConnectedAccountsRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  GetConnectedAccountsRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === GetConnectedAccountsRequest2.name && request.version === GetConnectedAccountsRequest2.currentVersion;
  }
  GetConnectedAccountsRequest2.isSerialized = isSerialized;
})(GetConnectedAccountsRequest || (GetConnectedAccountsRequest = {}));
var GetConnectedAccountsResponse;
((GetConnectedAccountsResponse2) => {
  function serializeArgs(serializer, args) {
    serializer.serializeU32AsUleb128(args.length);
    for (const account of args) {
      serializeAccountInfo(serializer, account);
    }
  }
  function deserializeArgs(deserializer) {
    const length = deserializer.deserializeUleb128AsU32();
    const accounts = [];
    for (let i4 = 0; i4 < length; i4 += 1) {
      accounts.push(deserializeAccountInfo(deserializer));
    }
    return accounts;
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  GetConnectedAccountsResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  GetConnectedAccountsResponse2.deserialize = deserialize;
})(GetConnectedAccountsResponse || (GetConnectedAccountsResponse = {}));
var IsConnectedRequest;
((IsConnectedRequest2) => {
  IsConnectedRequest2.name = "isConnected";
  IsConnectedRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: IsConnectedRequest2.name, version: IsConnectedRequest2.currentVersion });
  }
  IsConnectedRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  IsConnectedRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === IsConnectedRequest2.name && request.version === IsConnectedRequest2.currentVersion;
  }
  IsConnectedRequest2.isSerialized = isSerialized;
})(IsConnectedRequest || (IsConnectedRequest = {}));
var IsConnectedResponse;
((IsConnectedResponse2) => {
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value);
  }
  function deserializeArgs(deserializer) {
    return deserializer.deserializeBool();
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  IsConnectedResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  IsConnectedResponse2.deserialize = deserialize;
})(IsConnectedResponse || (IsConnectedResponse = {}));
var SignAndSubmitTransactionRequest;
((SignAndSubmitTransactionRequest2) => {
  SignAndSubmitTransactionRequest2.name = "signAndSubmitTransaction";
  SignAndSubmitTransactionRequest2.supportedVersions = [1, 2, 3, 4];
  SignAndSubmitTransactionRequest2.currentVersion = 4;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOption(value.network);
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeU32AsUleb128(value.feePayer ? 1 : 0);
    if (value.feePayer) {
      serializeAccountAuthenticatorInput(serializer, value.feePayer);
    }
  }
  SignAndSubmitTransactionRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const isPayloadBcsSerializable = version === 1 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(ot) : deserializeTransactionPayloadInput(deserializer);
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeUleb128AsU32();
    const feePayer = hasFeePayer ? deserializeAccountAuthenticatorInput(deserializer) : void 0;
    return {
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      signerAddress
    };
  }
  SignAndSubmitTransactionRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignAndSubmitTransactionRequest2.name, version: SignAndSubmitTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignAndSubmitTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignAndSubmitTransactionRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignAndSubmitTransactionRequest2.name && SignAndSubmitTransactionRequest2.supportedVersions.includes(request.version);
  }
  SignAndSubmitTransactionRequest2.isSerialized = isSerialized;
})(SignAndSubmitTransactionRequest || (SignAndSubmitTransactionRequest = {}));
var SignAndSubmitTransactionResponse;
((SignAndSubmitTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.txnHash);
  }
  function deserializeApprovalArgs(deserializer) {
    const txnHash = deserializer.deserializeStr();
    return { txnHash };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignAndSubmitTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignAndSubmitTransactionResponse2.deserialize = deserialize;
})(SignAndSubmitTransactionResponse || (SignAndSubmitTransactionResponse = {}));
function serializeAptosSignInInput(serializer, value) {
  serializer.serializeStr(JSON.stringify(value));
}
function deserializeAptosSignInInput(deserializer) {
  return JSON.parse(deserializer.deserializeStr());
}
var SignInRequest;
((SignInRequest2) => {
  SignInRequest2.name = "signIn";
  SignInRequest2.supportedVersions = [1, 2, 3];
  SignInRequest2.currentVersion = 3;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(
        `Unsupported network '${value.network}' in SignInRequest.serializeArgs`
      );
    }
    serializeAptosSignInInput(serializer, value);
    serializer.serializeStr(value.network);
  }
  SignInRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, _2) {
    return {
      ...deserializeAptosSignInInput(deserializer),
      network: deserializer.deserializeStr()
    };
  }
  SignInRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    return serializeWalletRequestWithArgs(
      { args, dappInfo, name: SignInRequest2.name, version: SignInRequest2.currentVersion },
      serializeArgs
    );
  }
  SignInRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequestWithArgs(
      request,
      (d8) => deserializeArgs(d8, request.version)
    );
  }
  SignInRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignInRequest2.name && SignInRequest2.supportedVersions.includes(request.version);
  }
  SignInRequest2.isSerialized = isSerialized;
})(SignInRequest || (SignInRequest = {}));
function serializeAptosSignInOutputV1(serializer, value) {
  serializeAccountInfo(serializer, value.account);
  serializer.serializeStr(JSON.stringify(value.input));
  serializer.serializeStr(value.plainText);
  serializeSignature(serializer, value.signature);
  serializer.serializeBytes(value.signingMessage);
  serializer.serializeStr(value.type);
}
function deserializeAptosSignInOutputV1(deserializer) {
  return {
    account: new d5(deserializeAccountInfo(deserializer)),
    input: JSON.parse(deserializer.deserializeStr()),
    plainText: deserializer.deserializeStr(),
    signature: deserializeSignature(deserializer),
    signingMessage: deserializer.deserializeBytes(),
    type: deserializer.deserializeStr()
  };
}
function serializeAptosSignInOutput(serializer, value) {
  serializeAccountInfo(serializer, value.account);
  serializer.serializeStr(JSON.stringify(value.input));
  serializeSignature(serializer, value.signature);
  serializer.serializeStr(value.type);
}
function deserializeAptosSignInOutput(deserializer) {
  return {
    account: new d5(deserializeAccountInfo(deserializer)),
    input: JSON.parse(deserializer.deserializeStr()),
    signature: deserializeSignature(deserializer),
    type: deserializer.deserializeStr()
  };
}
var SignInResponse;
((SignInResponse2) => {
  SignInResponse2.supportedVersions = [1, 2];
  SignInResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAptosSignInOutputV1(serializer, value);
  }
  function deserializeApprovalArgsV1(deserializer) {
    return deserializeAptosSignInOutputV1(deserializer);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAptosSignInOutput(serializer, value);
  }
  function deserializeApprovalArgs(deserializer) {
    return deserializeAptosSignInOutput(deserializer);
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgsV1 = makeUserResponseDeserializeFn(
    deserializeApprovalArgsV1
  );
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args, version = SignInResponse2.currentVersion) {
    return serializeWalletResponse(
      args,
      version === 1 ? serializeArgsV1 : serializeArgs
    );
  }
  SignInResponse2.serialize = serialize;
  function deserialize(serializedResponse, version = SignInResponse2.currentVersion) {
    return deserializeWalletResponse(
      serializedResponse,
      version === 1 ? deserializeArgsV1 : deserializeArgs
    );
  }
  SignInResponse2.deserialize = deserialize;
})(SignInResponse || (SignInResponse = {}));
var SignMessageRequest;
((SignMessageRequest2) => {
  SignMessageRequest2.name = "signMessage";
  SignMessageRequest2.supportedVersions = [1, 2];
  SignMessageRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeU8(value.chainId);
    serializer.serializeBytes(value.nonce);
    serializer.serializeBytes(value.message);
  }
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 2 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const chainId = deserializer.deserializeU8();
    const nonce = deserializer.deserializeBytes();
    const message = deserializer.deserializeBytes();
    return { chainId, message, nonce, signerAddress };
  }
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignMessageRequest2.name, version: SignMessageRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignMessageRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (d8) => deserializeArgs(d8, serializedRequest.version)
    );
  }
  SignMessageRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignMessageRequest2.name && request.version === SignMessageRequest2.currentVersion;
  }
  SignMessageRequest2.isSerialized = isSerialized;
})(SignMessageRequest || (SignMessageRequest = {}));
var SignMessageResponse;
((SignMessageResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.fullMessage);
    serializeSignature(serializer, value.signature);
  }
  function deserializeApprovalArgs(deserializer) {
    const fullMessage = deserializer.deserializeStr();
    const signature = deserializeSignature(deserializer);
    return { fullMessage, signature };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignMessageResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignMessageResponse2.deserialize = deserialize;
})(SignMessageResponse || (SignMessageResponse = {}));
var SignTransactionRequest;
((SignTransactionRequest2) => {
  SignTransactionRequest2.name = "signTransaction";
  SignTransactionRequest2.supportedVersions = [1, 2, 3, 4, 5];
  SignTransactionRequest2.currentVersion = 5;
  function normalizeArgs(args) {
    const {
      feePayer,
      secondarySigners,
      senderPublicKey,
      signerAddress,
      transaction
    } = args;
    const sender = {
      address: transaction.sender,
      publicKey: senderPublicKey
    };
    const network = chainIdToNetwork(args.transaction.chain_id.chainId);
    return {
      expirationTimestamp: Number(transaction.expiration_timestamp_secs),
      feePayer,
      gasUnitPrice: Number(transaction.gas_unit_price),
      maxGasAmount: Number(transaction.max_gas_amount),
      network,
      payload: transaction.payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  SignTransactionRequest2.normalizeArgs = normalizeArgs;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOption(value.network);
    serializer.serializeBool(value.sender !== void 0);
    if (value.sender !== void 0) {
      serializeAccountInput(serializer, value.sender);
    }
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU32AsUleb128(value.expirationSecondsFromNow ?? 0);
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeBool(value.feePayer !== void 0);
    if (value.feePayer !== void 0) {
      serializeAccountInput(serializer, value.feePayer);
    }
    const secondarySigners = value.secondarySigners ?? [];
    serializer.serializeU32AsUleb128(secondarySigners.length);
    for (const signer of secondarySigners) {
      serializeAccountInput(serializer, signer);
    }
  }
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const hasSender = deserializer.deserializeBool();
    const sender = hasSender ? deserializeAccountInput(deserializer) : void 0;
    const isPayloadBcsSerializable = version < 4 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(ot) : deserializeTransactionPayloadInput(deserializer);
    const expirationSecondsFromNow = deserializer.deserializeUleb128AsU32();
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeBool();
    const feePayer = hasFeePayer ? deserializeAccountInput(deserializer) : void 0;
    const secondarySignersLength = deserializer.deserializeUleb128AsU32();
    const secondarySigners = [];
    for (let i4 = 0; i4 < secondarySignersLength; i4 += 1) {
      secondarySigners.push(deserializeAccountInput(deserializer));
    }
    return {
      expirationSecondsFromNow: expirationSecondsFromNow > 0 ? expirationSecondsFromNow : void 0,
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignTransactionRequest2.name, version: SignTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignTransactionRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignTransactionRequest2.name && SignTransactionRequest2.supportedVersions.includes(request.version);
  }
  SignTransactionRequest2.isSerialized = isSerialized;
})(SignTransactionRequest || (SignTransactionRequest = {}));
var SignTransactionResponse;
((SignTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serialize(value.authenticator);
    serializer.serializeBool(value.rawTransaction !== void 0);
    if (value.rawTransaction !== void 0) {
      serializer.serialize(value.rawTransaction);
    }
  }
  function deserializeApprovalArgs(deserializer) {
    const authenticator = deserializer.deserialize(V);
    const hasRawTransaction = deserializer.deserializeBool();
    const rawTransaction = hasRawTransaction ? deserializer.deserialize(pe) : void 0;
    return {
      authenticator,
      rawTransaction
    };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignTransactionResponse2.deserialize = deserialize;
})(SignTransactionResponse || (SignTransactionResponse = {}));
function isTypedMessage(messageCls, message) {
  return (message == null ? void 0 : message.__messageType) === messageCls.TYPE;
}
var _PromptConnectionRequestMessage = class _PromptConnectionRequestMessage2 {
  constructor() {
    this.__messageType = _PromptConnectionRequestMessage2.TYPE;
  }
};
_PromptConnectionRequestMessage.TYPE = "PromptConnectionRequest";
var PromptConnectionRequestMessage = _PromptConnectionRequestMessage;
var _PromptConnectionResponseMessage = class _PromptConnectionResponseMessage2 {
  constructor(serializedRequest) {
    this.serializedRequest = serializedRequest;
    this.__messageType = _PromptConnectionResponseMessage2.TYPE;
  }
};
_PromptConnectionResponseMessage.TYPE = "PromptConnectionResponse";
var PromptConnectionResponseMessage = _PromptConnectionResponseMessage;
var _PromptApprovalResponseMessage = class _PromptApprovalResponseMessage2 {
  constructor(serializedValue) {
    this.serializedValue = serializedValue;
    this.__messageType = _PromptApprovalResponseMessage2.TYPE;
  }
};
_PromptApprovalResponseMessage.TYPE = "PromptApprovalResponse";
var PromptApprovalResponseMessage = _PromptApprovalResponseMessage;
var _PromptUnauthorizedErrorMessage = class _PromptUnauthorizedErrorMessage2 {
  constructor() {
    this.__messageType = _PromptUnauthorizedErrorMessage2.TYPE;
  }
};
_PromptUnauthorizedErrorMessage.TYPE = "PromptUnauthorizedError";
var PromptUnauthorizedErrorMessage = _PromptUnauthorizedErrorMessage;
function encodeWalletRequestBody({
  data,
  ...rest
}) {
  const serialized = JSON.stringify(
    { data, ...rest },
    (key, value) => key === "data" ? bytesToBase64(value) : value
  );
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64(utf8Encoded);
}
function encodePopupWalletRequest(request) {
  const serialized = JSON.stringify(request, (key, value) => {
    switch (key) {
      case "body":
        return encodeWalletRequestBody(value);
      case "clientIdentityKey":
        return bytesToBase64(value.toUint8Array());
      case "signature":
        return bytesToBase64(value.toUint8Array());
      default:
        return value;
    }
  });
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64url(utf8Encoded);
}
function makePopupWalletRequestChallenge({
  accountAddress,
  body,
  id,
  timestamp
}) {
  const serializer = new n();
  serializer.serializeStr("SignedPopupWalletRequest");
  serializer.serializeStr(id);
  serializer.serializeU64(timestamp);
  serializer.serializeBool(accountAddress !== void 0);
  if (accountAddress !== void 0) {
    serializer.serialize(l.from(accountAddress));
  }
  serializer.serializeStr(body.name);
  serializer.serializeU8(body.version);
  serializer.serializeBytes(body.data);
  return serializer.toUint8Array();
}

// node_modules/@identity-connect/crypto/dist/index.mjs
var import_ed2curve = __toESM(require_ed2curve(), 1);
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var EncryptionEnvelopeError = class extends Error {
};
var EnvelopeMessageMismatchError = class _EnvelopeMessageMismatchError extends EncryptionEnvelopeError {
  constructor(message, field) {
    super(message);
    this.field = field;
    this.name = "EnvelopeMessageMismatchError";
    Object.setPrototypeOf(this, _EnvelopeMessageMismatchError.prototype);
  }
};
var DecryptionError = class _DecryptionError extends EncryptionEnvelopeError {
  constructor(message) {
    super(message);
    this.name = "DecryptionError";
    Object.setPrototypeOf(this, _DecryptionError.prototype);
  }
};
var KeyTypes = ((KeyTypes2) => {
  KeyTypes2["Ed25519PublicKey"] = "Ed25519PublicKey";
  KeyTypes2["Ed25519SecretKey"] = "Ed25519SecretKey";
  KeyTypes2["X25519PublicKey"] = "X25519PublicKey";
  KeyTypes2["X25519SecretKey"] = "X25519SecretKey";
  return KeyTypes2;
})(KeyTypes || {});
function createX25519KeyPair() {
  return keypairToX25519(import_tweetnacl2.default.box.keyPair());
}
function createEd25519KeyPair() {
  return keypairToEd25519(import_tweetnacl2.default.sign.keyPair());
}
function toKey(rawKey, type) {
  return {
    key: rawKey,
    type
  };
}
function keypairToEd25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "Ed25519PublicKey"
      /* Ed25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "Ed25519SecretKey"
      /* Ed25519SecretKey */
    )
  };
}
function keypairToX25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "X25519PublicKey"
      /* X25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "X25519SecretKey"
      /* X25519SecretKey */
    )
  };
}
function decodeBase64(base64Str) {
  if (globalThis.Buffer) {
    return new Uint8Array(Buffer.from(base64Str, "base64"));
  }
  return Uint8Array.from(atob(base64Str), (m2) => m2.codePointAt(0));
}
function encodeBase64(bytes) {
  if (globalThis.Buffer) {
    return Buffer.from(bytes).toString("base64");
  }
  return btoa(Array.from(bytes, (x3) => String.fromCodePoint(x3)).join(""));
}
function concatUint8array(arrayOne, arrayTwo) {
  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
  mergedArray.set(arrayOne);
  mergedArray.set(arrayTwo, arrayOne.length);
  return mergedArray;
}
var SIGNATURE_PREFIX = "APTOS::IDENTITY_CONNECT";
function convertEd25519PublicKeyToX25519PublicKey(ed25519PublicKey, errorKeyName) {
  const x25519PublicKey = import_ed2curve.default.convertPublicKey(
    ed25519PublicKey.key.slice(0, 32)
  );
  if (!x25519PublicKey) {
    throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);
  }
  return toKey(
    x25519PublicKey,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
}
function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey) {
  const x25519SecretKey = import_ed2curve.default.convertSecretKey(
    ed25519SecretKey.key.slice(0, 32)
  );
  return toKey(
    x25519SecretKey,
    "X25519SecretKey"
    /* X25519SecretKey */
  );
}
function serializeEncryptionResult(enc) {
  return {
    nonceB64: encodeBase64(enc.nonce),
    securedB64: encodeBase64(enc.secured)
  };
}
function deserializeEncryptionResult(enc) {
  return {
    nonce: decodeBase64(enc.nonceB64),
    secured: decodeBase64(enc.securedB64)
  };
}
function encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
  const messageUint8 = new TextEncoder().encode(message);
  const secured = import_tweetnacl.default.box(
    messageUint8,
    nonce,
    receiverX25519PublicKey.key,
    senderX25519SecretKey.key.slice(0, 32)
  );
  return { nonce, secured };
}
function encryptObject(senderX25519SecretKey, receiverEd25519PublicKey, message) {
  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(
    receiverEd25519PublicKey,
    "receiver public key"
  );
  return encryptObjectDirect(
    senderX25519SecretKey,
    receiverX25519PublicKey,
    message
  );
}
function encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  return encryptMessageDirect(
    senderX25519SecretKey,
    receiverX25519PublicKey,
    JSON.stringify(message)
  );
}
function decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  let decryptedUint8;
  try {
    decryptedUint8 = import_tweetnacl.default.box.open(
      securedMessage,
      nonce,
      senderX25519PublicKey.key.slice(0, 32),
      receiverX25519SecretKey.key.slice(0, 32)
    );
  } catch (e14) {
    throw new DecryptionError(`Could not decrypt message: ${e14.message}`);
  }
  if (!decryptedUint8) {
    throw new DecryptionError("Could not decrypt message");
  }
  return new TextDecoder().decode(decryptedUint8);
}
function decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {
  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(
    receiverEd25519SecretKey
  );
  return decryptObjectDirect(
    senderX25519PublicKey,
    receiverX25519SecretKey,
    securedMessage,
    nonce
  );
}
function decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  const decryptedStr = decryptMessageDirect(
    senderX25519PublicKey,
    receiverX25519SecretKey,
    securedMessage,
    nonce
  );
  return JSON.parse(decryptedStr);
}
function messageHash(message, purpose) {
  const signaturePrefixHash = new Uint8Array(
    sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`)
  );
  return new Uint8Array(
    sha3_256(concatUint8array(signaturePrefixHash, message))
  );
}
function signWithEd25519SecretKey(message, signingEd25519SecretKey, purpose) {
  return import_tweetnacl.default.sign.detached(
    messageHash(message, purpose),
    signingEd25519SecretKey.key
  );
}
function verifySignature(message, signature, signingPublicKey, purpose) {
  return signingPublicKey.verifySignature({
    message: messageHash(message, purpose),
    signature
  });
}
var REQUIRED_FIELDS = [
  "receiverEd25519PublicKeyB64",
  "senderEd25519PublicKeyB64",
  "senderX25519PublicKeyB64",
  "sequence",
  "timestampMillis"
].sort();
function ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage) {
  const intersection = Object.keys(privateMessage).filter(
    (x3) => Object.keys(publicMessage).includes(x3)
  );
  if (intersection.length > 0) {
    const field = intersection[0];
    throw new EnvelopeMessageMismatchError(
      `Field ${field} appears in both private and public message fields`,
      field
    );
  }
}
function ensureMetadataFields(message) {
  const messageKeys = Object.keys(message).sort();
  const extraFields = messageKeys.filter(
    (key) => !REQUIRED_FIELDS.includes(key)
  );
  const missingFields = REQUIRED_FIELDS.filter(
    (key) => !messageKeys.includes(key)
  );
  if (extraFields.length > 0 || missingFields.length > 0) {
    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(", ")})` : "";
    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(", ")})` : "";
    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;
    throw new EnvelopeMessageMismatchError(
      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,
      "_metadata"
    );
  }
}
function encryptAndSignEnvelope(senderEd25519SecretKey, senderEd25519PublicKey, receiverEd25519PublicKey, sequence, publicMessage, privateMessage) {
  const senderEphemeralX25519KeyPair = createX25519KeyPair();
  const metadata = constructMetadata(
    senderEd25519PublicKey,
    receiverEd25519PublicKey,
    sequence,
    senderEphemeralX25519KeyPair.publicKey
  );
  ensureMetadataFields(metadata);
  ensurePrivatePublicFieldsDisjoint(
    privateMessage,
    publicMessage
  );
  return dangerouslyEncryptAndSignEnvelopeUnvalidated(
    senderEd25519SecretKey,
    receiverEd25519PublicKey,
    metadata,
    privateMessage,
    publicMessage,
    senderEphemeralX25519KeyPair
  );
}
function constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519PublicKey) {
  return {
    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),
    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),
    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),
    sequence,
    timestampMillis: Date.now()
  };
}
function dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair) {
  const encryptionResult = encryptObject(
    senderEphemeralX25519KeyPair.secretKey,
    receiverEd25519PublicKey,
    privateMessage
  );
  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);
  const encryptedPrivateMessageBytes = decodeBase64(
    encryptedPrivateMessage.securedB64
  );
  const serializedPublicMessage = JSON.stringify({
    ...publicMessage,
    _metadata: metadata
  });
  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);
  const messageSignature = signEnvelope(
    publicMessageBytes,
    encryptedPrivateMessageBytes,
    senderEd25519SecretKey
  );
  return {
    encryptedPrivateMessage,
    messageSignature,
    serializedPublicMessage
  };
}
function combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes) {
  const publicMessageBytesHash = sha3_256(publicMessageBytes);
  const privateMessageBytesHash = sha3_256(privateMessageBytes);
  const combinedHash = new Uint8Array(
    publicMessageBytesHash.length + privateMessageBytesHash.length
  );
  combinedHash.set(publicMessageBytesHash);
  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);
  return sha3_256(combinedHash);
}
function signEnvelope(publicMessageBytes, privateMessageBytes, senderEd25519SecretKey) {
  const messageHashBytes = combineHashedEnvelopeMessageBytes(
    publicMessageBytes,
    privateMessageBytes
  );
  const signatureBytes = signWithEd25519SecretKey(
    messageHashBytes,
    senderEd25519SecretKey,
    "SECURED_ENVELOPE"
  );
  return a.fromHexInput(signatureBytes).toString();
}
function verifyEnvelopeSignature(publicMessageBytes, privateMessageBytes, messageSignatureInput, senderEd25519PublicKey) {
  const messageSignature = new h(
    a.fromHexInput(messageSignatureInput).toUint8Array()
  );
  const senderPublicKey = new f(senderEd25519PublicKey.key);
  const messageHashBytes = combineHashedEnvelopeMessageBytes(
    publicMessageBytes,
    privateMessageBytes
  );
  const messageVerified = verifySignature(
    messageHashBytes,
    messageSignature,
    senderPublicKey,
    "SECURED_ENVELOPE"
  );
  if (!messageVerified) {
    throw new EnvelopeMessageMismatchError(
      "Could not verify SecuredEnvelope signature",
      "messageSignature"
    );
  }
}
function decryptEnvelope(senderEd25519PublicKey, receiverEd25519SecretKey, message) {
  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;
  const publicMessage = JSON.parse(serializedPublicMessage);
  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);
  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);
  verifyEnvelopeSignature(
    rawPublicMessage,
    rawPrivateMessage,
    messageSignature,
    senderEd25519PublicKey
  );
  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);
  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;
  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {
    throw new EnvelopeMessageMismatchError(
      "senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey",
      "senderPublicKey"
    );
  }
  const senderX25519PublicKeyBytes = decodeBase64(
    publicMessage._metadata.senderX25519PublicKeyB64
  );
  const senderX25519PublicKey = toKey(
    senderX25519PublicKeyBytes,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);
  const privateMessage = decryptObject(
    senderX25519PublicKey,
    receiverEd25519SecretKey,
    encryptionResult.secured,
    encryptionResult.nonce
  );
  ensureMetadataFields(publicMessage._metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return {
    messageSignature,
    privateMessage,
    publicMessage
  };
}
function serializePublicKeyB64(publicKey) {
  const serializer = new n();
  serializePublicKey(serializer, publicKey);
  return bytesToBase64(serializer.toUint8Array());
}
function deserializePublicKeyB64(publicKeyB64) {
  const serializedPublicKey = base64ToBytes(publicKeyB64);
  const deserializer = new a2(serializedPublicKey);
  return deserializePublicKey(deserializer);
}
function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64) {
  return new f(decodeBase64(ed25519PublicKeyB64));
}
var AccountConnectionAction = ((AccountConnectionAction2) => {
  AccountConnectionAction2["ADD"] = "add";
  AccountConnectionAction2["REMOVE"] = "remove";
  return AccountConnectionAction2;
})(AccountConnectionAction || {});

// node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: (config2 == null ? void 0 : config2.lang) ?? (store == null ? void 0 : store.lang),
    message: config2 == null ? void 0 : config2.message,
    abortEarly: (config2 == null ? void 0 : config2.abortEarly) ?? (store == null ? void 0 : store.abortEarly),
    abortPipeEarly: (config2 == null ? void 0 : config2.abortPipeEarly) ?? (store == null ? void 0 : store.abortPipeEarly)
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2 == null ? void 0 : store2.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3 == null ? void 0 : store3.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  var _a;
  return (_a = store4 == null ? void 0 : store4.get(reference)) == null ? void 0 : _a.get(lang);
}
function _stringify(input) {
  var _a, _b;
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && ((_b = (_a = Object.getPrototypeOf(input)) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name)) ?? "null";
  }
  return type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = (other == null ? void 0 : other.expected) ?? context.expects ?? null;
  const received = (other == null ? void 0 : other.received) ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other == null ? void 0 : other.path,
    issues: other == null ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = (other == null ? void 0 : other.message) ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message !== void 0) {
    issue.message = typeof message === "function" ? (
      // @ts-expect-error
      message(issue)
    ) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value2) {
      return context["~run"]({ value: value2 }, getGlobalConfig());
    }
  };
}
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};
var EMOJI_REGEX = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
  new RegExp("^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$", "u")
);
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function is(schema, input) {
  return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function function_(message) {
  return {
    kind: "schema",
    type: "function",
    reference: function_,
    expects: "Function",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "function") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function looseObject(entries, message) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: false,
    entries,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      var _a;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
          valueSchema.default !== void 0) {
            const value2 = key in input ? (
              // @ts-expect-error
              input[key]
            ) : getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value2 }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value2
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_a = dataset.issues) == null ? void 0 : _a.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) {
            dataset.value[key] = getFallback(valueSchema);
          } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config2, {
              input: void 0,
              expected: `"${key}"`,
              path: [
                {
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  // @ts-expect-error
                  value: input[key]
                }
              ]
            });
            if (config2.abortEarly) {
              break;
            }
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (const key in input) {
            if (_isValidObjectKey(input, key) && !(key in this.entries)) {
              dataset.value[key] = input[key];
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function nullish(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
function number(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema["~run"]({ value: input }, getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      for (const item of pipe2) {
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item["~run"](dataset, config2);
          }
        }
      }
      return dataset;
    }
  };
}

// node_modules/better-promises/dist/index.js
var $ = Object.defineProperty;
var k2 = (r10, t11, e14) => t11 in r10 ? $(r10, t11, { enumerable: true, configurable: true, writable: true, value: e14 }) : r10[t11] = e14;
var q = (r10, t11, e14) => k2(r10, t11 + "", e14);
function z2(r10, t11) {
  return (e14) => e14 instanceof r10 && e14.type === t11;
}
function P(r10, t11) {
  t11 || (t11 = []);
  const e14 = Symbol(r10);
  class c3 extends Error {
    constructor(...s5) {
      const a8 = typeof t11 == "function" ? t11(...s5) : typeof t11 == "string" ? [t11] : t11 || [];
      super(...a8), q(this, "type", e14), this.name = r10;
    }
  }
  return Object.defineProperty(c3, "name", { value: r10 }), [c3, z2(c3, e14)];
}
var [G, M] = P("CancelledError", "Promise was canceled");
var [H, N] = P(
  "TimeoutError",
  (r10, t11) => [`Timeout reached: ${r10}ms`, { cause: t11 }]
);
var B2 = Symbol("Resolved");

// node_modules/@telegram-apps/toolkit/dist/index.js
function O2(o13, e14) {
  e14 || (e14 = {});
  const {
    textColor: r10,
    bgColor: t11,
    shouldLog: s5
  } = e14, c3 = s5 === void 0 ? true : s5, d8 = typeof c3 == "boolean" ? () => c3 : c3, u2 = (n16, a8, ...i4) => {
    if (a8 || d8()) {
      const l3 = "font-weight:bold;padding:0 5px;border-radius:100px", [b3, m2, p5] = {
        log: ["#0089c3", "white", "INFO"],
        error: ["#ff0000F0", "white", "ERR"],
        warn: ["#D38E15", "white", "WARN"]
      }[n16];
      console[n16](
        `%c${p5} ${Intl.DateTimeFormat("en-GB", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          fractionalSecondDigits: 3,
          timeZone: "UTC"
        }).format(/* @__PURE__ */ new Date())}%c %c${o13}`,
        `${l3};background-color:${b3};color:${m2}`,
        "",
        `${l3};${r10 ? `color:${r10};` : ""}${t11 ? `background-color:${t11}` : ""}`,
        ...i4
      );
    }
  };
  return [
    ["log", "forceLog"],
    ["warn", "forceWarn"],
    ["error", "forceError"]
  ].reduce((n16, [a8, i4]) => (n16[a8] = u2.bind(void 0, a8, false), n16[i4] = u2.bind(void 0, a8, true), n16), {});
}

// node_modules/@telegram-apps/transformers/dist/index.js
var b;
function N2(e14) {
  return {
    lang: (e14 == null ? void 0 : e14.lang) ?? (b == null ? void 0 : b.lang),
    message: e14 == null ? void 0 : e14.message,
    abortEarly: (e14 == null ? void 0 : e14.abortEarly) ?? (b == null ? void 0 : b.abortEarly),
    abortPipeEarly: (e14 == null ? void 0 : e14.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)
  };
}
var D;
function Z(e14) {
  return D == null ? void 0 : D.get(e14);
}
var P2;
function ee(e14) {
  return P2 == null ? void 0 : P2.get(e14);
}
var j;
function ne(e14, n16) {
  var r10;
  return (r10 = j == null ? void 0 : j.get(e14)) == null ? void 0 : r10.get(n16);
}
function re(e14) {
  var r10, t11;
  const n16 = typeof e14;
  return n16 === "string" ? `"${e14}"` : n16 === "number" || n16 === "bigint" || n16 === "boolean" ? `${e14}` : n16 === "object" || n16 === "function" ? (e14 && ((t11 = (r10 = Object.getPrototypeOf(e14)) == null ? void 0 : r10.constructor) == null ? void 0 : t11.name)) ?? "null" : n16;
}
function f2(e14, n16, r10, t11, s5) {
  const u2 = s5 && "input" in s5 ? s5.input : r10.value, i4 = (s5 == null ? void 0 : s5.expected) ?? e14.expects ?? null, l3 = (s5 == null ? void 0 : s5.received) ?? re(u2), o13 = {
    kind: e14.kind,
    type: e14.type,
    input: u2,
    expected: i4,
    received: l3,
    message: `Invalid ${n16}: ${i4 ? `Expected ${i4} but r` : "R"}eceived ${l3}`,
    requirement: e14.requirement,
    path: s5 == null ? void 0 : s5.path,
    issues: s5 == null ? void 0 : s5.issues,
    lang: t11.lang,
    abortEarly: t11.abortEarly,
    abortPipeEarly: t11.abortPipeEarly
  }, y2 = e14.kind === "schema", p5 = (s5 == null ? void 0 : s5.message) ?? e14.message ?? ne(e14.reference, o13.lang) ?? (y2 ? ee(o13.lang) : null) ?? t11.message ?? Z(o13.lang);
  p5 && (o13.message = typeof p5 == "function" ? (
    // @ts-expect-error
    p5(o13)
  ) : p5), y2 && (r10.typed = false), r10.issues ? r10.issues.push(o13) : r10.issues = [o13];
}
function h2(e14) {
  return {
    version: 1,
    vendor: "valibot",
    validate(n16) {
      return e14["~run"]({ value: n16 }, N2());
    }
  };
}
function W2(e14, n16) {
  return Object.hasOwn(e14, n16) && n16 !== "__proto__" && n16 !== "prototype" && n16 !== "constructor";
}
function te(e14, n16) {
  const r10 = [...new Set(e14)];
  return r10.length > 1 ? `(${r10.join(` ${n16} `)})` : r10[0] ?? "never";
}
var se = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e14) {
    super(e14[0].message), this.name = "ValiError", this.issues = e14;
  }
};
function L(e14, n16) {
  return {
    kind: "validation",
    type: "check",
    reference: L,
    async: false,
    expects: null,
    requirement: e14,
    message: n16,
    "~run"(r10, t11) {
      return r10.typed && !this.requirement(r10.value) && f2(this, "input", r10, t11), r10;
    }
  };
}
function R(e14) {
  return {
    kind: "validation",
    type: "integer",
    reference: R,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e14,
    "~run"(n16, r10) {
      return n16.typed && !this.requirement(n16.value) && f2(this, "integer", n16, r10), n16;
    }
  };
}
function d7(e14) {
  return {
    kind: "transformation",
    type: "transform",
    reference: d7,
    async: false,
    operation: e14,
    "~run"(n16) {
      return n16.value = this.operation(n16.value), n16;
    }
  };
}
function U2(e14, n16, r10) {
  return typeof e14.default == "function" ? (
    // @ts-expect-error
    e14.default(n16, r10)
  ) : (
    // @ts-expect-error
    e14.default
  );
}
function _(e14) {
  return {
    kind: "schema",
    type: "boolean",
    reference: _,
    expects: "boolean",
    async: false,
    message: e14,
    get "~standard"() {
      return h2(this);
    },
    "~run"(n16, r10) {
      return typeof n16.value == "boolean" ? n16.typed = true : f2(this, "type", n16, r10), n16;
    }
  };
}
function z3(e14) {
  return {
    kind: "schema",
    type: "date",
    reference: z3,
    expects: "Date",
    async: false,
    message: e14,
    get "~standard"() {
      return h2(this);
    },
    "~run"(n16, r10) {
      return n16.value instanceof Date ? isNaN(n16.value) ? f2(this, "type", n16, r10, {
        received: '"Invalid Date"'
      }) : n16.typed = true : f2(this, "type", n16, r10), n16;
    }
  };
}
function J(e14, n16) {
  return {
    kind: "schema",
    type: "instance",
    reference: J,
    expects: e14.name,
    async: false,
    class: e14,
    message: n16,
    get "~standard"() {
      return h2(this);
    },
    "~run"(r10, t11) {
      return r10.value instanceof this.class ? r10.typed = true : f2(this, "type", r10, t11), r10;
    }
  };
}
function A4(e14) {
  return {
    kind: "schema",
    type: "lazy",
    reference: A4,
    expects: "unknown",
    async: false,
    getter: e14,
    get "~standard"() {
      return h2(this);
    },
    "~run"(n16, r10) {
      return this.getter(n16.value)["~run"](n16, r10);
    }
  };
}
function k3(e14, n16) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: k3,
    expects: "Object",
    async: false,
    entries: e14,
    message: n16,
    get "~standard"() {
      return h2(this);
    },
    "~run"(r10, t11) {
      var u2;
      const s5 = r10.value;
      if (s5 && typeof s5 == "object") {
        r10.typed = true, r10.value = {};
        for (const i4 in this.entries) {
          const l3 = this.entries[i4];
          if (i4 in s5 || (l3.type === "exact_optional" || l3.type === "optional" || l3.type === "nullish") && // @ts-expect-error
          l3.default !== void 0) {
            const o13 = i4 in s5 ? (
              // @ts-expect-error
              s5[i4]
            ) : U2(l3), y2 = l3["~run"]({ value: o13 }, t11);
            if (y2.issues) {
              const p5 = {
                type: "object",
                origin: "value",
                input: s5,
                key: i4,
                value: o13
              };
              for (const m2 of y2.issues)
                m2.path ? m2.path.unshift(p5) : m2.path = [p5], (u2 = r10.issues) == null || u2.push(m2);
              if (r10.issues || (r10.issues = y2.issues), t11.abortEarly) {
                r10.typed = false;
                break;
              }
            }
            y2.typed || (r10.typed = false), r10.value[i4] = y2.value;
          } else if (l3.type !== "exact_optional" && l3.type !== "optional" && l3.type !== "nullish" && (f2(this, "key", r10, t11, {
            input: void 0,
            expected: `"${i4}"`,
            path: [
              {
                type: "object",
                origin: "key",
                input: s5,
                key: i4,
                // @ts-expect-error
                value: s5[i4]
              }
            ]
          }), t11.abortEarly))
            break;
        }
        if (!r10.issues || !t11.abortEarly)
          for (const i4 in s5)
            W2(s5, i4) && !(i4 in this.entries) && (r10.value[i4] = s5[i4]);
      } else
        f2(this, "type", r10, t11);
      return r10;
    }
  };
}
function E2(e14) {
  return {
    kind: "schema",
    type: "number",
    reference: E2,
    expects: "number",
    async: false,
    message: e14,
    get "~standard"() {
      return h2(this);
    },
    "~run"(n16, r10) {
      return typeof n16.value == "number" && !isNaN(n16.value) ? n16.typed = true : f2(this, "type", n16, r10), n16;
    }
  };
}
function c(e14, n16) {
  return {
    kind: "schema",
    type: "optional",
    reference: c,
    expects: `(${e14.expects} | undefined)`,
    async: false,
    wrapped: e14,
    default: n16,
    get "~standard"() {
      return h2(this);
    },
    "~run"(r10, t11) {
      return r10.value === void 0 && (this.default !== void 0 && (r10.value = U2(this, r10, t11)), r10.value === void 0) ? (r10.typed = true, r10) : this.wrapped["~run"](r10, t11);
    }
  };
}
function V2(e14, n16, r10) {
  return {
    kind: "schema",
    type: "record",
    reference: V2,
    expects: "Object",
    async: false,
    key: e14,
    value: n16,
    message: r10,
    get "~standard"() {
      return h2(this);
    },
    "~run"(t11, s5) {
      var i4, l3;
      const u2 = t11.value;
      if (u2 && typeof u2 == "object") {
        t11.typed = true, t11.value = {};
        for (const o13 in u2)
          if (W2(u2, o13)) {
            const y2 = u2[o13], p5 = this.key["~run"]({ value: o13 }, s5);
            if (p5.issues) {
              const S2 = {
                type: "object",
                origin: "key",
                input: u2,
                key: o13,
                value: y2
              };
              for (const g2 of p5.issues)
                g2.path = [S2], (i4 = t11.issues) == null || i4.push(g2);
              if (t11.issues || (t11.issues = p5.issues), s5.abortEarly) {
                t11.typed = false;
                break;
              }
            }
            const m2 = this.value["~run"](
              { value: y2 },
              s5
            );
            if (m2.issues) {
              const S2 = {
                type: "object",
                origin: "value",
                input: u2,
                key: o13,
                value: y2
              };
              for (const g2 of m2.issues)
                g2.path ? g2.path.unshift(S2) : g2.path = [S2], (l3 = t11.issues) == null || l3.push(g2);
              if (t11.issues || (t11.issues = m2.issues), s5.abortEarly) {
                t11.typed = false;
                break;
              }
            }
            (!p5.typed || !m2.typed) && (t11.typed = false), p5.typed && (t11.value[p5.value] = m2.value);
          }
      } else
        f2(this, "type", t11, s5);
      return t11;
    }
  };
}
function a6(e14) {
  return {
    kind: "schema",
    type: "string",
    reference: a6,
    expects: "string",
    async: false,
    message: e14,
    get "~standard"() {
      return h2(this);
    },
    "~run"(n16, r10) {
      return typeof n16.value == "string" ? n16.typed = true : f2(this, "type", n16, r10), n16;
    }
  };
}
function O3(e14) {
  let n16;
  if (e14)
    for (const r10 of e14)
      n16 ? n16.push(...r10.issues) : n16 = r10.issues;
  return n16;
}
function $2(e14, n16) {
  return {
    kind: "schema",
    type: "union",
    reference: $2,
    expects: te(
      e14.map((r10) => r10.expects),
      "|"
    ),
    async: false,
    options: e14,
    message: n16,
    get "~standard"() {
      return h2(this);
    },
    "~run"(r10, t11) {
      let s5, u2, i4;
      for (const l3 of this.options) {
        const o13 = l3["~run"]({ value: r10.value }, t11);
        if (o13.typed)
          if (o13.issues)
            u2 ? u2.push(o13) : u2 = [o13];
          else {
            s5 = o13;
            break;
          }
        else
          i4 ? i4.push(o13) : i4 = [o13];
      }
      if (s5)
        return s5;
      if (u2) {
        if (u2.length === 1)
          return u2[0];
        f2(this, "type", r10, t11, {
          issues: O3(u2)
        }), r10.typed = true;
      } else {
        if ((i4 == null ? void 0 : i4.length) === 1)
          return i4[0];
        f2(this, "type", r10, t11, {
          issues: O3(i4)
        });
      }
      return r10;
    }
  };
}
function q2() {
  return {
    kind: "schema",
    type: "unknown",
    reference: q2,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return h2(this);
    },
    "~run"(e14) {
      return e14.typed = true, e14;
    }
  };
}
function B3(e14, n16, r10) {
  const t11 = e14["~run"]({ value: n16 }, N2(r10));
  if (t11.issues)
    throw new se(t11.issues);
  return t11.value;
}
function v(...e14) {
  return {
    ...e14[0],
    pipe: e14,
    get "~standard"() {
      return h2(this);
    },
    "~run"(n16, r10) {
      for (const t11 of e14)
        if (t11.kind !== "metadata") {
          if (n16.issues && (t11.kind === "schema" || t11.kind === "transformation")) {
            n16.typed = false;
            break;
          }
          (!n16.issues || !r10.abortEarly && !r10.abortPipeEarly) && (n16 = t11["~run"](n16, r10));
        }
      return n16;
    }
  };
}
function ue(e14) {
  return e14.replace(/_[a-z]/g, (n16) => n16[1].toUpperCase());
}
function ae(e14) {
  return Object.entries(e14).reduce((n16, [r10, t11]) => (n16[ue(r10)] = t11, n16), {});
}
function w(e14) {
  const n16 = ae(e14);
  for (const r10 in n16) {
    const t11 = n16[r10];
    t11 && typeof t11 == "object" && !(t11 instanceof Date) && (n16[r10] = Array.isArray(t11) ? t11.map(w) : w(t11));
  }
  return n16;
}
function I(e14) {
  return d7((n16) => e14 ? w(n16) : n16);
}
function M2(e14) {
  return (n16) => v(
    e14,
    I(n16)
  );
}
function T4(e14) {
  return (n16, r10) => B3(
    v(e14, I(r10)),
    n16
  );
}
function oe() {
  return d7(JSON.parse);
}
function C(e14) {
  const n16 = M2(e14);
  return (r10) => v(
    a6(),
    oe(),
    n16(r10)
  );
}
function ce(e14) {
  return d7((n16) => {
    const r10 = {};
    return new URLSearchParams(n16).forEach((t11, s5) => {
      const u2 = r10[s5];
      Array.isArray(u2) ? u2.push(t11) : u2 === void 0 ? r10[s5] = t11 : r10[s5] = [u2, t11];
    }), B3(e14, r10);
  });
}
function K(e14) {
  return (n16) => v(
    $2([a6(), J(URLSearchParams)]),
    ce(e14),
    I(n16)
  );
}
var Q = c(A4(() => he()));
var le = k3({
  id: E2(),
  photo_url: c(a6()),
  type: a6(),
  title: a6(),
  username: c(a6())
});
var pe2 = k3({
  added_to_attachment_menu: c(_()),
  allows_write_to_pm: c(_()),
  first_name: a6(),
  id: E2(),
  is_bot: c(_()),
  is_premium: c(_()),
  last_name: c(a6()),
  language_code: c(a6()),
  photo_url: c(a6()),
  username: c(a6())
});
var fe = k3({
  auth_date: v(
    a6(),
    d7((e14) => new Date(Number(e14) * 1e3)),
    z3()
  ),
  can_send_after: c(v(a6(), d7(Number), R())),
  chat: c(A4(() => ye())),
  chat_type: c(a6()),
  chat_instance: c(a6()),
  hash: a6(),
  query_id: c(a6()),
  receiver: Q,
  start_param: c(a6()),
  signature: a6(),
  user: Q
});
var ye = C(le);
var he = C(pe2);
var F = K(fe);
function H2(e14) {
  return /^#[\da-f]{6}$/i.test(e14);
}
var be = M2(
  V2(
    a6(),
    v(
      $2([a6(), E2()]),
      d7((e14) => typeof e14 == "number" ? `#${(e14 & 16777215).toString(16).padStart(6, "0")}` : e14),
      L(H2)
    )
  )
);
var x = c(
  v(a6(), d7((e14) => e14 === "1"))
);
var G2 = C(be());
var de = k3({
  tgWebAppBotInline: x,
  tgWebAppData: c(F()),
  tgWebAppDefaultColors: c(G2()),
  tgWebAppFullscreen: x,
  tgWebAppPlatform: a6(),
  tgWebAppShowSettings: x,
  tgWebAppStartParam: c(a6()),
  tgWebAppThemeParams: G2(),
  tgWebAppVersion: a6()
});
var X = K(de);
var ke = T4(F());
var _e2 = T4(X());
var Se2 = k3({
  eventType: a6(),
  eventData: c(q2())
});

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n16) {
  return { all: n16 = n16 || /* @__PURE__ */ new Map(), on: function(t11, e14) {
    var i4 = n16.get(t11);
    i4 ? i4.push(e14) : n16.set(t11, [e14]);
  }, off: function(t11, e14) {
    var i4 = n16.get(t11);
    i4 && (e14 ? i4.splice(i4.indexOf(e14) >>> 0, 1) : n16.set(t11, []));
  }, emit: function(t11, e14) {
    var i4 = n16.get(t11);
    i4 && i4.slice().map(function(n17) {
      n17(e14);
    }), (i4 = n16.get("*")) && i4.slice().map(function(n17) {
      n17(t11, e14);
    });
  } };
}

// node_modules/@telegram-apps/signals/dist/index.js
var r9;
function y(e14, c3) {
  r9 && r9.set(e14, c3) || c3();
}
function S(e14, c3) {
  c3 || (c3 = {});
  const g2 = c3.equals || Object.is;
  let u2 = [], s5 = e14;
  const i4 = (t11) => {
    if (!g2(s5, t11)) {
      const l3 = s5;
      s5 = t11, y(o13, () => {
        [...u2].forEach(([f7, d8]) => {
          f7(t11, l3), d8 && n16(f7, true);
        });
      });
    }
  };
  function a8(t11) {
    const l3 = typeof t11 != "object" ? { once: t11 } : t11;
    return {
      once: l3.once || false,
      signal: l3.signal || false
    };
  }
  const n16 = (t11, l3) => {
    const f7 = a8(l3), d8 = u2.findIndex(([h4, p5]) => h4 === t11 && p5.once === f7.once && p5.signal === f7.signal);
    d8 >= 0 && u2.splice(d8, 1);
  }, o13 = Object.assign(
    function() {
      return j2(o13), s5;
    },
    {
      destroy() {
        u2 = [];
      },
      set: i4,
      reset() {
        i4(e14);
      },
      sub(t11, l3) {
        return u2.push([t11, a8(l3)]), () => n16(t11, l3);
      },
      unsub: n16,
      unsubAll() {
        u2 = u2.filter((t11) => t11[1].signal);
      }
    }
  );
  return o13;
}
var b2 = [];
function j2(e14) {
  b2.length && b2[b2.length - 1].add(e14);
}

// node_modules/error-kid/dist/index.js
var f3 = Object.defineProperty;
var u = (r10, t11, e14) => t11 in r10 ? f3(r10, t11, { enumerable: true, configurable: true, writable: true, value: e14 }) : r10[t11] = e14;
var c2 = (r10, t11, e14) => u(r10, typeof t11 != "symbol" ? t11 + "" : t11, e14);
function a7(r10, t11) {
  return (e14) => e14 instanceof r10 && e14.type === t11;
}
function p4(r10, t11) {
  t11 || (t11 = []);
  const e14 = Symbol(r10);
  class n16 extends Error {
    constructor(...i4) {
      const o13 = typeof t11 == "function" ? t11(...i4) : typeof t11 == "string" ? [t11] : t11 || [];
      super(...o13);
      c2(this, "type", e14);
      this.name = r10;
    }
  }
  return Object.defineProperty(n16, "name", { value: r10 }), [n16, a7(n16, e14)];
}
function l2(r10, t11, e14) {
  const n16 = Symbol(r10);
  class s5 extends p4(r10, e14)[0] {
    constructor(...o13) {
      super(...o13);
      c2(this, "data");
      c2(this, "type", n16);
      this.data = t11(...o13);
    }
  }
  return Object.defineProperty(s5, "name", { value: r10 }), [s5, a7(s5, n16)];
}

// node_modules/@telegram-apps/bridge/dist/index.js
function H3(e14) {
  return is(
    looseObject({ TelegramWebviewProxy: looseObject({ postEvent: function_() }) }),
    e14
  );
}
function K2() {
  try {
    return window.self !== window.top;
  } catch {
    return true;
  }
}
function le2(e14, t11) {
  const r10 = /* @__PURE__ */ new Map(), n16 = mitt_default(), a8 = (o13, s5, c3) => {
    c3 || (c3 = false);
    const i4 = r10.get(o13) || /* @__PURE__ */ new Map();
    r10.set(o13, i4);
    const _2 = i4.get(s5) || [];
    i4.set(s5, _2);
    const l3 = _2.findIndex((w3) => w3[1] === c3);
    if (l3 >= 0 && (n16.off(o13, _2[l3][0]), _2.splice(l3, 1), !_2.length && (i4.delete(s5), !i4.size))) {
      const w3 = r10.size;
      r10.delete(o13), w3 && !r10.size && t11();
    }
  };
  return [
    function(s5, c3, i4) {
      !r10.size && e14();
      const _2 = () => {
        a8(s5, c3, i4);
      }, l3 = (...M3) => {
        i4 && _2(), s5 === "*" ? c3(M3) : c3(...M3);
      };
      n16.on(s5, l3);
      const w3 = r10.get(s5) || /* @__PURE__ */ new Map();
      r10.set(s5, w3);
      const T6 = w3.get(c3) || [];
      return w3.set(c3, T6), T6.push([l3, i4 || false]), _2;
    },
    a8,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    n16.emit,
    function() {
      const s5 = r10.size;
      n16.all.clear(), r10.clear(), s5 && t11();
    }
  ];
}
function v2(e14, t11) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e14, eventData: t11 }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
var h3 = false;
var f5 = S(O2("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog() {
    return h3;
  }
}));
function Y(e14, t11, r10, n16) {
  Object.defineProperty(e14, t11, {
    enumerable: true,
    configurable: true,
    get: r10,
    set: n16
  });
}
function W3(e14, t11) {
  const r10 = e14[t11];
  Y(e14, t11, () => r10, (n16) => {
    Object.entries(n16).forEach(([a8, o13]) => {
      r10[a8] = o13;
    });
  });
}
function U3(e14, t11, r10) {
  Object.defineProperty(e14, t11, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: r10
  });
}
function E3(e14, t11, r10) {
  const n16 = e14[t11], a8 = [r10];
  typeof n16 == "function" && a8.push(n16);
  const o13 = (...c3) => {
    a8.forEach((i4) => {
      i4(...c3);
    });
  }, s5 = Object.assign((...c3) => {
    o13(...c3);
  }, {
    // Unwraps the composer.
    unwrap() {
      const { length: c3 } = a8;
      if (c3 === 1) {
        delete e14[t11];
        return;
      }
      if (c3 === 2) {
        U3(e14, t11, a8[1]);
        return;
      }
      a8.unshift(1), U3(e14, t11, o13);
    }
  });
  Y(
    e14,
    t11,
    () => s5,
    (c3) => {
      a8.push(c3);
    }
  );
}
var we = {
  clipboard_text_received: looseObject({
    req_id: string(),
    data: nullish(string())
  }),
  custom_method_invoked: looseObject({
    req_id: string(),
    result: optional(unknown()),
    error: optional(string())
  }),
  popup_closed: nullish(
    looseObject({ button_id: nullish(string(), () => {
    }) }),
    {}
  ),
  viewport_changed: looseObject({
    height: number(),
    width: nullish(number(), () => window.innerWidth),
    is_state_stable: boolean(),
    is_expanded: boolean()
  }),
  theme_changed: looseObject({
    theme_params: be()
  })
};
function I2(e14) {
  if (e14.source !== window.parent)
    return;
  let t11;
  try {
    t11 = parse(pipe(string(), oe(), Se2), e14.data);
  } catch {
    return;
  }
  const { eventType: r10, eventData: n16 } = t11, a8 = we[r10];
  let o13;
  try {
    o13 = a8 ? parse(a8, n16) : n16;
  } catch (s5) {
    return f5().forceError(
      [
        `An error occurred processing the "${r10}" event from the Telegram application.`,
        "Please, file an issue here:",
        "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
      ].join(`
`),
      t11,
      s5
    );
  }
  ge(r10, o13);
}
var [
  X2,
  me,
  ge,
  be2
] = le2(
  () => {
    const e14 = window;
    !e14.TelegramGameProxy && (e14.TelegramGameProxy = {}), E3(e14.TelegramGameProxy, "receiveEvent", v2), W3(e14, "TelegramGameProxy"), !e14.Telegram && (e14.Telegram = {}), !e14.Telegram.WebView && (e14.Telegram.WebView = {}), E3(e14.Telegram.WebView, "receiveEvent", v2), W3(e14.Telegram, "WebView"), E3(e14, "TelegramGameProxy_receiveEvent", v2), window.addEventListener("message", I2);
  },
  () => {
    [
      ["TelegramGameProxy_receiveEvent"],
      ["TelegramGameProxy", "receiveEvent"],
      ["Telegram", "WebView", "receiveEvent"]
    ].forEach((e14) => {
      const t11 = window;
      let r10 = [void 0, t11];
      for (const o13 of e14)
        if (r10 = [r10[1], r10[1][o13]], !r10[1])
          return;
      const [n16, a8] = r10;
      "unwrap" in a8 && (a8.unwrap(), n16 && n16 !== t11 && !Object.keys(n16).length && delete t11[e14[0]]);
    }), window.removeEventListener("message", I2);
  }
);
var [
  de2,
  Ie
] = p4(
  "MethodUnsupportedError",
  (e14, t11) => [
    `Method "${e14}" is unsupported in Mini Apps version ${t11}`
  ]
);
var [
  he2,
  Re
] = p4(
  "MethodParameterUnsupportedError",
  (e14, t11, r10) => [
    `Parameter "${t11}" of "${e14}" method is unsupported in Mini Apps version ${r10}`
  ]
);
var [
  ye2,
  je
] = l2(
  "LaunchParamsRetrieveError",
  (e14) => ({ errors: e14 }),
  (e14) => [
    [
      "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
      " Refer to docs for more information:",
      "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment",
      "",
      "Collected errors:",
      ...e14.map(([t11, r10]) => `Source: ${t11} / ${r10 instanceof Error ? r10.message : String(r10)}`)
    ].join(`
`)
  ]
);
var [
  ve,
  $e
] = p4(
  "InvalidLaunchParamsError",
  (e14, t11) => [
    `Invalid value for launch params: ${e14}`,
    { cause: t11 }
  ]
);
var [Ee2, ze] = p4("UnknownEnvError");
var [
  Pe,
  Ne
] = p4(
  "InvokeCustomMethodError",
  (e14) => [`Server returned error: ${e14}`]
);
var g = S((...e14) => {
  try {
    window.parent.postMessage(...e14);
  } catch (t11) {
    t11 instanceof SyntaxError ? f5().forceError(
      "Unable to call window.parent.postMessage due to incorrectly configured target origin. Use the setTargetOrigin method to allow this origin to receive events",
      t11
    ) : f5().forceError(t11);
  }
});
var ke2 = (...e14) => g()(...e14);
var x2 = S("https://web.telegram.org");
function Z2(e14, t11) {
  f5().log("Posting event:", t11 ? { eventType: e14, eventData: t11 } : { eventType: e14 });
  const r10 = window, n16 = JSON.stringify({ eventType: e14, eventData: t11 });
  if (K2())
    return ke2(n16, x2());
  if (H3(r10)) {
    r10.TelegramWebviewProxy.postEvent(e14, JSON.stringify(t11));
    return;
  }
  if (is(looseObject({ external: looseObject({ notify: function_() }) }), r10)) {
    r10.external.notify(n16);
    return;
  }
  throw new Ee2();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  const arr = new Uint8Array(16);
  arr[0] = (v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v6 >>> 16 & 255;
  arr[2] = v6 >>> 8 & 255;
  arr[3] = v6 & 255;
  arr[4] = (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v6 & 255;
  arr[6] = (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v6 & 255;
  arr[8] = (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v6 & 255;
  arr[10] = (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v6 / 4294967296 & 255;
  arr[12] = v6 >>> 24 & 255;
  arr[13] = v6 >>> 16 & 255;
  arr[14] = v6 >>> 8 & 255;
  arr[15] = v6 & 255;
  return arr;
}
var parse_default = parse2;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i4 = 0; i4 < str.length; ++i4) {
    bytes.push(str.charCodeAt(i4));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i4 = 0; i4 < 16; ++i4) {
        buf[offset + i4] = bytes[i4];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes[i4] = msg.charCodeAt(i4);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i4 = 0; i4 < length32; i4 += 8) {
    const x3 = input[i4 >> 5] >>> i4 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x3 >>> 4 & 15) + hexTab.charAt(x3 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x3, len) {
  x3[len >> 5] |= 128 << len % 32;
  x3[getOutputLength(len) - 1] = len;
  let a8 = 1732584193;
  let b3 = -271733879;
  let c3 = -1732584194;
  let d8 = 271733878;
  for (let i4 = 0; i4 < x3.length; i4 += 16) {
    const olda = a8;
    const oldb = b3;
    const oldc = c3;
    const oldd = d8;
    a8 = md5ff(a8, b3, c3, d8, x3[i4], 7, -680876936);
    d8 = md5ff(d8, a8, b3, c3, x3[i4 + 1], 12, -389564586);
    c3 = md5ff(c3, d8, a8, b3, x3[i4 + 2], 17, 606105819);
    b3 = md5ff(b3, c3, d8, a8, x3[i4 + 3], 22, -1044525330);
    a8 = md5ff(a8, b3, c3, d8, x3[i4 + 4], 7, -176418897);
    d8 = md5ff(d8, a8, b3, c3, x3[i4 + 5], 12, 1200080426);
    c3 = md5ff(c3, d8, a8, b3, x3[i4 + 6], 17, -1473231341);
    b3 = md5ff(b3, c3, d8, a8, x3[i4 + 7], 22, -45705983);
    a8 = md5ff(a8, b3, c3, d8, x3[i4 + 8], 7, 1770035416);
    d8 = md5ff(d8, a8, b3, c3, x3[i4 + 9], 12, -1958414417);
    c3 = md5ff(c3, d8, a8, b3, x3[i4 + 10], 17, -42063);
    b3 = md5ff(b3, c3, d8, a8, x3[i4 + 11], 22, -1990404162);
    a8 = md5ff(a8, b3, c3, d8, x3[i4 + 12], 7, 1804603682);
    d8 = md5ff(d8, a8, b3, c3, x3[i4 + 13], 12, -40341101);
    c3 = md5ff(c3, d8, a8, b3, x3[i4 + 14], 17, -1502002290);
    b3 = md5ff(b3, c3, d8, a8, x3[i4 + 15], 22, 1236535329);
    a8 = md5gg(a8, b3, c3, d8, x3[i4 + 1], 5, -165796510);
    d8 = md5gg(d8, a8, b3, c3, x3[i4 + 6], 9, -1069501632);
    c3 = md5gg(c3, d8, a8, b3, x3[i4 + 11], 14, 643717713);
    b3 = md5gg(b3, c3, d8, a8, x3[i4], 20, -373897302);
    a8 = md5gg(a8, b3, c3, d8, x3[i4 + 5], 5, -701558691);
    d8 = md5gg(d8, a8, b3, c3, x3[i4 + 10], 9, 38016083);
    c3 = md5gg(c3, d8, a8, b3, x3[i4 + 15], 14, -660478335);
    b3 = md5gg(b3, c3, d8, a8, x3[i4 + 4], 20, -405537848);
    a8 = md5gg(a8, b3, c3, d8, x3[i4 + 9], 5, 568446438);
    d8 = md5gg(d8, a8, b3, c3, x3[i4 + 14], 9, -1019803690);
    c3 = md5gg(c3, d8, a8, b3, x3[i4 + 3], 14, -187363961);
    b3 = md5gg(b3, c3, d8, a8, x3[i4 + 8], 20, 1163531501);
    a8 = md5gg(a8, b3, c3, d8, x3[i4 + 13], 5, -1444681467);
    d8 = md5gg(d8, a8, b3, c3, x3[i4 + 2], 9, -51403784);
    c3 = md5gg(c3, d8, a8, b3, x3[i4 + 7], 14, 1735328473);
    b3 = md5gg(b3, c3, d8, a8, x3[i4 + 12], 20, -1926607734);
    a8 = md5hh(a8, b3, c3, d8, x3[i4 + 5], 4, -378558);
    d8 = md5hh(d8, a8, b3, c3, x3[i4 + 8], 11, -2022574463);
    c3 = md5hh(c3, d8, a8, b3, x3[i4 + 11], 16, 1839030562);
    b3 = md5hh(b3, c3, d8, a8, x3[i4 + 14], 23, -35309556);
    a8 = md5hh(a8, b3, c3, d8, x3[i4 + 1], 4, -1530992060);
    d8 = md5hh(d8, a8, b3, c3, x3[i4 + 4], 11, 1272893353);
    c3 = md5hh(c3, d8, a8, b3, x3[i4 + 7], 16, -155497632);
    b3 = md5hh(b3, c3, d8, a8, x3[i4 + 10], 23, -1094730640);
    a8 = md5hh(a8, b3, c3, d8, x3[i4 + 13], 4, 681279174);
    d8 = md5hh(d8, a8, b3, c3, x3[i4], 11, -358537222);
    c3 = md5hh(c3, d8, a8, b3, x3[i4 + 3], 16, -722521979);
    b3 = md5hh(b3, c3, d8, a8, x3[i4 + 6], 23, 76029189);
    a8 = md5hh(a8, b3, c3, d8, x3[i4 + 9], 4, -640364487);
    d8 = md5hh(d8, a8, b3, c3, x3[i4 + 12], 11, -421815835);
    c3 = md5hh(c3, d8, a8, b3, x3[i4 + 15], 16, 530742520);
    b3 = md5hh(b3, c3, d8, a8, x3[i4 + 2], 23, -995338651);
    a8 = md5ii(a8, b3, c3, d8, x3[i4], 6, -198630844);
    d8 = md5ii(d8, a8, b3, c3, x3[i4 + 7], 10, 1126891415);
    c3 = md5ii(c3, d8, a8, b3, x3[i4 + 14], 15, -1416354905);
    b3 = md5ii(b3, c3, d8, a8, x3[i4 + 5], 21, -57434055);
    a8 = md5ii(a8, b3, c3, d8, x3[i4 + 12], 6, 1700485571);
    d8 = md5ii(d8, a8, b3, c3, x3[i4 + 3], 10, -1894986606);
    c3 = md5ii(c3, d8, a8, b3, x3[i4 + 10], 15, -1051523);
    b3 = md5ii(b3, c3, d8, a8, x3[i4 + 1], 21, -2054922799);
    a8 = md5ii(a8, b3, c3, d8, x3[i4 + 8], 6, 1873313359);
    d8 = md5ii(d8, a8, b3, c3, x3[i4 + 15], 10, -30611744);
    c3 = md5ii(c3, d8, a8, b3, x3[i4 + 6], 15, -1560198380);
    b3 = md5ii(b3, c3, d8, a8, x3[i4 + 13], 21, 1309151649);
    a8 = md5ii(a8, b3, c3, d8, x3[i4 + 4], 6, -145523070);
    d8 = md5ii(d8, a8, b3, c3, x3[i4 + 11], 10, -1120210379);
    c3 = md5ii(c3, d8, a8, b3, x3[i4 + 2], 15, 718787259);
    b3 = md5ii(b3, c3, d8, a8, x3[i4 + 9], 21, -343485551);
    a8 = safeAdd(a8, olda);
    b3 = safeAdd(b3, oldb);
    c3 = safeAdd(c3, oldc);
    d8 = safeAdd(d8, oldd);
  }
  return [a8, b3, c3, d8];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i4 = 0; i4 < length8; i4 += 8) {
    output[i4 >> 5] |= (input[i4 / 8] & 255) << i4 % 32;
  }
  return output;
}
function safeAdd(x3, y2) {
  const lsw = (x3 & 65535) + (y2 & 65535);
  const msw = (x3 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q3, a8, b3, x3, s5, t11) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a8, q3), safeAdd(x3, t11)), s5), b3);
}
function md5ff(a8, b3, c3, d8, x3, s5, t11) {
  return md5cmn(b3 & c3 | ~b3 & d8, a8, b3, x3, s5, t11);
}
function md5gg(a8, b3, c3, d8, x3, s5, t11) {
  return md5cmn(b3 & d8 | c3 & ~d8, a8, b3, x3, s5, t11);
}
function md5hh(a8, b3, c3, d8, x3, s5, t11) {
  return md5cmn(b3 ^ c3 ^ d8, a8, b3, x3, s5, t11);
}
function md5ii(a8, b3, c3, d8, x3, s5, t11) {
  return md5cmn(c3 ^ (b3 | ~d8), a8, b3, x3, s5, t11);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset + i4] = rnds[i4];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f6(s5, x3, y2, z4) {
  switch (s5) {
    case 0:
      return x3 & y2 ^ ~x3 & z4;
    case 1:
      return x3 ^ y2 ^ z4;
    case 2:
      return x3 & y2 ^ x3 & z4 ^ y2 & z4;
    case 3:
      return x3 ^ y2 ^ z4;
  }
}
function ROTL(x3, n16) {
  return x3 << n16 | x3 >>> 32 - n16;
}
function sha1(bytes) {
  const K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes.push(msg.charCodeAt(i4));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l3 = bytes.length / 4 + 2;
  const N3 = Math.ceil(l3 / 16);
  const M3 = new Array(N3);
  for (let i4 = 0; i4 < N3; ++i4) {
    const arr = new Uint32Array(16);
    for (let j3 = 0; j3 < 16; ++j3) {
      arr[j3] = bytes[i4 * 64 + j3 * 4] << 24 | bytes[i4 * 64 + j3 * 4 + 1] << 16 | bytes[i4 * 64 + j3 * 4 + 2] << 8 | bytes[i4 * 64 + j3 * 4 + 3];
    }
    M3[i4] = arr;
  }
  M3[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M3[N3 - 1][14] = Math.floor(M3[N3 - 1][14]);
  M3[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i4 = 0; i4 < N3; ++i4) {
    const W4 = new Uint32Array(80);
    for (let t11 = 0; t11 < 16; ++t11) {
      W4[t11] = M3[i4][t11];
    }
    for (let t11 = 16; t11 < 80; ++t11) {
      W4[t11] = ROTL(W4[t11 - 3] ^ W4[t11 - 8] ^ W4[t11 - 14] ^ W4[t11 - 16], 1);
    }
    let a8 = H4[0];
    let b3 = H4[1];
    let c3 = H4[2];
    let d8 = H4[3];
    let e14 = H4[4];
    for (let t11 = 0; t11 < 80; ++t11) {
      const s5 = Math.floor(t11 / 20);
      const T6 = ROTL(a8, 5) + f6(s5, b3, c3, d8) + e14 + K3[s5] + W4[t11] >>> 0;
      e14 = d8;
      d8 = c3;
      c3 = ROTL(b3, 30) >>> 0;
      b3 = a8;
      a8 = T6;
    }
    H4[0] = H4[0] + a8 >>> 0;
    H4[1] = H4[1] + b3 >>> 0;
    H4[2] = H4[2] + c3 >>> 0;
    H4[3] = H4[3] + d8 >>> 0;
    H4[4] = H4[4] + e14 >>> 0;
  }
  return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@aptos-connect/web-transport/dist/index.mjs
var DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };
var PROMPT_POLLER_INTERVAL = 500;
var dismissalSerializedResponse = ConnectResponse.serialize({
  status: "dismissed"
});
var PromptUnauthorizedError = class extends Error {
  constructor() {
    super("Unauthorized");
  }
};
function openPrompt(url, size = DEFAULT_PROMPT_SIZE) {
  const { height, width } = size;
  const options = {
    height,
    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),
    popup: true,
    top: window.screenTop + Math.round((window.outerHeight - height) / 2),
    width
  };
  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);
  const href = url instanceof URL ? url.href : url;
  const promptWindow = window.open(href, void 0, strOptions);
  if (promptWindow === null) {
    throw new Error("Couldn't open prompt");
  }
  return promptWindow;
}
async function waitForPromptResponse(baseUrl, promptWindow, request) {
  return new Promise((resolve, reject) => {
    const listeners = {
      onMessage: (message) => {
        if (message.source !== promptWindow || message.origin !== baseUrl) {
          return;
        }
        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          reject(new PromptUnauthorizedError());
          return;
        }
        if (isTypedMessage(PromptConnectionRequestMessage, message.data)) {
          promptWindow.postMessage(
            new PromptConnectionResponseMessage(request),
            baseUrl
          );
          return;
        }
        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(message.data.serializedValue);
        }
      },
      promptPollerId: setInterval(() => {
        if (promptWindow.closed) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(dismissalSerializedResponse);
        }
      }, PROMPT_POLLER_INTERVAL)
    };
    window.addEventListener("message", listeners.onMessage);
  });
}
var localDappStateKey = "@aptos-connect/dapp-local-state";
function serializeLocalDappState(state) {
  const serializer = new n();
  serializer.serializeU32AsUleb128(state.connectedAccounts.length);
  for (const account of state.connectedAccounts) {
    serializeAccountInfo(serializer, account);
  }
  return serializer.toUint8Array();
}
function deserializeLocalDappState(serializedValue) {
  const deserializer = new a2(serializedValue);
  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();
  const connectedAccounts = [];
  for (let i4 = 0; i4 < connectedAccountsLength; i4 += 1) {
    connectedAccounts.push(deserializeAccountInfo(deserializer));
  }
  return { connectedAccounts };
}
function getState() {
  const encodedValue = window.localStorage.getItem(localDappStateKey);
  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : { connectedAccounts: [] };
}
function setState(state) {
  const serializedValue = serializeLocalDappState(state);
  const encodedValue = bytesToBase64(serializedValue);
  window.localStorage.setItem(localDappStateKey, encodedValue);
}
function getConnectedAccounts() {
  const state = getState();
  return state.connectedAccounts;
}
function addConnectedAccount(account) {
  const { connectedAccounts, ...state } = getState();
  connectedAccounts.push(account);
  setState({ ...state, connectedAccounts });
}
function removeConnectedAccount(address) {
  const { connectedAccounts, ...state } = getState();
  const index = connectedAccounts.findIndex((a8) => a8.address.equals(address));
  if (index >= 0) {
    connectedAccounts.splice(index, 1);
  }
  setState({ ...state, connectedAccounts });
}
async function createWalletRequest(baseUrl, request) {
  const encodedClientIdentityKey = bytesToBase64url(
    request.clientIdentityKey.toUint8Array()
  );
  const response = await fetch(
    `${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/`,
    {
      body: JSON.stringify({
        body: encodeWalletRequestBody(request.body),
        id: request.id,
        signature: bytesToBase64(request.signature.toUint8Array()),
        timestamp: request.timestamp
      }),
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      method: "post"
    }
  );
  if (!response.ok) {
    throw new Error("Failed creating the wallet request");
  }
}
var identityKeyStorageKey = "@aptos-connect/client-identity-key";
function getClientIdentityKey() {
  const serialized = window.localStorage.getItem(identityKeyStorageKey);
  if (serialized) {
    return new z(serialized);
  }
  const identityKey = z.generate();
  window.localStorage.setItem(identityKeyStorageKey, identityKey.toString());
  return identityKey;
}
var ON_RESUME_DELAY = 300;
var FG_RESPONSE_POLLING_INTERVAL = 2e3;
var BG_RESPONSE_POLLING_INTERVAL = 3e3;
var POLLING_TIMEOUT = 5 * 6e4;
function waitFor(milliseconds) {
  let timeoutId;
  let cancel = () => {
  };
  const timer = new Promise((resolve) => {
    timeoutId = setTimeout(resolve, milliseconds);
    cancel = () => {
      clearTimeout(timeoutId);
      resolve();
    };
  });
  timer.cancel = cancel;
  return timer;
}
async function smartPolling(callback) {
  let timer;
  let justResumed = false;
  let pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  const onWindowFocus = () => {
    justResumed = true;
    pollingInterval = FG_RESPONSE_POLLING_INTERVAL;
    timer == null ? void 0 : timer.cancel();
  };
  const onWindowBlur = () => {
    pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  };
  window.addEventListener("focus", onWindowFocus);
  window.addEventListener("blur", onWindowBlur);
  try {
    const startTime = Date.now();
    while (Date.now() - startTime < POLLING_TIMEOUT) {
      timer = waitFor(pollingInterval);
      await timer;
      if (justResumed) {
        timer = waitFor(ON_RESUME_DELAY);
        await timer;
      }
      const response = await callback();
      if (response.status === 200) {
        return response;
      }
      justResumed = false;
    }
    throw new Error("Timeout");
  } finally {
    window.removeEventListener("focus", onWindowFocus);
    window.removeEventListener("blur", onWindowFocus);
  }
}
async function getWalletResponse(baseUrl, clientIdentityKey, requestId) {
  const encodedClientIdentityKey = bytesToBase64url(
    clientIdentityKey.toUint8Array()
  );
  const url = new URL(
    `${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/${requestId}/response/`
  );
  const response = await smartPolling(
    () => fetch(url, {
      headers: { Accept: "application/json" },
      method: "get"
    })
  );
  const responseBody = await response.json();
  const data = base64ToBytes(responseBody.data.body);
  return { data };
}
async function openTelegramPrompt(args) {
  const {
    baseUrl,
    provider,
    request: body,
    tgWebAppUrl = "/AptosConnectBot/AptosConnect"
  } = args;
  const identityKey = getClientIdentityKey();
  const clientIdentityKey = identityKey.publicKey();
  const requestId = v4_default();
  const timestamp = Date.now();
  const challenge = makePopupWalletRequestChallenge({
    body,
    id: requestId,
    timestamp
  });
  const signature = identityKey.sign(challenge);
  const signedWalletRequest = {
    body,
    clientIdentityKey,
    id: requestId,
    signature,
    timestamp
  };
  let encodedRequest = encodePopupWalletRequest(signedWalletRequest);
  if (encodedRequest.length > 1024) {
    void createWalletRequest(baseUrl, signedWalletRequest);
    encodedRequest = encodePopupWalletRequest({
      clientIdentityKey,
      id: requestId,
      signature,
      timestamp
    });
  }
  const startParam = `prompt_${provider ?? ""}${encodedRequest}`;
  Z2("web_app_open_tg_link", {
    path_full: `${tgWebAppUrl}?startapp=${startParam}`
  });
  return getWalletResponse(baseUrl, clientIdentityKey, requestId);
}
function isTelegramMiniApp() {
  return window.TelegramWebviewProxy !== void 0;
}
var WebWalletTransport = class {
  constructor(baseUrl, provider = "google", tgWebAppUrl) {
    this.baseUrl = baseUrl;
    this.provider = provider;
    this.tgWebAppUrl = tgWebAppUrl;
    this.baseUrl = baseUrl;
  }
  async sendPromptRequest(request) {
    if (isTelegramMiniApp()) {
      return openTelegramPrompt({
        baseUrl: this.baseUrl,
        provider: this.provider,
        request,
        tgWebAppUrl: this.tgWebAppUrl
      });
    }
    const url = new URL(`${this.baseUrl}/prompt/`);
    url.searchParams.set("provider", this.provider);
    const prompt = openPrompt(url);
    return waitForPromptResponse(this.baseUrl, prompt, request);
  }
  async sendRequest(request) {
    switch (request.name) {
      case IsConnectedRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return IsConnectedResponse.serialize(connectedAccounts.length > 0);
      }
      case GetConnectedAccountsRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return GetConnectedAccountsResponse.serialize(connectedAccounts);
      }
      case ConnectRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request);
        const response = ConnectResponse.deserialize(serializedResponse);
        if (response.args.status === "approved") {
          const { account, pairing } = response.args.args;
          if (pairing === void 0) {
            addConnectedAccount(account);
          }
        }
        return serializedResponse;
      }
      case SignInRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request);
        const response = SignInResponse.deserialize(
          serializedResponse,
          request.version === 1 ? 1 : 2
        );
        if (response.args.status === "approved") {
          const { account } = response.args.args;
          addConnectedAccount(account);
        }
        return serializedResponse;
      }
      case DisconnectRequest.name: {
        const [activeAccount] = getConnectedAccounts();
        if (activeAccount) {
          removeConnectedAccount(activeAccount.address);
        }
        return DisconnectResponse.serialize({});
      }
      case SignMessageRequest.name:
      case SignTransactionRequest.name:
      case SignAndSubmitTransactionRequest.name: {
        return this.sendPromptRequest(request);
      }
      default: {
        throw new Error("Unexpected request");
      }
    }
  }
};

// node_modules/@identity-connect/api/dist/index.mjs
var AuthError = {
  missing_client: "missing_client",
  redirect_mismatch: "redirect_mismatch",
  state_mismatch: "state_mismatch"
};
var AuthErrorMessages = {
  [AuthError.state_mismatch]: {
    code: 0,
    description: "State mismatch",
    shortMessage: "An error occurred while logging in, please try again."
  },
  [AuthError.redirect_mismatch]: {
    code: 1,
    description: "Redirect mismatch",
    shortMessage: "An error occurred while logging in, please try again."
  },
  [AuthError.missing_client]: {
    code: 2,
    description: "Missing client",
    shortMessage: "An error occurred while logging in, please try again."
  }
};
var NetworkName = ((NetworkName22) => {
  NetworkName22["DEVNET"] = "devnet";
  NetworkName22["MAINNET"] = "mainnet";
  NetworkName22["TESTNET"] = "testnet";
  return NetworkName22;
})(NetworkName || {});
var PairingStatus = ((PairingStatus2) => {
  PairingStatus2["Finalized"] = "FINALIZED";
  PairingStatus2["Pending"] = "PENDING";
  return PairingStatus2;
})(PairingStatus || {});
var SigningRequestTypes = ((SigningRequestTypes2) => {
  SigningRequestTypes2["SIGN_AND_SUBMIT_TRANSACTION"] = "SIGN_AND_SUBMIT_TRANSACTION";
  SigningRequestTypes2["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  SigningRequestTypes2["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  return SigningRequestTypes2;
})(SigningRequestTypes || {});
var SigningRequestStatus = ((SigningRequestStatus2) => {
  SigningRequestStatus2["APPROVED"] = "APPROVED";
  SigningRequestStatus2["CANCELLED"] = "CANCELLED";
  SigningRequestStatus2["INVALID"] = "INVALID";
  SigningRequestStatus2["PENDING"] = "PENDING";
  SigningRequestStatus2["REJECTED"] = "REJECTED";
  return SigningRequestStatus2;
})(SigningRequestStatus || {});
var WalletOSEnum = ((WalletOSEnum2) => {
  WalletOSEnum2["Android"] = "android";
  WalletOSEnum2["IdentityConnect"] = "ic";
  WalletOSEnum2["Linux"] = "linux";
  WalletOSEnum2["Macos"] = "osx";
  WalletOSEnum2["Windows"] = "win";
  WalletOSEnum2["iOS"] = "ios";
  return WalletOSEnum2;
})(WalletOSEnum || {});
var WalletPlatformEnum = ((WalletPlatformEnum2) => {
  WalletPlatformEnum2["BraveExtension"] = "brave-extension";
  WalletPlatformEnum2["ChromeExtension"] = "chrome-extension";
  WalletPlatformEnum2["FirefoxExtension"] = "firefox-extension";
  WalletPlatformEnum2["IcDappWallet"] = "ic-dapp-wallet";
  WalletPlatformEnum2["KiwiExtension"] = "kiwi-extension";
  WalletPlatformEnum2["NativeApp"] = "native-app";
  WalletPlatformEnum2["OperaExtension"] = "opera-extension";
  WalletPlatformEnum2["SafariExtension"] = "safari-extension";
  return WalletPlatformEnum2;
})(WalletPlatformEnum || {});

// node_modules/@identity-connect/wallet-api/dist/index.mjs
function isBcsSerializable(value) {
  return (value == null ? void 0 : value.serialize) !== void 0 && (value == null ? void 0 : value.bcsToBytes) !== void 0 && (value == null ? void 0 : value.bcsToHex) !== void 0;
}
function bcsSerialize(serializable) {
  return serializable.bcsToHex().toString();
}
function bcsDeserialize(deserializableClass, serializedValue) {
  const serializedValueBytes = a.fromHexString(serializedValue).toUint8Array();
  const deserializer = new a2(serializedValueBytes);
  return deserializableClass.deserialize(deserializer);
}
var UnexpectedValueError = class _UnexpectedValueError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnexpectedValueError";
    Object.setPrototypeOf(this, _UnexpectedValueError.prototype);
  }
};
function serializeEntryFunctionArg(arg) {
  if (arg instanceof Uint8Array) {
    return {
      type: "Uint8Array",
      value: a.fromHexInput(arg).toString()
    };
  }
  if (Array.isArray(arg)) {
    return arg.map(serializeEntryFunctionArg);
  }
  return arg;
}
function serializeEntryFunctionPayload(payload) {
  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);
  return {
    ...payload,
    arguments: normalizedArgs,
    type: "entry_function_payload"
  };
}
function serializeJsonTransactionPayload(payload) {
  if (payload.type === "entry_function_payload" || payload.type === void 0) {
    return serializeEntryFunctionPayload(payload);
  }
  if (payload.type === "multisig_payload") {
    const innerPayload = payload.transaction_payload !== void 0 ? serializeEntryFunctionPayload(payload.transaction_payload) : void 0;
    return { ...payload, transaction_payload: innerPayload };
  }
  throw new UnexpectedValueError();
}
function serializeRawTransaction(rawTxn) {
  const value = bcsSerialize(rawTxn);
  if ("fee_payer_address" in rawTxn) {
    return { type: "fee_payer_raw_txn", value };
  }
  if ("secondary_signer_addresses" in rawTxn) {
    return { type: "multi_agent_raw_txn", value };
  }
  if ("chain_id" in rawTxn) {
    return { type: "raw_txn", value };
  }
  throw new UnexpectedValueError("Invalid raw transaction type");
}
function serializeSignAndSubmitTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("feePayerAuthenticator" in args) {
    return {
      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),
      rawTxn: serializeRawTransaction(args.rawTxn)
    };
  }
  if ("rawTxn" in args) {
    return { rawTxn: serializeRawTransaction(args.rawTxn) };
  }
  throw new UnexpectedValueError();
}
function serializeSignTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("rawTxn" in args) {
    const serializedRawTxn = serializeRawTransaction(args.rawTxn);
    return { rawTxn: serializedRawTxn };
  }
  throw new UnexpectedValueError();
}
function deserializeSignTransactionResponseArgs(args) {
  const accountAuthenticator = bcsDeserialize(
    V,
    args.accountAuthenticator
  );
  if ("rawTxn" in args) {
    const rawTxn = bcsDeserialize(pe, args.rawTxn);
    return { accountAuthenticator, rawTxn };
  }
  return { accountAuthenticator };
}

// node_modules/@identity-connect/dapp-sdk/dist/index.mjs
var DEFAULT_FRONTEND_URL = "https://web.petra.app";
function convertToSerializableArgument(argument) {
  if (argument === void 0 || argument === null) {
    return argument;
  }
  if (Array.isArray(argument)) {
    return argument.map(
      (subArgument) => convertToSerializableArgument(subArgument)
    );
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || argument instanceof Uint8Array) {
    return argument;
  }
  if (typeof argument === "bigint") {
    return argument.toString();
  }
  if (argument instanceof ArrayBuffer) {
    return new Uint8Array(argument);
  }
  if ("values" in argument) {
    return argument.values.map(
      (subArgument) => convertToSerializableArgument(subArgument)
    );
  }
  if ("data" in argument) {
    return l.from(argument.data).toString();
  }
  if (argument.value === void 0) {
    return void 0;
  }
  if (typeof argument.value === "string" || typeof argument.value === "number" || typeof argument.value === "boolean" || argument.value instanceof Uint8Array) {
    return argument.value;
  }
  if (typeof argument.value === "bigint") {
    return argument.value.toString();
  }
  throw new Error("Unexpected argument");
}
function normalizePayloadForIC(payload, aptosConfig) {
  if ("bcsToBytes" in payload) {
    return payload;
  }
  if ("bytecode" in payload) {
    return Wn(payload);
  }
  if (aptosConfig) {
    return payload.abi !== void 0 ? pa({ ...payload, abi: payload.abi }) : Wn({ aptosConfig, ...payload });
  }
  const entryFunctionPayload = {
    arguments: payload.functionArguments.map(convertToSerializableArgument),
    function: payload.function,
    type: "entry_function_payload",
    type_arguments: (payload.typeArguments ?? []).map((ta) => ta.toString())
  };
  return "multisigAddress" in payload ? {
    multisig_address: l.from(
      payload.multisigAddress
    ).toString(),
    transaction_payload: entryFunctionPayload,
    type: "multisig_payload"
  } : entryFunctionPayload;
}
var SignatureRequestError = class _SignatureRequestError extends Error {
  constructor(status) {
    super(status);
    this.name = "SignatureRequestError";
    Object.setPrototypeOf(this, _SignatureRequestError.prototype);
  }
};
var UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {
  constructor(missingFields) {
    const message = `Missing the following fields: ${missingFields.join(", ")}`;
    super(message);
    this.name = "UnexpectedSignatureResponseError";
    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);
  }
};
var PairingExpiredError = class _PairingExpiredError extends Error {
  constructor() {
    super();
    this.name = "PairingExpiredError";
    Object.setPrototypeOf(this, _PairingExpiredError.prototype);
  }
};
var DAPP_PAIRINGS_WINDOW_STORAGE_KEY = "icDappPairings";
var windowStateAccessors = {
  async get(address) {
    const pairings = await this.getAll();
    return pairings[address];
  },
  async getAll() {
    const serialized = window.localStorage.getItem(
      DAPP_PAIRINGS_WINDOW_STORAGE_KEY
    );
    return serialized ? JSON.parse(serialized) : {};
  },
  async update(address, pairing) {
    const pairings = await this.getAll();
    if (pairing === void 0) {
      delete pairings[address];
    } else {
      pairings[address] = pairing;
    }
    const newSerialized = JSON.stringify(pairings);
    window.localStorage.setItem(
      DAPP_PAIRINGS_WINDOW_STORAGE_KEY,
      newSerialized
    );
  }
};
var SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [
  "address",
  "application",
  "chainId",
  "fullMessage",
  "message",
  "nonce",
  "prefix",
  "signature"
];
function validateSignMessageResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = ["hash"];
function validateSignAndSubmitTransactionResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var API_VERSION = "0.2.0";
var SIGNING_REQUEST_POLLING_INTERVAL = 2500;
var SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\S+ to be )?(\d+)/;
async function waitFor2(milliseconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
}
async function withRetries(requestFn, onError, retries = 1) {
  for (let i4 = 0; i4 < retries; i4 += 1) {
    try {
      return await requestFn();
    } catch (err) {
      onError(err);
    }
  }
  return requestFn();
}
var ACPairingClient = class {
  constructor({
    accessors = windowStateAccessors,
    axiosConfig,
    defaultNetworkName = NetworkName.MAINNET
  } = {}) {
    this.onDisconnectListeners = /* @__PURE__ */ new Set();
    this.accessors = accessors;
    this.defaultNetworkName = defaultNetworkName;
    this.axiosInstance = axios_default.create({
      baseURL: DEFAULT_FRONTEND_URL,
      ...axiosConfig
    });
    const isClientSideRendering = typeof window !== "undefined";
    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;
  }
  async getPairing(id) {
    const response = await this.axiosInstance.get(
      `v1/pairing/${id}/`
    );
    return response.data.data.pairing;
  }
  async syncFirstPairing() {
    const pairings = await this.accessors.getAll();
    const firstPairing = Object.values(pairings)[0];
    if (firstPairing === void 0) {
      return;
    }
    try {
      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);
      await this.accessors.update(firstPairing.accountAddress, {
        ...firstPairing,
        currSequenceNumber: maxDappSequenceNumber,
        dappWalletId: dappSpecificWallet == null ? void 0 : dappSpecificWallet.id
      });
    } catch (_err) {
      await this.accessors.update(firstPairing.accountAddress, void 0);
    }
  }
  async createSigningRequest(pairing, type, networkName, requestBody) {
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(
      pairing.accountTransportEd25519PublicKeyB64
    );
    let sequenceNumber = pairing.currSequenceNumber + 1;
    return withRetries(
      async () => {
        const requestEnvelope = await encryptAndSignEnvelope(
          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          sequenceNumber,
          { apiVersion: API_VERSION, networkName, requestType: type },
          requestBody
        );
        const response = await this.axiosInstance.post(
          `v1/pairing/${pairing.pairingId}/signing-request/`,
          requestEnvelope
        );
        await this.accessors.update(pairing.accountAddress, {
          ...pairing,
          currSequenceNumber: sequenceNumber
        });
        return response.data.data.signingRequest;
      },
      (err) => {
        var _a, _b, _c;
        if (isAxiosError(err)) {
          const errorMessage = (_b = (_a = err.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message;
          const expectedSequenceNumber = (_c = errorMessage == null ? void 0 : errorMessage.match(
            SEQUENCE_NUMBER_MISMATCH_PATTERN
          )) == null ? void 0 : _c[1];
          if (expectedSequenceNumber !== void 0) {
            sequenceNumber = Number(expectedSequenceNumber);
            return;
          }
        }
        throw err;
      }
    );
  }
  async getSigningRequest(id) {
    var _a, _b;
    const response = await this.axiosInstance.get(`v1/signing-request/${id}/`, {
      validateStatus: (status) => status === 200 || status === 404
    });
    return (_b = (_a = response.data) == null ? void 0 : _a.data) == null ? void 0 : _b.signingRequest;
  }
  async deletePairing(pairingId, secretKey, publicKey) {
    const requestEnvelope = await encryptAndSignEnvelope(
      secretKey,
      publicKey,
      publicKey,
      0,
      // ignored
      {},
      {}
    );
    await this.axiosInstance.post(
      `v1/pairing/${pairingId}/delete/`,
      requestEnvelope,
      { validateStatus: (status) => status === 204 || status === 404 }
    );
  }
  async cancelSigningRequest(pairing, id) {
    const sequenceNumber = pairing.currSequenceNumber;
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(
      pairing.accountTransportEd25519PublicKeyB64
    );
    const requestEnvelope = await encryptAndSignEnvelope(
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      sequenceNumber + 1,
      {},
      {}
    );
    const response = await this.axiosInstance.patch(
      `v1/signing-request/${id}/cancel/`,
      requestEnvelope
    );
    await this.accessors.update(pairing.accountAddress, {
      ...pairing,
      currSequenceNumber: sequenceNumber + 1
    });
    return response.data.data.signingRequest;
  }
  async signRequest(address, type, requestBody, { cancelToken, networkName } = {}) {
    await this.initPromise;
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The requested account is not paired");
    }
    let signingRequest;
    try {
      signingRequest = await this.createSigningRequest(
        pairing,
        type,
        networkName || this.defaultNetworkName,
        requestBody
      );
      while (signingRequest.status === "PENDING") {
        await waitFor2(SIGNING_REQUEST_POLLING_INTERVAL);
        if (cancelToken == null ? void 0 : cancelToken.cancelled) {
          signingRequest.status = SigningRequestStatus.CANCELLED;
          break;
        }
        signingRequest = await this.getSigningRequest(signingRequest.id) ?? signingRequest;
      }
    } catch (err) {
      if (isAxiosError(err) && err.code === "404") {
        await this.accessors.update(address, void 0);
        for (const listener of this.onDisconnectListeners) {
          listener(address);
        }
        throw new PairingExpiredError();
      }
      throw err;
    }
    if (signingRequest.status !== "APPROVED") {
      throw new SignatureRequestError(signingRequest.status);
    }
    const decrypted = decryptEnvelope(
      toKey(
        decodeBase64(pairing.accountTransportEd25519PublicKeyB64),
        KeyTypes.Ed25519PublicKey
      ),
      toKey(
        decodeBase64(pairing.dappEd25519SecretKeyB64),
        KeyTypes.Ed25519SecretKey
      ),
      signingRequest.responseEnvelope
    );
    return decrypted.privateMessage;
  }
  // region Public API
  /**
   * Requests a connection to an account (internally known as pairing).
   * @returns either the address of the connected account, or undefined if the
   * connection was cancelled.
   */
  async addPairing({ publicKey, secretKey }, finalizedPairing) {
    await this.accessors.update(finalizedPairing.account.accountAddress, {
      accountAddress: finalizedPairing.account.accountAddress,
      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,
      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,
      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,
      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,
      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),
      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),
      dappWalletId: finalizedPairing.dappSpecificWalletId,
      pairingId: finalizedPairing.id
    });
  }
  async disconnect(address) {
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The specified account is not paired");
    }
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    await this.deletePairing(
      pairing.pairingId,
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey)
    );
    await this.accessors.update(address, void 0);
    for (const listener of this.onDisconnectListeners) {
      listener(address);
    }
  }
  async signMessage(address, args, options) {
    const response = await this.signRequest(address, SigningRequestTypes.SIGN_MESSAGE, args, options);
    validateSignMessageResponse(response);
    return response;
  }
  async signTransaction(address, args, options) {
    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);
    const serializedResponseArgs = await this.signRequest(
      address,
      SigningRequestTypes.SIGN_TRANSACTION,
      serializedRequestArgs,
      options
    );
    return deserializeSignTransactionResponseArgs(serializedResponseArgs);
  }
  // endregion
  async signAndSubmitTransaction(address, args, options) {
    var _a, _b, _c, _d;
    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);
    try {
      const responseArgs = await this.signRequest(
        address,
        SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION,
        serializedRequestArgs,
        options
      );
      validateSignAndSubmitTransactionResponse(responseArgs);
      return responseArgs;
    } catch (e14) {
      if (e14 instanceof AxiosError && ((_b = (_a = e14.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message)) {
        throw new Error((_d = (_c = e14.response) == null ? void 0 : _c.data) == null ? void 0 : _d.message);
      }
      throw e14;
    }
  }
  async getConnectedAccounts() {
    await this.initPromise;
    const pairings = await this.accessors.getAll();
    return Object.values(pairings).map(
      ({
        accountAddress,
        accountEd25519PublicKeyB64,
        accountPublicKeyB64
      }) => ({
        address: l.from(accountAddress),
        publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)
      })
    );
  }
  onDisconnect(listener) {
    this.onDisconnectListeners.add(listener);
    return () => this.onDisconnectListeners.delete(listener);
  }
};
var ACDappClient = class {
  constructor({
    backendBaseURL,
    dappId,
    dappImageURI,
    dappName,
    defaultNetworkName = NetworkName.MAINNET,
    frontendBaseURL = DEFAULT_FRONTEND_URL,
    provider = "google",
    tgWebAppURL
  } = {}) {
    this.dappInfo = {
      domain: window.location.origin,
      imageURI: dappImageURI,
      name: dappName ?? document.title
    };
    this.transport = new WebWalletTransport(
      frontendBaseURL,
      provider,
      tgWebAppURL
    );
    this.dappId = dappId;
    this.pairingClient = new ACPairingClient({
      axiosConfig: {
        baseURL: backendBaseURL ?? frontendBaseURL
      },
      defaultNetworkName
    });
  }
  // region Public API
  async getKeylessAccounts() {
    const serializedRequest = GetConnectedAccountsRequest.serialize(
      this.dappInfo
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);
    return response.args;
  }
  async getIcAccounts() {
    return await this.pairingClient.getConnectedAccounts() ?? [];
  }
  async isIcAccount(address) {
    const icAccounts = await this.getIcAccounts();
    return icAccounts.find(
      (account) => account.address.equals(l.from(address))
    ) !== void 0;
  }
  async getConnectedAccounts() {
    const keylessAccounts = await this.getKeylessAccounts();
    const icAccounts = await this.getIcAccounts();
    return [...keylessAccounts, ...icAccounts];
  }
  async disconnect(address) {
    if (await this.isIcAccount(address)) {
      const stringAddress = l.from(address).toString();
      await this.pairingClient.disconnect(stringAddress);
    } else {
      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);
      await this.transport.sendRequest(serializedRequest);
    }
  }
  async connect({
    claimOptions,
    preferredWalletName
  } = {}) {
    const dappKeypair = createEd25519KeyPair();
    const injectedPreferredWalletName = typeof window !== "undefined" ? window.AC_PREFERRED_WALLET_NAME : void 0;
    const requestArgs = {
      claimOptions,
      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),
      dappId: this.dappId,
      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName
    };
    const serializedRequest = ConnectRequest.serialize(
      this.dappInfo,
      requestArgs
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = ConnectResponse.deserialize(serializedResponse);
    if (response.args.status === "approved") {
      const { account, pairing } = response.args.args;
      if (pairing) {
        await this.pairingClient.addPairing(dappKeypair, pairing);
      }
      return makeUserApproval({ account });
    }
    return response.args;
  }
  async signIn(args) {
    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignInResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signMessage(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { chainId } = args;
      const network = chainIdToNetwork(chainId);
      let message;
      let nonce;
      try {
        message = new TextDecoder().decode(args.message);
        nonce = new TextDecoder().decode(args.nonce);
      } catch (_err) {
        throw new Error("Only UTF-8 encoded text is supported when using IC");
      }
      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(
        signerAddress.toString(),
        {
          address: true,
          application: true,
          chainId: true,
          message,
          nonce
        },
        { networkName: network }
      );
      const signatureBytes = a.fromHexInput(hexSignature).toUint8Array();
      const signature = signatureBytes.length === h.LENGTH ? new h(signatureBytes) : O.deserialize(new a2(signatureBytes));
      return makeUserApproval({
        fullMessage,
        signature
      });
    }
    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignMessageResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signTransaction(args) {
    const normalizedArgs = "transaction" in args ? SignTransactionRequest.normalizeArgs(args) : args;
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationSecondsFromNow,
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network,
        payload,
        secondarySigners,
        sender,
        sequenceNumber
      } = normalizedArgs;
      if (feePayer !== void 0) {
        throw new Error("Sponsored transaction not currently supported");
      }
      if (secondarySigners && secondarySigners.length > 0) {
        throw new Error("Multi-agent transactions not currently supported");
      }
      if (!("bcsToBytes" in payload)) {
        throw new Error(
          "Payload input format is only supported with Keyless accounts."
        );
      }
      const responseArgs = await this.pairingClient.signTransaction(
        signerAddress.toString(),
        {
          options: {
            expirationSecondsFromNow,
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount,
            sender: sender == null ? void 0 : sender.address.toString(),
            sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0
          },
          payload
        },
        {
          networkName: network
        }
      );
      return makeUserApproval({
        authenticator: responseArgs.accountAuthenticator,
        rawTransaction: responseArgs.rawTxn
      });
    }
    const serializedRequest = SignTransactionRequest.serialize(
      this.dappInfo,
      normalizedArgs
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signAndSubmitTransaction(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network
      } = args;
      if (network === shelbynet.name) {
        throw new Error("Shelbynet not supported");
      }
      const aptosConfig = new s({ network });
      let convertedArgs;
      if (feePayer !== void 0) {
        const payload = await normalizePayloadForIC(args.payload, aptosConfig);
        const rawTxn = await Ur({
          aptosConfig,
          feePayerAddress: feePayer.address,
          options: {
            gasUnitPrice,
            maxGasAmount
          },
          payload,
          sender: signerAddress
        });
        convertedArgs = {
          feePayerAuthenticator: feePayer.authenticator,
          rawTxn: new ut(rawTxn, [], feePayer.address)
        };
      } else {
        const payload = normalizePayloadForIC(args.payload);
        convertedArgs = {
          options: {
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount
          },
          payload
        };
      }
      const { hash } = await this.pairingClient.signAndSubmitTransaction(
        signerAddress.toString(),
        convertedArgs,
        {
          networkName: network
        }
      );
      return makeUserApproval({
        txnHash: hash
      });
    }
    const serializedRequest = SignAndSubmitTransactionRequest.serialize(
      this.dappInfo,
      args
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  // endregion
};

// node_modules/@aptos-connect/wallet-adapter-plugin/dist/index.mjs
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _address;
var _publicKey;
var AptosConnectAccount = class {
  constructor({ address, ansName, publicKey }) {
    this.chains = e8;
    this.features = [];
    __privateAdd(this, _address, void 0);
    __privateAdd(this, _publicKey, void 0);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _address, address);
    this.label = ansName;
  }
  get address() {
    return __privateGet(this, _address).toString();
  }
  get publicKey() {
    return __privateGet(this, _publicKey).toUint8Array();
  }
  get signingScheme() {
    if (__privateGet(this, _publicKey) instanceof f) {
      return E.Ed25519;
    }
    if (__privateGet(this, _publicKey) instanceof Dt) {
      return E.MultiEd25519;
    }
    if (__privateGet(this, _publicKey) instanceof k) {
      return E.SingleKey;
    }
    if (__privateGet(this, _publicKey) instanceof Se) {
      return E.MultiKey;
    }
    throw new Error("Unsupported public key type");
  }
  // endregion
};
_address = /* @__PURE__ */ new WeakMap();
_publicKey = /* @__PURE__ */ new WeakMap();
function customAccountToStandardAccount({
  address,
  name,
  publicKey
}) {
  return new d3({
    address,
    ansName: name,
    publicKey
  });
}
function unwrapUserResponse(response, callback) {
  if (response.status === "dismissed") {
    return { status: r5.REJECTED };
  }
  return { args: callback(response.args), status: r5.APPROVED };
}
function networkToChainId(network) {
  switch (network) {
    case e.MAINNET:
      return r.mainnet;
    case e.TESTNET:
      return r.testnet;
    default:
      return void 0;
  }
}
var _AptosConnectWallet = class _AptosConnectWallet2 {
  constructor({
    aptosClientConfig,
    claimSecretKey,
    network = e.MAINNET,
    preferredWalletName,
    ...clientConfig
  }) {
    this.version = "1.0.0";
    this.chains = e8;
    this.client = new ACDappClient(clientConfig);
    if (!o[network] && network !== shelbynet.name) {
      throw new Error("Network not supported");
    }
    this.network = network;
    const aptosSettings = network !== shelbynet.name ? { network } : {
      fullnode: shelbynet.nodeUrl,
      indexer: shelbynet.indexerUrl,
      network: e.CUSTOM
    };
    const aptosConfig = new s({
      ...aptosSettings,
      ...aptosClientConfig
    });
    this.aptosClient = new W(aptosConfig);
    this.preferredWalletName = preferredWalletName;
    if (claimSecretKey) {
      if (network === shelbynet.name) {
        throw new Error("Shelbynet not supported");
      }
      this.claimOptions = {
        network,
        secretKey: new z(claimSecretKey)
      };
    }
    this.chainIdPromise = this.aptosClient.getChainId();
    this.chainIdPromise.then((chainId) => {
      this.chainId = chainId;
    });
  }
  static get connectedAccount() {
    const serialized = localStorage.getItem(
      _AptosConnectWallet2.connectedAccountStorageKey
    );
    if (!serialized) {
      return void 0;
    }
    try {
      const { address, publicKey } = JSON.parse(
        serialized
      );
      return new d3({
        address: l.from(address),
        publicKey: deserializePublicKeyB64(publicKey)
      });
    } catch (_err) {
      this.connectedAccount = void 0;
      return void 0;
    }
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      const serialized = {
        address: value.address.toString(),
        publicKey: serializePublicKeyB64(value.publicKey)
      };
      localStorage.setItem(
        _AptosConnectWallet2.connectedAccountStorageKey,
        JSON.stringify(serialized)
      );
    } else {
      localStorage.removeItem(_AptosConnectWallet2.connectedAccountStorageKey);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount } = _AptosConnectWallet2;
    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];
  }
  async connect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount !== void 0) {
      return { args: connectedAccount, status: r5.APPROVED };
    }
    const response = await this.client.connect({
      claimOptions: this.claimOptions,
      preferredWalletName: this.preferredWalletName
    });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    const newConnectedAccount = customAccountToStandardAccount(
      response.args.account
    );
    _AptosConnectWallet2.connectedAccount = newConnectedAccount;
    return {
      args: newConnectedAccount,
      status: r5.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWallet2.connectedAccount = void 0;
    }
  }
  async signIn(input) {
    const response = await this.client.signIn({
      network: this.network,
      ...input
    });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    const output = response.args;
    _AptosConnectWallet2.connectedAccount = output.account;
    return { args: output, status: r5.APPROVED };
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(a4.Unauthorized);
    }
    return customAccountToStandardAccount(connectedAccount);
  }
  async getNetwork() {
    const chainId = await this.chainIdPromise;
    const isShelbynet = this.network === shelbynet.name;
    return {
      chainId,
      name: isShelbynet ? e.CUSTOM : this.network,
      url: isShelbynet ? shelbynet.nodeUrl : o[this.network]
    };
  }
  async signMessage(input) {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(a4.Unauthorized);
    }
    const chainId = networkToChainId(this.network) ?? this.chainId ?? await this.chainIdPromise;
    const { message, nonce } = input;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    const { fullMessage, signature } = response.args;
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: this.client.dappInfo.domain,
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage,
        signature,
        ...extraResponseArgs
      },
      status: r5.APPROVED
    };
  }
  async signTransaction(txnOrArgs, _asFeePayer) {
    var _a;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(a4.Unauthorized);
    }
    if ("bcsToBytes" in txnOrArgs) {
      const transaction = txnOrArgs;
      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
      const secondarySigners = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map(
        (address) => ({ address })
      );
      const response2 = await this.client.signTransaction({
        feePayer,
        network: this.network,
        secondarySigners,
        signerAddress: connectedAccount.address,
        transaction: transaction.rawTransaction
      });
      return unwrapUserResponse(response2, (args) => args.authenticator);
    }
    const requestArgs = txnOrArgs;
    const response = await this.client.signTransaction({
      network: this.network,
      ...requestArgs,
      signerAddress: connectedAccount.address
    });
    return unwrapUserResponse(response, (responseArgs) => {
      var _a2, _b;
      const { authenticator, rawTransaction } = responseArgs;
      if (!rawTransaction) {
        throw new Error("Expected raw transaction in response args");
      }
      const secondarySigners = requestArgs.secondarySigners ?? [];
      let transaction;
      if (secondarySigners.length > 0) {
        transaction = new Gn(
          rawTransaction,
          secondarySigners.map((s5) => s5.address),
          (_a2 = requestArgs.feePayer) == null ? void 0 : _a2.address
        );
      } else {
        transaction = new Gt(
          rawTransaction,
          (_b = requestArgs.feePayer) == null ? void 0 : _b.address
        );
      }
      return {
        authenticator,
        rawTransaction: transaction
      };
    });
  }
  async signAndSubmitTransaction(args) {
    const { gasUnitPrice, maxGasAmount, payload } = args;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s3(a4.Unauthorized);
    }
    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,
      maxGasAmount,
      network: this.network,
      payload,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r5.REJECTED };
    }
    return {
      args: { hash: response.args.txnHash },
      status: r5.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // endregion
};
_AptosConnectWallet.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var AptosConnectWallet = _AptosConnectWallet;
var walletMetadata = {
  apple: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxzdHlsZT4KICAgICAgICBwYXRoIHsKICAgICAgICAgICAgZmlsbDogYmxhY2s7CiAgICAgICAgfQoKICAgICAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgICAgICAgIHBhdGggewogICAgICAgICAgICAgICAgZmlsbDogd2hpdGU7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICA8L3N0eWxlPgogICAgPHBhdGgKICAgICAgICBkPSJNMjAuMzkzMiA4LjE4MjQyQzIwLjI1NzggOC4yOTA0MyAxNy44NjggOS42NzUzNyAxNy44NjggMTIuNzU0OUMxNy44NjggMTYuMzE2OCAyMC45MDkgMTcuNTc3IDIxIDE3LjYwODJDMjAuOTg2IDE3LjY4NSAyMC41MTY5IDE5LjMzMzkgMTkuMzk2NiAyMS4wMTQxQzE4LjM5NzcgMjIuNDkyNiAxNy4zNTQ1IDIzLjk2ODggMTUuNzY3NSAyMy45Njg4QzE0LjE4MDQgMjMuOTY4OCAxMy43NzIgMjMuMDIwNyAxMS45Mzk5IDIzLjAyMDdDMTAuMTU0NSAyMy4wMjA3IDkuNTE5NzIgMjQgOC4wNjgwNSAyNEM2LjYxNjM5IDI0IDUuNjAzNDkgMjIuNjMxOSA0LjQzODg5IDIwLjk1MTdDMy4wODk5MiAxOC45Nzg3IDIgMTUuOTEzNiAyIDEzLjAwNDVDMiA4LjMzODQzIDQuOTUwMDEgNS44NjM3OSA3Ljg1MzM0IDUuODYzNzlDOS4zOTYwMiA1Ljg2Mzc5IDEwLjY4MiA2LjkwNTQ5IDExLjY1MDUgNi45MDU0OUMxMi41NzI0IDYuOTA1NDkgMTQuMDEwMSA1LjgwMTM4IDE1Ljc2NTEgNS44MDEzOEMxNi40MzAzIDUuODAxMzggMTguODIwMiA1Ljg2Mzc5IDIwLjM5MzIgOC4xODI0MlpNMTQuOTMxOSAzLjgyNTk4QzE1LjY1NzggMi45NDAyOSAxNi4xNzEyIDEuNzExMzcgMTYuMTcxMiAwLjQ4MjQ0OEMxNi4xNzEyIDAuMzEyMDMxIDE2LjE1NzIgMC4xMzkyMTQgMTYuMTI2OSAwQzE0Ljk0NiAwLjA0NTYwNDYgMTMuNTQxIDAuODA4ODgxIDEyLjY5MzggMS44MTkzOEMxMi4wMjg2IDIuNTk3MDYgMTEuNDA3OCAzLjgyNTk4IDExLjQwNzggNS4wNzE3MUMxMS40MDc4IDUuMjU4OTMgMTEuNDM4MiA1LjQ0NjE0IDExLjQ1MjIgNS41MDYxNUMxMS41MjY4IDUuNTIwNTUgMTEuNjQ4MiA1LjUzNzM1IDExLjc2OTYgNS41MzczNUMxMi44MjkxIDUuNTM3MzUgMTQuMTYxOCA0LjgwNzY4IDE0LjkzMTkgMy44MjU5OFoiIC8+Cjwvc3ZnPg=="
    ),
    name: "Continue with Apple",
    url: "https://web.petra.app"
  },
  generic: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAeMSURBVHgB7Z09bFNXFMfPtQKVUgZXAomJGokFFlK1Iw1mKkyFlqENVKRTOyARNqRWIkhU6ghSl051pZZ26EeYyoZBjK1wF7og1emEVIYMEKkBcnv+tl9iHMf2s9+979x3z0+K7Dh2JL///3zcj/eeoQyYr9ryGtFJQ3TYWqrwSzP8vGz5h5SsaPIxbZKhxjrRnVeIGrW6adKEGBoTiP6MH8jSuyx0lZQ8aLCC13cS1cc1Q2oDtKJ9nS4YQwsa4XJgIWs7DF1Ja4RUBpibtZdVeOFYWrxx11wZ9e0jGYCjvrJm6Vd+OkNKCDR3Gjo2SjYoDXvDmVl77pml+6TihwQC9v6HVXty2BsHGgAp3xqqacoPkrLhrA0NB71p2xLQ+qChRVLCZ0Bf0NcASB2mXfOVgsB6zn9/13y75fXeF9DwoeZr2i8cK9wYvtHbGG7pAbh5uK3iF5LyWp+s/pIBOg1DhZSiMjNXtYvdL2yUgM5Y/29Sig5KwX4uBSv4ZSMD8Lz+ZVJiAAt3C8kvrQyg0R8dG1mglQHWdDUvNsr/YSWXOiWAx4gXSImKEi/j49Fo+o8XLgOvlZ7rIk+0YBdXaV3rf8zMlLj+HyYlVipTvNxb4dWiaNm9l+jVXUTT/LNn79a///to8/HxIyoWHPxTZOOY+oXI+w4Qvd71A8EhfBqWH7aN8KDRfv5Xg0KmbOaO2sLG/0Fubw/NtB8POmp1V58Q/X6vbYS7tyg4CmeARPTjp9NH96QkZviltlk6pFMYA7x5hOjEaXeRnhZkhJ9r8ktE0AZAXUekv328fwMnAZQFyRkhWAPMsujvzcsVvheYABlBGsEZACn+/Xk5qT4NyAJfLMjKBsEYAOkeEY+UHzrffUX0208kgikKAIzZL14NJ90P4+z59ghFQkkQbwBE/EfnqXAgm8HYX39J9PQJ5cbQU8PyAin/00vFFD8BQ9fPrrW/a16INABSPQ4MhndFB1kA3zUvxBkgER8HJhbwXT+5RLkgygCJ+EVp9tKAeQ0Mb30jxgAxi5+AxvCtI+QVEQZQ8TdBKfB5HHI3ADrgIo3xJwXzAz77gdwNkIyHlU0wzX3C04xnrgZA01OEqV0XIDB8zA/kZgCkfHxJpT/Tu/wcn1wMAGfnOfkRCsiOrnujXAwQ0jp+3rjOAt4NAOG17o8O5gVc9gLeDaCpPx3oBd5xGDBeDTAreO+eZE4UxQDa9Y8HsoCrLXDeDKDRPxmu1gi8GUCjfzJmHe2N8GIAjf7JcVUGvOwJ9BX9ODWr+ZBEUjkw+alqWDPJ+kwj5waAa31FP87LwyZLaSADHspghQ/nPN7KeDu58xIwG8G+vkFkud1rn4NVU+cGCPEMnqyA+J9nOPG1Z2/2s4JODeAz/UsjET/rU9R3Z3w8nRog1vTvSnyQdRlwaoB9Ee70cSk+CKYEIPVXIjOAa/HBdCgGiC36fYjvAmcGiKn7D1V84MwAsaT/kMUHzgwQw1bv0MUHTgwwvSvsgzIKRRAfODFA0Sd/8hQ/6+sLOcsARSXvyH8cggGKmgEkpP3VjC8noxlgRKSIv5zxfgc1wAhIafhcbHYRe5EoKUjq9v9RA/hF2lAPO56yRg2wDRLH+ZoBPCFR/D/uubmgpBqgB6kzfC7SP1ADdCFVfEz+uLodjRqgg+S5/QcO7zqiBiD5Czu42YQrojeAdPGR+l3eYCJqA4SwpOsy+kG0BghBfNfRD6I0QAjio/N3Hf0gOgOEspMHt5PxcXOp6AyAJdXVHG/RMgpI/b5uQxudARBVVxfk3gncV+pPiLIHkGoCZKarnu8rGO0oQKIJfNX9bqKeB5BkAoif9dU/RiH6mUAJJoD4Put+N7oWQPmaIE/xgRqgQx4myFt8oAbowqcJJIgP1AA9+DCBFPGBGqAPLk0gSXygBtgGFyaQJj5QAwwgSxNIFB+oAYaQhQmkig/UACMwiQkkiw/UACMyjgmkiw/UAClIY4IQxAdqgJSMYoJQxAdqgDEYZIKQxAdqgDHpZ4LQxAdm7qi1lDHYeJnHdQIhSta3VBkGroeETaZ3boUnPnBigNjAFbyfCt9ouh1aAjIgVPFByRCtkBItJWvUABHTRAnw3DYpUjCmbYBlUqKEu/8/NQNEDItfL+0kWiIlSp5z8JdqdbPCI4E6KVHBmjd+rJtmqfPbTVKigkd/1/HYMsAOoprOB8TFeifrtwyAMpA4QomCGtI/nmxMBXMzeE2zQBysG7qSPN8wgGaBSGDxk+hv/9rDmaP2Pk8QzJBSRJo37pj93S9sWQ18YeiUloLiAU059R/rfX2LAZAeuBRcJKVQsPgfd6f+hL77AW7UTY26GgUlcFjLH+pmqf+fBjBXtYu8YnCZlHBh8TmgF7f/8xDOVu1Ja+kbbgzLpAQDaj5KeSubD37fcD6o2krJ0m1+WiElBBpc80/1q/m9jGSABC0JsulE/fVBKb/PZ9KBbMAfWjSWzpEigkT4VZ7NXeIJvZSfHY9WWSCq8j+4wD2CThzlgDGtBZ2bT3kiN63wG/+DMgBmmOLZwxdsCDbFYYtewWq/kBWdCIfADT62y1jL52hfGlf0bv4H4emQh2jTz1sAAAAASUVORK5CYII="
    ),
    name: "Petra Web",
    url: "https://web.petra.app"
  },
  google: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
    ),
    name: "Continue with Google",
    url: "https://web.petra.app"
  }
};
var AptosConnectAppleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "apple" });
    this.name = walletMetadata.apple.name;
    this.icon = walletMetadata.apple.icon;
    this.url = walletMetadata.apple.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o5]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o6]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n10]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n8]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1.0"
      }
    };
  }
  // endregion
};
var AptosConnectGenericWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "generic" });
    this.name = walletMetadata.generic.name;
    this.icon = walletMetadata.generic.icon;
    this.url = walletMetadata.generic.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o5]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o6]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n10]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n8]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1.0"
      }
    };
  }
  // endregion
};
var AptosConnectGoogleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "google" });
    this.name = walletMetadata.google.name;
    this.icon = walletMetadata.google.icon;
    this.url = walletMetadata.google.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o5]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o6]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n10]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n8]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1.0"
      }
    };
  }
  // endregion
};

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) arr2[i4] = arr[i4];
  return arr2;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _call_super(_this, derived, args) {
  derived = _get_prototype_of(derived);
  return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _construct(Parent, args, Class) {
  if (_is_native_reflect_construct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function construct(Parent2, args2, Class2) {
      var a8 = [
        null
      ];
      a8.push.apply(a8, args2);
      var Constructor = Function.bind.apply(Parent2, a8);
      var instance = new Constructor();
      if (Class2) _set_prototype_of(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
  for (var i4 = 0; i4 < props.length; i4++) {
    var descriptor = props[i4];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _get_prototype_of(o13) {
  _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o14) {
    return o14.__proto__ || Object.getPrototypeOf(o14);
  };
  return _get_prototype_of(o13);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _set_prototype_of(subClass, superClass);
}
function _is_native_function(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  source = source != null ? source : {};
  if (Object.getOwnPropertyDescriptors) {
    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
  } else {
    ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _possible_constructor_return(self, call) {
  if (call && (_type_of(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assert_this_initialized(self);
}
function _set_prototype_of(o13, p5) {
  _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o14, p6) {
    o14.__proto__ = p6;
    return o14;
  };
  return _set_prototype_of(o13, p5);
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o13, minLen) {
  if (!o13) return;
  if (typeof o13 === "string") return _array_like_to_array(o13, minLen);
  var n16 = Object.prototype.toString.call(o13).slice(8, -1);
  if (n16 === "Object" && o13.constructor) n16 = o13.constructor.name;
  if (n16 === "Map" || n16 === "Set") return Array.from(n16);
  if (n16 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n16)) return _array_like_to_array(o13, minLen);
}
function _wrap_native_super(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrap_native_super = function wrapNativeSuper(Class2) {
    if (Class2 === null || !_is_native_function(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _get_prototype_of(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _set_prototype_of(Wrapper, Class2);
  };
  return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
  try {
    var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (_2) {
  }
  return (_is_native_reflect_construct = function() {
    return !!result;
  })();
}
function _ts_generator(thisArg, body) {
  var f7, y2, t11, g2, _2 = {
    label: 0,
    sent: function() {
      if (t11[0] & 1) throw t11[1];
      return t11[1];
    },
    trys: [],
    ops: []
  };
  return g2 = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n16) {
    return function(v6) {
      return step([
        n16,
        v6
      ]);
    };
  }
  function step(op) {
    if (f7) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f7 = 1, y2 && (t11 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t11 = y2["return"]) && t11.call(y2), 0) : y2.next) && !(t11 = t11.call(y2, op[1])).done) return t11;
      if (y2 = 0, t11) op = [
        op[0] & 2,
        t11.value
      ];
      switch (op[0]) {
        case 0:
        case 1:
          t11 = op;
          break;
        case 4:
          _2.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [
            0
          ];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t11 = _2.trys, t11 = t11.length > 0 && t11[t11.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t11 || op[1] > t11[0] && op[1] < t11[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t11[1]) {
            _2.label = t11[1];
            t11 = op;
            break;
          }
          if (t11 && _2.label < t11[2]) {
            _2.label = t11[2];
            _2.ops.push(op);
            break;
          }
          if (t11[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e14) {
      op = [
        6,
        e14
      ];
      y2 = 0;
    } finally {
      f7 = t11 = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var WALLET_ADAPTER_CORE_VERSION = "8.2.0";
var GA4 = function() {
  "use strict";
  function GA42() {
    _class_call_check(this, GA42);
    this.aptosGAID = "G-GNVVWBL3J9";
    this.injectGA(this.aptosGAID);
  }
  _create_class(GA42, [
    {
      key: "gtag",
      value: function gtag(a8, b3, c3) {
        var dataLayer = window.dataLayer || [];
        dataLayer.push(arguments);
      }
    },
    {
      key: "injectGA",
      value: function injectGA(gaID) {
        if (typeof window === "undefined") return;
        if (!gaID) return;
        var head = document.getElementsByTagName("head")[0];
        var myScript = document.createElement("script");
        myScript.setAttribute("src", "https://www.googletagmanager.com/gtag/js?id=".concat(gaID));
        var that = this;
        myScript.onload = function() {
          that.gtag("js", /* @__PURE__ */ new Date());
          that.gtag("config", "".concat(gaID), {
            send_page_view: false
          });
        };
        head.insertBefore(myScript, head.children[1]);
      }
    }
  ]);
  return GA42;
}();
var WalletError = function(Error1) {
  "use strict";
  _inherits(WalletError2, Error1);
  function WalletError2(message, error) {
    _class_call_check(this, WalletError2);
    var _this;
    _this = _call_super(this, WalletError2, [
      message
    ]);
    _this.error = error;
    return _this;
  }
  return WalletError2;
}(_wrap_native_super(Error));
var WalletNotSelectedError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotSelectedError2, WalletError2);
  function WalletNotSelectedError2() {
    _class_call_check(this, WalletNotSelectedError2);
    var _this;
    _this = _call_super(this, WalletNotSelectedError2, arguments);
    _this.name = "WalletNotSelectedError";
    return _this;
  }
  return WalletNotSelectedError2;
}(WalletError);
var WalletNotReadyError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotReadyError2, WalletError2);
  function WalletNotReadyError2() {
    _class_call_check(this, WalletNotReadyError2);
    var _this;
    _this = _call_super(this, WalletNotReadyError2, arguments);
    _this.name = "WalletNotReadyError";
    return _this;
  }
  return WalletNotReadyError2;
}(WalletError);
var WalletConnectionError = function(WalletError2) {
  "use strict";
  _inherits(WalletConnectionError2, WalletError2);
  function WalletConnectionError2() {
    _class_call_check(this, WalletConnectionError2);
    var _this;
    _this = _call_super(this, WalletConnectionError2, arguments);
    _this.name = "WalletConnectionError";
    return _this;
  }
  return WalletConnectionError2;
}(WalletError);
var WalletDisconnectionError = function(WalletError2) {
  "use strict";
  _inherits(WalletDisconnectionError2, WalletError2);
  function WalletDisconnectionError2() {
    _class_call_check(this, WalletDisconnectionError2);
    var _this;
    _this = _call_super(this, WalletDisconnectionError2, arguments);
    _this.name = "WalletDisconnectionError";
    return _this;
  }
  return WalletDisconnectionError2;
}(WalletError);
var WalletAccountError = function(WalletError2) {
  "use strict";
  _inherits(WalletAccountError2, WalletError2);
  function WalletAccountError2() {
    _class_call_check(this, WalletAccountError2);
    var _this;
    _this = _call_super(this, WalletAccountError2, arguments);
    _this.name = "WalletAccountError";
    return _this;
  }
  return WalletAccountError2;
}(WalletError);
var WalletGetNetworkError = function(WalletError2) {
  "use strict";
  _inherits(WalletGetNetworkError2, WalletError2);
  function WalletGetNetworkError2() {
    _class_call_check(this, WalletGetNetworkError2);
    var _this;
    _this = _call_super(this, WalletGetNetworkError2, arguments);
    _this.name = "WalletGetNetworkError";
    return _this;
  }
  return WalletGetNetworkError2;
}(WalletError);
var WalletAccountChangeError = function(WalletError2) {
  "use strict";
  _inherits(WalletAccountChangeError2, WalletError2);
  function WalletAccountChangeError2() {
    _class_call_check(this, WalletAccountChangeError2);
    var _this;
    _this = _call_super(this, WalletAccountChangeError2, arguments);
    _this.name = "WalletAccountChangeError";
    return _this;
  }
  return WalletAccountChangeError2;
}(WalletError);
var WalletNetworkChangeError = function(WalletError2) {
  "use strict";
  _inherits(WalletNetworkChangeError2, WalletError2);
  function WalletNetworkChangeError2() {
    _class_call_check(this, WalletNetworkChangeError2);
    var _this;
    _this = _call_super(this, WalletNetworkChangeError2, arguments);
    _this.name = "WalletNetworkChangeError";
    return _this;
  }
  return WalletNetworkChangeError2;
}(WalletError);
var WalletNotConnectedError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotConnectedError2, WalletError2);
  function WalletNotConnectedError2() {
    _class_call_check(this, WalletNotConnectedError2);
    var _this;
    _this = _call_super(this, WalletNotConnectedError2, arguments);
    _this.name = "WalletNotConnectedError";
    return _this;
  }
  return WalletNotConnectedError2;
}(WalletError);
var WalletSignMessageError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignMessageError2, WalletError2);
  function WalletSignMessageError2() {
    _class_call_check(this, WalletSignMessageError2);
    var _this;
    _this = _call_super(this, WalletSignMessageError2, arguments);
    _this.name = "WalletSignMessageError";
    return _this;
  }
  return WalletSignMessageError2;
}(WalletError);
var WalletSignMessageAndVerifyError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignMessageAndVerifyError2, WalletError2);
  function WalletSignMessageAndVerifyError2() {
    _class_call_check(this, WalletSignMessageAndVerifyError2);
    var _this;
    _this = _call_super(this, WalletSignMessageAndVerifyError2, arguments);
    _this.name = "WalletSignMessageAndVerifyError";
    return _this;
  }
  return WalletSignMessageAndVerifyError2;
}(WalletError);
var WalletSignAndSubmitMessageError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignAndSubmitMessageError2, WalletError2);
  function WalletSignAndSubmitMessageError2() {
    _class_call_check(this, WalletSignAndSubmitMessageError2);
    var _this;
    _this = _call_super(this, WalletSignAndSubmitMessageError2, arguments);
    _this.name = "WalletSignAndSubmitMessageError";
    return _this;
  }
  return WalletSignAndSubmitMessageError2;
}(WalletError);
var WalletSignTransactionError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignTransactionError2, WalletError2);
  function WalletSignTransactionError2() {
    _class_call_check(this, WalletSignTransactionError2);
    var _this;
    _this = _call_super(this, WalletSignTransactionError2, arguments);
    _this.name = "WalletSignTransactionError";
    return _this;
  }
  return WalletSignTransactionError2;
}(WalletError);
var WalletNotSupportedMethod = function(WalletError2) {
  "use strict";
  _inherits(WalletNotSupportedMethod2, WalletError2);
  function WalletNotSupportedMethod2() {
    _class_call_check(this, WalletNotSupportedMethod2);
    var _this;
    _this = _call_super(this, WalletNotSupportedMethod2, arguments);
    _this.name = "WalletNotSupportedMethod";
    return _this;
  }
  return WalletNotSupportedMethod2;
}(WalletError);
var WalletChangeNetworkError = function(WalletError2) {
  "use strict";
  _inherits(WalletChangeNetworkError2, WalletError2);
  function WalletChangeNetworkError2() {
    _class_call_check(this, WalletChangeNetworkError2);
    var _this;
    _this = _call_super(this, WalletChangeNetworkError2, arguments);
    _this.name = "WalletChangeNetworkError";
    return _this;
  }
  return WalletChangeNetworkError2;
}(WalletError);
var WalletSubmitTransactionError = function(WalletError2) {
  "use strict";
  _inherits(WalletSubmitTransactionError2, WalletError2);
  function WalletSubmitTransactionError2() {
    _class_call_check(this, WalletSubmitTransactionError2);
    var _this;
    _this = _call_super(this, WalletSubmitTransactionError2, arguments);
    _this.name = "WalletSubmitTransactionError";
    return _this;
  }
  return WalletSubmitTransactionError2;
}(WalletError);
var WalletNotFoundError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotFoundError2, WalletError2);
  function WalletNotFoundError2() {
    _class_call_check(this, WalletNotFoundError2);
    var _this;
    _this = _call_super(this, WalletNotFoundError2, arguments);
    _this.name = "WalletNotFoundError";
    return _this;
  }
  return WalletNotFoundError2;
}(WalletError);
var WalletReadyState = function(WalletReadyState2) {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  return WalletReadyState2;
}(WalletReadyState || {});
var NetworkName2 = function(NetworkName22) {
  NetworkName22["Mainnet"] = "mainnet";
  NetworkName22["Testnet"] = "testnet";
  NetworkName22["Devnet"] = "devnet";
  return NetworkName22;
}(NetworkName2 || {});
var ChainIdToAnsSupportedNetworkMap = {
  "1": "mainnet",
  // mainnet
  "2": "testnet"
};
var APTOS_CONNECT_BASE_URL = "https://aptosconnect.app";
var PETRA_WEB_BASE_URL = "https://web.petra.app";
var PETRA_WEB_GENERIC_WALLET_NAME = "Petra Web";
var PETRA_WALLET_NAME = "Petra";
var DEFAULT_WALLET_CONNECTION_FALLBACKS = _define_property({}, PETRA_WALLET_NAME, PETRA_WEB_GENERIC_WALLET_NAME);
var APTOS_CONNECT_ACCOUNT_URL = "https://aptosconnect.app/dashboard/main-account";
var PETRA_WEB_ACCOUNT_URL = "https://web.petra.app/dashboard/main-account";
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(navigator.userAgent);
}
function isInAppBrowser() {
  var isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
  var isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(navigator.userAgent);
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator) return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return (typeof error === "undefined" ? "undefined" : _type_of(error)) === "object" && "message" in error ? error.message : error;
}
var getAptosConfig = function(networkInfo, dappConfig) {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  var pluginSettings = {
    TRANSACTION_SUBMITTER: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.transactionSubmitter
  };
  if (isAptosNetwork(networkInfo)) {
    var currentNetwork = convertNetwork(networkInfo);
    if (isAptosLiveNetwork(currentNetwork)) {
      var apiKey = dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosApiKeys;
      return new s({
        network: currentNetwork,
        clientConfig: {
          API_KEY: apiKey ? apiKey[currentNetwork] : void 0
        },
        pluginSettings
      });
    }
    return new s({
      network: currentNetwork,
      pluginSettings
    });
  }
  var knownNetworks = {
    okx: "https://wallet.okx.com/fullnode/aptos/discover/rpc"
  };
  if (networkInfo.url) {
    var isKnownNetwork = Object.values(knownNetworks).includes(networkInfo.url);
    if (isKnownNetwork) {
      return new s({
        network: e.CUSTOM,
        fullnode: networkInfo.url,
        pluginSettings
      });
    }
  }
  throw new Error("Invalid network, network ".concat(networkInfo.name, " not supported with Aptos wallet adapter to prevent user from using an unexpected network."));
};
var isAptosNetwork = function(networkInfo) {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  return o[networkInfo.name] !== void 0;
};
var isAptosLiveNetwork = function(networkInfo) {
  return networkInfo === "devnet" || networkInfo === "testnet" || networkInfo === "mainnet";
};
var fetchDevnetChainId = function() {
  var _ref = _async_to_generator(function() {
    var aptos;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          aptos = new W();
          return [
            4,
            aptos.getChainId()
          ];
        case 1:
          return [
            2,
            _state.sent()
          ];
      }
    });
  });
  return function fetchDevnetChainId2() {
    return _ref.apply(this, arguments);
  };
}();
var handlePublishPackageTransaction = function(transactionInput) {
  var metadataBytes = transactionInput.data.functionArguments[0];
  if (typeof metadataBytes === "string") {
    metadataBytes = a.fromHexInput(metadataBytes).toUint8Array();
  }
  var byteCode = transactionInput.data.functionArguments[1];
  if (Array.isArray(byteCode)) {
    byteCode = byteCode.map(function(byte) {
      if (typeof byte === "string") {
        return a.fromHexInput(byte).toUint8Array();
      }
      return byte;
    });
  } else {
    throw new WalletSignAndSubmitMessageError("The bytecode argument must be an array.").message;
  }
  return {
    metadataBytes,
    byteCode
  };
};
function convertNetwork(networkInfo) {
  switch (networkInfo === null || networkInfo === void 0 ? void 0 : networkInfo.name) {
    case "mainnet":
      return e.MAINNET;
    case "testnet":
      return e.TESTNET;
    case "devnet":
      return e.DEVNET;
    case "local":
      return e.LOCAL;
    case "shelbynet":
      return e.SHELBYNET;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
function partitionWallets(wallets) {
  var partitionFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInstalledOrLoadable;
  var defaultWallets = [];
  var moreWallets = [];
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = wallets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var wallet = _step.value;
      if (partitionFunction(wallet)) {
        defaultWallets.push(wallet);
      } else {
        moreWallets.push(wallet);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return {
    defaultWallets,
    moreWallets
  };
}
function isInstalledOrLoadable(wallet) {
  return wallet.readyState === "Installed";
}
function isInstallRequired(wallet) {
  var isWalletReady = isInstalledOrLoadable(wallet);
  var isMobile2 = !isWalletReady && isRedirectable();
  return !isMobile2 && !isWalletReady;
}
function shouldUseFallbackWallet(wallet) {
  return !!wallet.fallbackWallet && isInstallRequired(wallet) && isInstalledOrLoadable(wallet.fallbackWallet);
}
function truncateAddress(address) {
  if (!address) return;
  return "".concat(address.slice(0, 6), "...").concat(address.slice(-5));
}
function isAptosConnectWallet(wallet) {
  return isPetraWebWallet(wallet);
}
function isPetraWebWallet(wallet) {
  var ignoreGenericWallet = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (!wallet.url) return false;
  if (ignoreGenericWallet && isPetraWebGenericWallet(wallet)) {
    return false;
  }
  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL) || wallet.url.startsWith(PETRA_WEB_BASE_URL);
}
function isPetraWebGenericWallet(wallet) {
  return wallet.name === PETRA_WEB_GENERIC_WALLET_NAME;
}
function getAptosConnectWallets(wallets) {
  var _partitionWallets = partitionWallets(wallets, isAptosConnectWallet), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  return {
    aptosConnectWallets: defaultWallets,
    otherWallets: moreWallets
  };
}
function getPetraWebWallets(wallets) {
  var _partitionWallets = partitionWallets(wallets, isPetraWebWallet), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  return {
    petraWebWallets: defaultWallets,
    otherWallets: moreWallets
  };
}
function groupAndSortWallets(wallets, options) {
  var _ref = options !== null && options !== void 0 ? options : {}, tmp = _ref.fallbacks, _ref1 = tmp === void 0 ? {} : tmp, fallbackConnections = _ref1.connections, additionalFallbackWallets = _ref1.additionalFallbackWallets;
  var aptosConnectWallets = getAptosConnectWallets(wallets).aptosConnectWallets;
  var _getPetraWebWallets = getPetraWebWallets(wallets), otherWallets = _getPetraWebWallets.otherWallets, petraWebWallets = _getPetraWebWallets.petraWebWallets;
  var _partitionWallets = partitionWallets(otherWallets), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  var availableWalletsWithFallbacks = [];
  if (fallbackConnections && Object.keys(fallbackConnections).length > 0) {
    var _loop = function(i5) {
      var wallet = moreWallets[i5];
      var fallbackName = fallbackConnections[wallet.name];
      if (fallbackName) {
        var fallbackWallet = _to_consumable_array(wallets).concat(_to_consumable_array(additionalFallbackWallets !== null && additionalFallbackWallets !== void 0 ? additionalFallbackWallets : [])).find(function(w3) {
          return w3.name === fallbackName && isInstalledOrLoadable(w3);
        });
        if (fallbackWallet) {
          var walletWithFallback = _object_spread_props(_object_spread({}, wallet), {
            fallbackWallet
          });
          moreWallets.splice(i5, 1);
          availableWalletsWithFallbacks.push(walletWithFallback);
        }
      }
    };
    for (var i4 = moreWallets.length - 1; i4 >= 0; i4--) _loop(i4);
  }
  if (options === null || options === void 0 ? void 0 : options.sortAptosConnectWallets) {
    aptosConnectWallets.sort(options.sortAptosConnectWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortPetraWebWallets) {
    petraWebWallets.sort(options.sortPetraWebWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortAvailableWallets) {
    defaultWallets.sort(options.sortAvailableWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortInstallableWallets) {
    moreWallets.sort(options.sortInstallableWallets);
  }
  return {
    /** @deprecated Use {@link petraWebWallets} instead. */
    aptosConnectWallets,
    /** Wallets that use social login to create an account on the blockchain */
    petraWebWallets,
    /** Wallets that are currently installed or loadable. */
    availableWallets: defaultWallets,
    /** Wallets that are currently uninstalled that have a fallback wallet. */
    availableWalletsWithFallbacks,
    /** Wallets that are NOT currently installed or loadable. */
    installableWallets: moreWallets
  };
}
var aptosStandardSupportedWalletList = [
  {
    name: "OKX Wallet",
    url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAeMSURBVHgB7Z09bFNXFMfPtQKVUgZXAomJGokFFlK1Iw1mKkyFlqENVKRTOyARNqRWIkhU6ghSl051pZZ26EeYyoZBjK1wF7og1emEVIYMEKkBcnv+tl9iHMf2s9+979x3z0+K7Dh2JL///3zcj/eeoQyYr9ryGtFJQ3TYWqrwSzP8vGz5h5SsaPIxbZKhxjrRnVeIGrW6adKEGBoTiP6MH8jSuyx0lZQ8aLCC13cS1cc1Q2oDtKJ9nS4YQwsa4XJgIWs7DF1Ja4RUBpibtZdVeOFYWrxx11wZ9e0jGYCjvrJm6Vd+OkNKCDR3Gjo2SjYoDXvDmVl77pml+6TihwQC9v6HVXty2BsHGgAp3xqqacoPkrLhrA0NB71p2xLQ+qChRVLCZ0Bf0NcASB2mXfOVgsB6zn9/13y75fXeF9DwoeZr2i8cK9wYvtHbGG7pAbh5uK3iF5LyWp+s/pIBOg1DhZSiMjNXtYvdL2yUgM5Y/29Sig5KwX4uBSv4ZSMD8Lz+ZVJiAAt3C8kvrQyg0R8dG1mglQHWdDUvNsr/YSWXOiWAx4gXSImKEi/j49Fo+o8XLgOvlZ7rIk+0YBdXaV3rf8zMlLj+HyYlVipTvNxb4dWiaNm9l+jVXUTT/LNn79a///to8/HxIyoWHPxTZOOY+oXI+w4Qvd71A8EhfBqWH7aN8KDRfv5Xg0KmbOaO2sLG/0Fubw/NtB8POmp1V58Q/X6vbYS7tyg4CmeARPTjp9NH96QkZviltlk6pFMYA7x5hOjEaXeRnhZkhJ9r8ktE0AZAXUekv328fwMnAZQFyRkhWAPMsujvzcsVvheYABlBGsEZACn+/Xk5qT4NyAJfLMjKBsEYAOkeEY+UHzrffUX0208kgikKAIzZL14NJ90P4+z59ghFQkkQbwBE/EfnqXAgm8HYX39J9PQJ5cbQU8PyAin/00vFFD8BQ9fPrrW/a16INABSPQ4MhndFB1kA3zUvxBkgER8HJhbwXT+5RLkgygCJ+EVp9tKAeQ0Mb30jxgAxi5+AxvCtI+QVEQZQ8TdBKfB5HHI3ADrgIo3xJwXzAz77gdwNkIyHlU0wzX3C04xnrgZA01OEqV0XIDB8zA/kZgCkfHxJpT/Tu/wcn1wMAGfnOfkRCsiOrnujXAwQ0jp+3rjOAt4NAOG17o8O5gVc9gLeDaCpPx3oBd5xGDBeDTAreO+eZE4UxQDa9Y8HsoCrLXDeDKDRPxmu1gi8GUCjfzJmHe2N8GIAjf7JcVUGvOwJ9BX9ODWr+ZBEUjkw+alqWDPJ+kwj5waAa31FP87LwyZLaSADHspghQ/nPN7KeDu58xIwG8G+vkFkud1rn4NVU+cGCPEMnqyA+J9nOPG1Z2/2s4JODeAz/UsjET/rU9R3Z3w8nRog1vTvSnyQdRlwaoB9Ee70cSk+CKYEIPVXIjOAa/HBdCgGiC36fYjvAmcGiKn7D1V84MwAsaT/kMUHzgwQw1bv0MUHTgwwvSvsgzIKRRAfODFA0Sd/8hQ/6+sLOcsARSXvyH8cggGKmgEkpP3VjC8noxlgRKSIv5zxfgc1wAhIafhcbHYRe5EoKUjq9v9RA/hF2lAPO56yRg2wDRLH+ZoBPCFR/D/uubmgpBqgB6kzfC7SP1ADdCFVfEz+uLodjRqgg+S5/QcO7zqiBiD5Czu42YQrojeAdPGR+l3eYCJqA4SwpOsy+kG0BghBfNfRD6I0QAjio/N3Hf0gOgOEspMHt5PxcXOp6AyAJdXVHG/RMgpI/b5uQxudARBVVxfk3gncV+pPiLIHkGoCZKarnu8rGO0oQKIJfNX9bqKeB5BkAoif9dU/RiH6mUAJJoD4Put+N7oWQPmaIE/xgRqgQx4myFt8oAbowqcJJIgP1AA9+DCBFPGBGqAPLk0gSXygBtgGFyaQJj5QAwwgSxNIFB+oAYaQhQmkig/UACMwiQkkiw/UACMyjgmkiw/UAClIY4IQxAdqgJSMYoJQxAdqgDEYZIKQxAdqgDHpZ4LQxAdm7qi1lDHYeJnHdQIhSta3VBkGroeETaZ3boUnPnBigNjAFbyfCt9ouh1aAjIgVPFByRCtkBItJWvUABHTRAnw3DYpUjCmbYBlUqKEu/8/NQNEDItfL+0kWiIlSp5z8JdqdbPCI4E6KVHBmjd+rJtmqfPbTVKigkd/1/HYMsAOoprOB8TFeifrtwyAMpA4QomCGtI/nmxMBXMzeE2zQBysG7qSPN8wgGaBSGDxk+hv/9rDmaP2Pk8QzJBSRJo37pj93S9sWQ18YeiUloLiAU059R/rfX2LAZAeuBRcJKVQsPgfd6f+hL77AW7UTY26GgUlcFjLH+pmqf+fBjBXtYu8YnCZlHBh8TmgF7f/8xDOVu1Ja+kbbgzLpAQDaj5KeSubD37fcD6o2krJ0m1+WiElBBpc80/1q/m9jGSABC0JsulE/fVBKb/PZ9KBbMAfWjSWzpEigkT4VZ7NXeIJvZSfHY9WWSCq8j+4wD2CThzlgDGtBZ2bT3kiN63wG/+DMgBmmOLZwxdsCDbFYYtewWq/kBWdCIfADT62y1jL52hfGlf0bv4H4emQh2jTz1sAAAAASUVORK5CYII=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://petra.app/explore?link="
  },
  {
    name: "Nightly",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Pontem Wallet",
    url: "https://pontem.network/pontem-wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Backpack",
    url: "https://chromewebstore.google.com/detail/backpack/aflkmfhebedbjioipglgcbcmnbpgliof",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CjxyZWN0IHg9IjEwIiB3aWR0aD0iNDQiIGhlaWdodD0iNjQiIGZpbGw9InVybCgjcGF0dGVybjBfMTdfNCkiLz4KPGRlZnM+CjxwYXR0ZXJuIGlkPSJwYXR0ZXJuMF8xN180IiBwYXR0ZXJuQ29udGVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgd2lkdGg9IjEiIGhlaWdodD0iMSI+Cjx1c2UgeGxpbms6aHJlZj0iI2ltYWdlMF8xN180IiB0cmFuc2Zvcm09InNjYWxlKDAuMDE4MTgxOCAwLjAxMjUpIi8+CjwvcGF0dGVybj4KPGltYWdlIGlkPSJpbWFnZTBfMTdfNCIgd2lkdGg9IjU1IiBoZWlnaHQ9IjgwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQURjQUFBQlFDQVlBQUFDOUt1MmtBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBUWpTVVJCVkhnQjdadlJjZHRHRUliL1BkTFBvUjh6SThsVUJXWUY1TG1DT0JWWXFzQmhCWllyaUZPQjVRcXNWT0FqWFlDWkNrUmJtc2xqK0I0U20xMlFZaUNKU2tqY3dpSXc5ODF3UUkxQTRIN2NZZkh2M29GUUFaZmVkOXBBanhib3dmRnpCanBZZnRZdzA4UXh2bklMa3prd09RNWhCbU1JaGx4NTc2WFZiOEFpNm82WUxWcHl3Um45ZnZRNW5NTUlFM0VxaXBqZk02T0xTS1JCMDh6UjhDaUVDMFRpRU1sVnYvOEdHWCt5RUtiSUVPNVN4aC96NDBZUzFYUExCdEFaS2lKakdqNzdITjZoSktYRlNkRG90ak8rUkxYTTVvNk95d2FiTmtvaVArenF5VUUwbFNzMGtXSDVsUml6ckFWdHlJeVFiM1cvNlVQSG1PUGZvYXpEMFMzUVlaSkFSSGdPRFVqTXZSYmc1WHYwL1pkSUpLckgxS0hjNVUrSnFMb3RCbzdDaVdjU0xHWS9oakJGUlVTTDIrQWplMWcrMEhleFh4SjFNZEV0WlRTeThwdWx4S21nSnd1Y3NPT2ZSSWhIVlJDQytNMFBUMW9JWlhwNEozRUZZK3p4blNIQ09STjlPQXdoYlAyYmJYYkszWWdZNDhjUWRRL0pIdHBFdzIxNjhuK05zL2pIMTduTjJnZGhDdVBsWE5xempiRitzT2Z5UU1IOGNXOUViVUo2Y1U1MCtsRGcyU2h1SmV6VEt1bTBhWWQ0VU4weTg3MnNQTzdBRWxtSlhtd1N1SEZZbWdtVEU1T2tMZUxzbng2TXdyRitEc2VqcCtyMDJkR3BCSWtwWXBGMmFudTFRKzZmL2c3Zit2MWZDZlFMSWxGUkIxdmtZbGQ5ZnlZdGpFNU1HZnp1YUR3ZTNtcEQ4WTl2M3A5SUZ2d2VrVWp4NTNTWFdvalZlZUhvUmZGUmNXdFlPbzYvZ25LOTN1NWE1SkY2aWV4UHZ5RVN2VURGNGJrV3AxY3Z0ZzZpeFozRGNUaERDZVlPWjFnbHVHWFJoTGVkWVgxTHJjV1o5QnFYdi9yTGFCZmZlOUtJMXpmZmNuRnFxMHlxVitJQkVRRTVrM0pDSjdlSldJbVQyc2NyR0hBUXdnUVIvQTJEUjRPUzRhVnVWc09TUGZZQXU1STY1NTFGMTk3M09PTXZNRUFmMWpFTnpKMVJ4bi9CZ0xZWUJaY3RiQ3JGK1FFUjUycGlmMTlrc1lCM1lvSE1Ebmd6MXN0aWRlOHJVdi9zdVZVQjFPcVFyMjdxSnJ1aU9hT1k2aE1ZUWNRL1NFQmhPNGN1WVhqTzVXeFVtdzNzVndHdDVUZ3h5VjFZSXZuZjlXQ3dVMFB6L1kzelJobmlIYm9lK0VzWkRsMFlvMWFzSlViMnY4b0JWZFprOVB4MDFSOHdxbVExWTBvdFRIVlNaS0dKcWtTeXlpdG5ldXJLeFQwaTBUT3IrMHdTVjFlU3VMcVN4TldWSks2dUpIRjFKWW1ySzFwbUNHZ2lSQmRPWnlaTjVzbjJDWmtYYkJPRzZ5bXNteEowM2RIRk83R1Y3MFFpa2JoSEhpMTFOUTRSblZndG4zOVVTTmRiYzlDVkRXUzFOR1Avb0xkYVR2ZG9JQ1NUTXVvdDdhYXc5b2g4S1Q4YVRCSlhWNUs0dXBMRTFaVWtycTQwWHB6NSs5bjdncE5VcDVIaWRLbUdrOXlua2VLWVNNU0Iva0FEa1pSbjZzamhIQTBreTJpMExETU1CbDhzWDIxNWJQUitPeGlQanZOSGdaVFVmMjVNU1YxcUtMcm1iUG0xZ0w1YmdBeGVoRDZUZjNTcldQQm16RXlqUFM5ZnVwOHc0ZGJMZy84QUhSZXNCMHpiQzQ0QUFBQUFTVVZPUks1Q1lJST0iLz4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://backpack.app/ul/v1?url="
  },
  {
    name: "Bitget Wallet",
    url: "https://web3.bitget.com",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjMDAxRjI5Ii8+CjxwYXRoIGQ9Ik0yMTkuOTQ4IDk1LjcwMjJDMjAxLjYyMyA5NS42OTI5IDE4My4zMyA5NS42ODM1IDE2NC45NDEgOTUuNzExNkMxNTMuODIyIDk1LjcxMTYgMTQ5LjY1MSAxMDkuNjcxIDE1Ny45MjEgMTE3LjkzOUwyODMuMDk4IDI0My4xMTdDMjg3LjAwNCAyNDYuNjkgMjg5LjQ0MSAyNTAuNTc0IDI4OS41MyAyNTUuNjkzQzI4OS40NDEgMjYwLjgxMiAyODcuMDA0IDI2NC42OTYgMjgzLjA5OCAyNjguMjY5TDE1Ny45MjEgMzkzLjQ0NkMxNDkuNjUxIDQwMS43MTUgMTUzLjgyMiA0MTUuNjc0IDE2NC45NDEgNDE1LjY3NEMxODMuMzMgNDE1LjcwMiAyMDEuNjIzIDQxNS42OTMgMjE5Ljk0OCA0MTUuNjgzQzIyOS4xMjIgNDE1LjY3OSAyMzguMzA1IDQxNS42NzQgMjQ3LjUxMSA0MTUuNjc0QzI1OS41NTUgNDE1LjY3NCAyNjYuNzIgNDA5LjI0IDI3My4xNTQgNDAyLjgwNUwzODYuMDQ3IDI4OS45MTJDMzk1LjA1NyAyODAuOTAyIDQwMy4xMTkgMjY4LjkzOSA0MDMuMDA5IDI1NS42OTNDNDAzLjExOSAyNDIuNDQ3IDM5NS4wNTcgMjMwLjQ4NCAzODYuMDQ3IDIyMS40NzRMMjczLjE1NCAxMDguNThDMjY2LjcyIDEwMi4xNDYgMjU5LjU1NSA5NS43MTE2IDI0Ny41MTEgOTUuNzExNkMyMzguMzA1IDk1LjcxMTYgMjI5LjEyMiA5NS43MDY5IDIxOS45NDggOTUuNzAyMloiIGZpbGw9IiMwMEYwRkYiLz4KPC9zdmc+Cg==",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Gate Wallet",
    url: "https://www.gate.com/zh/web3/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNjAwcHgiIGhlaWdodD0iNjAwcHgiIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPue8lue7hCA3PC90aXRsZT4KICAgIDxkZWZzPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTEiIHBvaW50cz0iMCAwIDYwMCAwIDYwMCA2MDAgMCA2MDAiPjwvcG9seWdvbj4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSLmjaLoibIiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJTVkciIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzU1LjAwMDAwMCwgLTU1MTguMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSLnvJbnu4QtNyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc1NS4wMDAwMDAsIDU1MTguMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0i57yW57uEIj4KICAgICAgICAgICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9tYXNrPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzAwLDQ2NC45OTg0MjcgQzIwOC44NzMwNjksNDY0Ljk5ODQyNyAxMzQuOTk2NTA0LDM5MS4xMjI1NjYgMTM0Ljk5NjUwNCwyOTkuOTk2NTA0IEMxMzQuOTk2NTA0LDIwOC44NzA0NDIgMjA4Ljg3MzA2OSwxMzUuMDAwOTM4IDMwMCwxMzUuMDAwOTM4IEwzMDAsLTAuMDAwNjM1NjAwNjI0IEMxMzQuMzEwMDQ5LC0wLjAwMDYzNTYwMDYyNCAwLDEzNC4zMTQ0ODkgMCwyOTkuOTk2NTA0IEMwLDQ2NS42Nzg1MiAxMzQuMzEwMDQ5LDYwMCAzMDAsNjAwIEM0NjUuNjg5OTUxLDYwMCA2MDAsNDY1LjY3ODUyIDYwMCwyOTkuOTk2NTA0IEw0NjUuMDAzNDk2LDI5OS45OTY1MDQgQzQ2NS4wMDM0OTYsMzkxLjEyMjU2NiAzOTEuMTI2OTMxLDQ2NC45OTg0MjcgMzAwLDQ2NC45OTg0MjciIGlkPSJGaWxsLTEiIGZpbGw9IiMyMzU0RTYiIG1hc2s9InVybCgjbWFzay0yKSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IkZpbGwtMyIgZmlsbD0iIzE3RTZBMSIgcG9pbnRzPSIyOTkuOTkyMzczIDI5OS45OTcxNCA0NjQuOTk1ODY5IDI5OS45OTcxNCA0NjQuOTk1ODY5IDEzNC45OTUyMTcgMjk5Ljk5MjM3MyAxMzQuOTk1MjE3Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Cosmostation Wallet",
    url: "https://www.cosmostation.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wIDQwQzAgMTcuOTA4NiAxNy45MDg2IDAgNDAgMEg4OEMxMTAuMDkxIDAgMTI4IDE3LjkwODYgMTI4IDQwVjg4QzEyOCAxMTAuMDkxIDExMC4wOTEgMTI4IDg4IDEyOEg0MEMxNy45MDg2IDEyOCAwIDExMC4wOTEgMCA4OFY0MFoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl85MDg4XzE0OTgxKSIvPgo8cGF0aCBkPSJNNTEuMDI1MyA4Ni4xNTkxTDM1Ljg2NiA1OS45MDI1QzM1LjQ4ODEgNTkuMjQ3OSAzNS4yODkxIDU4LjUwNTUgMzUuMjg5MSA1Ny43NDk3QzM1LjI4OTEgNTYuOTkzOSAzNS40ODgxIDU2LjI1MTQgMzUuODY2IDU1LjU5NjlMNTEuMDI1MyAyOS4zNTNDNTEuNDAzMiAyOC42OTg0IDUxLjk0NjggMjguMTU0OSA1Mi42MDE0IDI3Ljc3N0M1My4yNTU5IDI3LjM5OTEgNTMuOTk4NSAyNy4yMDAyIDU0Ljc1NDMgMjcuMjAwMkg4NS4wNjAyQzg1LjgxNjEgMjcuMjAwMiA4Ni41NTg2IDI3LjM5OTEgODcuMjEzMiAyNy43NzdDODcuODY3OCAyOC4xNTQ5IDg4LjQxMTMgMjguNjk4NCA4OC43ODkyIDI5LjM1M0wxMDQgNTUuNjIyNEw5Ni41NDE5IDU5LjkyODFMODIuNjI1NSAzNS44MzcxSDU3LjI0MDNMNDQuNTY2OSA1Ny43NzUyTDU4LjQ4MzMgODEuODc5TDUxLjAyNTMgODYuMTU5MVoiIGZpbGw9IiM5QzZDRkYiLz4KPHBhdGggZD0iTTczLjI0NTYgMTAwLjQ0OEg0Mi44NzU1QzQyLjExOTcgMTAwLjQ0OCA0MS4zNzcyIDEwMC4yNDkgNDAuNzIyNiA5OS44NzExQzQwLjA2ODEgOTkuNDkzMiAzOS41MjQ1IDk4Ljk0OTYgMzkuMTQ2NiA5OC4yOTUxTDI0IDcyLjA2NDFMMzEuNDQ1MSA2Ny43NTg1TDQ1LjM2MTUgOTEuODYyM0g3MC42ODI3TDgzLjM0MzMgNjkuOTExM0w2OS40Mzk3IDQ1LjgyMDNMNzYuODg0OSA0MS41MTQ2TDkyLjA0NDIgNjcuNzU4NUM5Mi40MjIxIDY4LjQxMyA5Mi42MjExIDY5LjE1NTUgOTIuNjIxMSA2OS45MTEzQzkyLjYyMTEgNzAuNjY3MSA5Mi40MjIxIDcxLjQwOTYgOTIuMDQ0MiA3Mi4wNjQxTDc2Ljg4NDkgOTguMzIwN0M3Ni41MTM0IDk4Ljk1OTIgNzUuOTgzIDk5LjQ5MDYgNzUuMzQ1MyA5OS44NjM0Qzc0LjcwNzUgMTAwLjIzNiA3My45ODQyIDEwMC40MzggNzMuMjQ1NiAxMDAuNDQ4WiIgZmlsbD0iIzA1RDJERCIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzkwODhfMTQ5ODEiIHgxPSI2NCIgeTE9IjAiIHgyPSI2NCIgeTI9IjEyOCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMjEyMTIxIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzE3MTcxNyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true
  }
];
var crossChainStandardSupportedWalletList = [
  {
    name: "Phantom (Solana)",
    url: "https://phantom.com/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://phantom.app/ul/browse/"
  },
  {
    name: "Phantom (Ethereum)",
    url: "https://phantom.com/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://phantom.app/ul/browse/"
  },
  {
    name: "Nightly (Solana)",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Nightly (Ethereum)",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Metamask (Solana)",
    url: "https://metamask.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiB2aWV3Qm94PSIwIDAgMjU2IDI0MCI+PHBhdGggZmlsbD0iI0UxNzcyNiIgZD0iTTI1MC4wNjYgMEwxNDAuMjE5IDgxLjI3OWwyMC40MjctNDcuOXoiLz48cGF0aCBmaWxsPSIjRTI3NjI1IiBkPSJtNi4xOTEuMDk2bDg5LjE4MSAzMy4yODlsMTkuMzk2IDQ4LjUyOHpNMjA1Ljg2IDE3Mi44NThsNDguNTUxLjkyNGwtMTYuOTY4IDU3LjY0MmwtNTkuMjQzLTE2LjMxMXptLTE1NS43MjEgMGwyNy41NTcgNDIuMjU1bC01OS4xNDMgMTYuMzEybC0xNi44NjUtNTcuNjQzeiIvPjxwYXRoIGZpbGw9IiNFMjc2MjUiIGQ9Im0xMTIuMTMxIDY5LjU1MmwxLjk4NCA2NC4wODNsLTU5LjM3MS0yLjcwMWwxNi44ODgtMjUuNDc4bC4yMTQtLjI0NXptMzEuMTIzLS43MTVsNDAuOSAzNi4zNzZsLjIxMi4yNDRsMTYuODg4IDI1LjQ3OGwtNTkuMzU4IDIuN3pNNzkuNDM1IDE3My4wNDRsMzIuNDE4IDI1LjI1OWwtMzcuNjU4IDE4LjE4MXptOTcuMTM2LS4wMDRsNS4xMzEgNDMuNDQ1bC0zNy41NTMtMTguMTg0eiIvPjxwYXRoIGZpbGw9IiNENUJGQjIiIGQ9Im0xNDQuOTc4IDE5NS45MjJsMzguMTA3IDE4LjQ1MmwtMzUuNDQ3IDE2Ljg0NmwuMzY4LTExLjEzNHptLTMzLjk2Ny4wMDhsLTIuOTA5IDIzLjk3NGwuMjM5IDExLjMwM2wtMzUuNTMtMTYuODMzeiIvPjxwYXRoIGZpbGw9IiMyMzM0NDciIGQ9Im0xMDAuMDA3IDE0MS45OTlsOS45NTggMjAuOTI4bC0zMy45MDMtOS45MzJ6bTU1Ljk4NS4wMDJsMjQuMDU4IDEwLjk5NGwtMzQuMDE0IDkuOTI5eiIvPjxwYXRoIGZpbGw9IiNDQzYyMjgiIGQ9Im04Mi4wMjYgMTcyLjgzbC01LjQ4IDQ1LjA0bC0yOS4zNzMtNDQuMDU1em05MS45NS4wMDFsMzQuODU0Ljk4NGwtMjkuNDgzIDQ0LjA1N3ptMjguMTM2LTQ0LjQ0NGwtMjUuMzY1IDI1Ljg1MWwtMTkuNTU3LTguOTM3bC05LjM2MyAxOS42ODRsLTYuMTM4LTMzLjg0OXptLTE0OC4yMzcgMGw2MC40MzUgMi43NDlsLTYuMTM5IDMzLjg0OWwtOS4zNjUtMTkuNjgxbC0xOS40NTMgOC45MzV6Ii8+PHBhdGggZmlsbD0iI0UyNzUyNSIgZD0ibTUyLjE2NiAxMjMuMDgybDI4LjY5OCAyOS4xMjFsLjk5NCAyOC43NDl6bTE1MS42OTctLjA1MmwtMjkuNzQ2IDU3Ljk3M2wxLjEyLTI4Ljh6bS05MC45NTYgMS44MjZsMS4xNTUgNy4yN2wyLjg1NCAxOC4xMTFsLTEuODM1IDU1LjYyNWwtOC42NzUtNDQuNjg1bC0uMDAzLS40NjJ6bTMwLjE3MS0uMTAxbDYuNTIxIDM1Ljk2bC0uMDAzLjQ2MmwtOC42OTcgNDQuNzk3bC0uMzQ0LTExLjIwNWwtMS4zNTctNDQuODYyeiIvPjxwYXRoIGZpbGw9IiNGNTg0MUYiIGQ9Im0xNzcuNzg4IDE1MS4wNDZsLS45NzEgMjQuOTc4bC0zMC4yNzQgMjMuNTg3bC02LjEyLTQuMzI0bDYuODYtMzUuMzM1em0tOTkuNDcxIDBsMzAuMzk5IDguOTA2bDYuODYgMzUuMzM1bC02LjEyIDQuMzI0bC0zMC4yNzUtMjMuNTg5eiIvPjxwYXRoIGZpbGw9IiNDMEFDOUQiIGQ9Im02Ny4wMTggMjA4Ljg1OGwzOC43MzIgMTguMzUybC0uMTY0LTcuODM3bDMuMjQxLTIuODQ1aDM4LjMzNGwzLjM1OCAyLjgzNWwtLjI0OCA3LjgzMWwzOC40ODctMTguMjlsLTE4LjcyOCAxNS40NzZsLTIyLjY0NSAxNS41NTNoLTM4Ljg2OWwtMjIuNjMtMTUuNjE3eiIvPjxwYXRoIGZpbGw9IiMxNjE2MTYiIGQ9Im0xNDIuMjA0IDE5My40NzlsNS40NzYgMy44NjlsMy4yMDkgMjUuNjA0bC00LjY0NC0zLjkyMWgtMzYuNDc2bC00LjU1NiA0bDMuMTA0LTI1LjY4MWw1LjQ3OC0zLjg3MXoiLz48cGF0aCBmaWxsPSIjNzYzRTFBIiBkPSJNMjQyLjgxNCAyLjI1TDI1NiA0MS44MDdsLTguMjM1IDM5Ljk5N2w1Ljg2NCA0LjUyM2wtNy45MzUgNi4wNTRsNS45NjQgNC42MDZsLTcuODk3IDcuMTkxbDQuODQ4IDMuNTExbC0xMi44NjYgMTUuMDI2bC01Mi43Ny0xNS4zNjVsLS40NTctLjI0NWwtMzguMDI3LTMyLjA3OHptLTIyOS42MjggMGw5OC4zMjYgNzIuNzc3bC0zOC4wMjggMzIuMDc4bC0uNDU3LjI0NWwtNTIuNzcgMTUuMzY1bC0xMi44NjYtMTUuMDI2bDQuODQ0LTMuNTA4bC03Ljg5Mi03LjE5NGw1Ljk1Mi00LjYwMWwtOC4wNTQtNi4wNzFsNi4wODUtNC41MjZMMCA0MS44MDl6Ii8+PHBhdGggZmlsbD0iI0Y1ODQxRiIgZD0ibTE4MC4zOTIgMTAzLjk5bDU1LjkxMyAxNi4yNzlsMTguMTY1IDU1Ljk4NmgtNDcuOTI0bC0zMy4wMi40MTZsMjQuMDE0LTQ2LjgwOHptLTEwNC43ODQgMGwtMTcuMTUxIDI1Ljg3M2wyNC4wMTcgNDYuODA4bC0zMy4wMDUtLjQxNkgxLjYzMWwxOC4wNjMtNTUuOTg1em04Ny43NzYtNzAuODc4bC0xNS42MzkgNDIuMjM5bC0zLjMxOSA1Ny4wNmwtMS4yNyAxNy44ODVsLS4xMDEgNDUuNjg4aC0zMC4xMTFsLS4wOTgtNDUuNjAybC0xLjI3NC0xNy45ODZsLTMuMzItNTcuMDQ1bC0xNS42MzctNDIuMjM5eiIvPjwvc3ZnPg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://link.metamask.io/dapp/"
  },
  {
    name: "Metamask (Ethereum)",
    url: "https://metamask.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiB2aWV3Qm94PSIwIDAgMjU2IDI0MCI+PHBhdGggZmlsbD0iI0UxNzcyNiIgZD0iTTI1MC4wNjYgMEwxNDAuMjE5IDgxLjI3OWwyMC40MjctNDcuOXoiLz48cGF0aCBmaWxsPSIjRTI3NjI1IiBkPSJtNi4xOTEuMDk2bDg5LjE4MSAzMy4yODlsMTkuMzk2IDQ4LjUyOHpNMjA1Ljg2IDE3Mi44NThsNDguNTUxLjkyNGwtMTYuOTY4IDU3LjY0MmwtNTkuMjQzLTE2LjMxMXptLTE1NS43MjEgMGwyNy41NTcgNDIuMjU1bC01OS4xNDMgMTYuMzEybC0xNi44NjUtNTcuNjQzeiIvPjxwYXRoIGZpbGw9IiNFMjc2MjUiIGQ9Im0xMTIuMTMxIDY5LjU1MmwxLjk4NCA2NC4wODNsLTU5LjM3MS0yLjcwMWwxNi44ODgtMjUuNDc4bC4yMTQtLjI0NXptMzEuMTIzLS43MTVsNDAuOSAzNi4zNzZsLjIxMi4yNDRsMTYuODg4IDI1LjQ3OGwtNTkuMzU4IDIuN3pNNzkuNDM1IDE3My4wNDRsMzIuNDE4IDI1LjI1OWwtMzcuNjU4IDE4LjE4MXptOTcuMTM2LS4wMDRsNS4xMzEgNDMuNDQ1bC0zNy41NTMtMTguMTg0eiIvPjxwYXRoIGZpbGw9IiNENUJGQjIiIGQ9Im0xNDQuOTc4IDE5NS45MjJsMzguMTA3IDE4LjQ1MmwtMzUuNDQ3IDE2Ljg0NmwuMzY4LTExLjEzNHptLTMzLjk2Ny4wMDhsLTIuOTA5IDIzLjk3NGwuMjM5IDExLjMwM2wtMzUuNTMtMTYuODMzeiIvPjxwYXRoIGZpbGw9IiMyMzM0NDciIGQ9Im0xMDAuMDA3IDE0MS45OTlsOS45NTggMjAuOTI4bC0zMy45MDMtOS45MzJ6bTU1Ljk4NS4wMDJsMjQuMDU4IDEwLjk5NGwtMzQuMDE0IDkuOTI5eiIvPjxwYXRoIGZpbGw9IiNDQzYyMjgiIGQ9Im04Mi4wMjYgMTcyLjgzbC01LjQ4IDQ1LjA0bC0yOS4zNzMtNDQuMDU1em05MS45NS4wMDFsMzQuODU0Ljk4NGwtMjkuNDgzIDQ0LjA1N3ptMjguMTM2LTQ0LjQ0NGwtMjUuMzY1IDI1Ljg1MWwtMTkuNTU3LTguOTM3bC05LjM2MyAxOS42ODRsLTYuMTM4LTMzLjg0OXptLTE0OC4yMzcgMGw2MC40MzUgMi43NDlsLTYuMTM5IDMzLjg0OWwtOS4zNjUtMTkuNjgxbC0xOS40NTMgOC45MzV6Ii8+PHBhdGggZmlsbD0iI0UyNzUyNSIgZD0ibTUyLjE2NiAxMjMuMDgybDI4LjY5OCAyOS4xMjFsLjk5NCAyOC43NDl6bTE1MS42OTctLjA1MmwtMjkuNzQ2IDU3Ljk3M2wxLjEyLTI4Ljh6bS05MC45NTYgMS44MjZsMS4xNTUgNy4yN2wyLjg1NCAxOC4xMTFsLTEuODM1IDU1LjYyNWwtOC42NzUtNDQuNjg1bC0uMDAzLS40NjJ6bTMwLjE3MS0uMTAxbDYuNTIxIDM1Ljk2bC0uMDAzLjQ2MmwtOC42OTcgNDQuNzk3bC0uMzQ0LTExLjIwNWwtMS4zNTctNDQuODYyeiIvPjxwYXRoIGZpbGw9IiNGNTg0MUYiIGQ9Im0xNzcuNzg4IDE1MS4wNDZsLS45NzEgMjQuOTc4bC0zMC4yNzQgMjMuNTg3bC02LjEyLTQuMzI0bDYuODYtMzUuMzM1em0tOTkuNDcxIDBsMzAuMzk5IDguOTA2bDYuODYgMzUuMzM1bC02LjEyIDQuMzI0bC0zMC4yNzUtMjMuNTg5eiIvPjxwYXRoIGZpbGw9IiNDMEFDOUQiIGQ9Im02Ny4wMTggMjA4Ljg1OGwzOC43MzIgMTguMzUybC0uMTY0LTcuODM3bDMuMjQxLTIuODQ1aDM4LjMzNGwzLjM1OCAyLjgzNWwtLjI0OCA3LjgzMWwzOC40ODctMTguMjlsLTE4LjcyOCAxNS40NzZsLTIyLjY0NSAxNS41NTNoLTM4Ljg2OWwtMjIuNjMtMTUuNjE3eiIvPjxwYXRoIGZpbGw9IiMxNjE2MTYiIGQ9Im0xNDIuMjA0IDE5My40NzlsNS40NzYgMy44NjlsMy4yMDkgMjUuNjA0bC00LjY0NC0zLjkyMWgtMzYuNDc2bC00LjU1NiA0bDMuMTA0LTI1LjY4MWw1LjQ3OC0zLjg3MXoiLz48cGF0aCBmaWxsPSIjNzYzRTFBIiBkPSJNMjQyLjgxNCAyLjI1TDI1NiA0MS44MDdsLTguMjM1IDM5Ljk5N2w1Ljg2NCA0LjUyM2wtNy45MzUgNi4wNTRsNS45NjQgNC42MDZsLTcuODk3IDcuMTkxbDQuODQ4IDMuNTExbC0xMi44NjYgMTUuMDI2bC01Mi43Ny0xNS4zNjVsLS40NTctLjI0NWwtMzguMDI3LTMyLjA3OHptLTIyOS42MjggMGw5OC4zMjYgNzIuNzc3bC0zOC4wMjggMzIuMDc4bC0uNDU3LjI0NWwtNTIuNzcgMTUuMzY1bC0xMi44NjYtMTUuMDI2bDQuODQ0LTMuNTA4bC03Ljg5Mi03LjE5NGw1Ljk1Mi00LjYwMWwtOC4wNTQtNi4wNzFsNi4wODUtNC41MjZMMCA0MS44MDl6Ii8+PHBhdGggZmlsbD0iI0Y1ODQxRiIgZD0ibTE4MC4zOTIgMTAzLjk5bDU1LjkxMyAxNi4yNzlsMTguMTY1IDU1Ljk4NmgtNDcuOTI0bC0zMy4wMi40MTZsMjQuMDE0LTQ2LjgwOHptLTEwNC43ODQgMGwtMTcuMTUxIDI1Ljg3M2wyNC4wMTcgNDYuODA4bC0zMy4wMDUtLjQxNkgxLjYzMWwxOC4wNjMtNTUuOTg1em04Ny43NzYtNzAuODc4bC0xNS42MzkgNDIuMjM5bC0zLjMxOSA1Ny4wNmwtMS4yNyAxNy44ODVsLS4xMDEgNDUuNjg4aC0zMC4xMTFsLS4wOTgtNDUuNjAybC0xLjI3NC0xNy45ODZsLTMuMzItNTcuMDQ1bC0xNS42MzctNDIuMjM5eiIvPjwvc3ZnPg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://link.metamask.io/dapp/"
  }
];
function getSDKWallets(dappConfig) {
  var sdkWallets = [];
  if (typeof window !== "undefined") {
    sdkWallets.push(new AptosConnectGoogleWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)), new AptosConnectAppleWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)), new AptosConnectGenericWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)));
  }
  return sdkWallets;
}
var WalletCore = function(EventEmitter2) {
  "use strict";
  _inherits(WalletCore2, EventEmitter2);
  function WalletCore2(optInWallets, dappConfig, disableTelemetry) {
    var hideWallets = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [
      "Petra Web"
    ];
    _class_call_check(this, WalletCore2);
    var _this;
    _this = _call_super(this, WalletCore2);
    _this._wallet = null;
    _this._sdkWallets = [];
    _this._standard_wallets = [];
    _this._standard_not_detected_wallets = [];
    _this._standard_wallets_hidden = [];
    _this._network = null;
    _this._connected = false;
    _this._connecting = false;
    _this._account = null;
    _this._optInWallets = [];
    _this._hideWallets = [];
    _this._disableTelemetry = false;
    _this.ga4 = null;
    _this._optInWallets = optInWallets || [];
    _this._hideWallets = hideWallets;
    _this._dappConfig = dappConfig;
    _this._disableTelemetry = disableTelemetry !== null && disableTelemetry !== void 0 ? disableTelemetry : false;
    _this._sdkWallets = getSDKWallets(_this._dappConfig);
    if (!_this._disableTelemetry) {
      _this.ga4 = new GA4();
    }
    _this.fetchExtensionAIP62AptosWallets();
    _this.fetchSDKAIP62AptosWallets();
    _this.appendNotDetectedStandardSupportedWallets();
    return _this;
  }
  _create_class(WalletCore2, [
    {
      key: "fetchExtensionAIP62AptosWallets",
      value: function fetchExtensionAIP62AptosWallets() {
        var _getAptosWallets = d(), aptosWallets = _getAptosWallets.aptosWallets, on = _getAptosWallets.on;
        this.setExtensionAIP62Wallets(aptosWallets);
        if (typeof window === "undefined") return;
        var that = this;
        var removeRegisterListener = on("register", function() {
          var _getAptosWallets2 = d(), aptosWallets2 = _getAptosWallets2.aptosWallets;
          that.setExtensionAIP62Wallets(aptosWallets2);
        });
        var removeUnregisterListener = on("unregister", function() {
          var _getAptosWallets2 = d(), aptosWallets2 = _getAptosWallets2.aptosWallets;
          that.setExtensionAIP62Wallets(aptosWallets2);
        });
      }
    },
    {
      /**
      * Set AIP-62 extension wallets
      *
      * @param extensionwWallets
      */
      key: "setExtensionAIP62Wallets",
      value: function setExtensionAIP62Wallets(extensionwWallets) {
        var _this = this;
        extensionwWallets.map(function(wallet) {
          if (_this.excludeWallet(wallet)) {
            return;
          }
          if (wallet.name === "Rimosafe") {
            return;
          }
          var isValid = i(wallet);
          if (isValid) {
            var index = _this._standard_not_detected_wallets.findIndex(function(notDetctedWallet) {
              return notDetctedWallet.name == wallet.name;
            });
            if (index !== -1) {
              _this._standard_not_detected_wallets.splice(index, 1);
            }
            var alreadyExists = _this._standard_wallets.some(function(w3) {
              return w3.name === wallet.name;
            }) || _this._standard_wallets_hidden.some(function(w3) {
              return w3.name === wallet.name;
            });
            if (!alreadyExists) {
              wallet.readyState = "Installed";
              wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
              if (!_this.hideWallet(wallet)) {
                _this._standard_wallets.push(wallet);
                _this.emit("standardWalletsAdded", wallet);
              } else {
                _this._standard_wallets_hidden.push(wallet);
                _this.emit("standardWalletsHiddenAdded", wallet);
              }
            }
          }
        });
      }
    },
    {
      /**
      * Set AIP-62 SDK wallets
      */
      key: "fetchSDKAIP62AptosWallets",
      value: function fetchSDKAIP62AptosWallets() {
        var _this = this;
        this._sdkWallets.map(function(wallet) {
          if (_this.excludeWallet(wallet)) {
            return;
          }
          var isValid = i(wallet);
          if (isValid) {
            wallet.readyState = "Installed";
            wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
            if (!_this.hideWallet(wallet)) {
              _this._standard_wallets.push(wallet);
            } else {
              _this._standard_wallets_hidden.push(wallet);
            }
          }
        });
      }
    },
    {
      // Aptos native wallets do not have an authenticationFunction property
      key: "isAptosNativeWallet",
      value: function isAptosNativeWallet(wallet) {
        return !("authenticationFunction" in wallet);
      }
    },
    {
      // Since we can't discover AIP-62 wallets that are not installed on the user machine,
      // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.
      // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array
      // when wallet is not installed on the user machine
      key: "appendNotDetectedStandardSupportedWallets",
      value: function appendNotDetectedStandardSupportedWallets() {
        var _this = this;
        var _this__dappConfig;
        var walletRegistry = ((_this__dappConfig = this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.crossChainWallets) ? _to_consumable_array(aptosStandardSupportedWalletList).concat(_to_consumable_array(crossChainStandardSupportedWalletList)) : aptosStandardSupportedWalletList;
        walletRegistry.map(function(supportedWallet) {
          var existingStandardWallet = _this._standard_wallets.find(function(wallet) {
            return wallet.name === supportedWallet.name;
          }) || _this._standard_wallets_hidden.find(function(wallet) {
            return wallet.name === supportedWallet.name;
          });
          if (existingStandardWallet) {
            return;
          }
          if (_this.excludeWallet(supportedWallet)) {
            return;
          }
          if (!existingStandardWallet) {
            supportedWallet.isAptosNativeWallet = !("authenticationFunction" in supportedWallet);
            _this._standard_not_detected_wallets.push(supportedWallet);
            _this.emit("standardNotDetectedWalletAdded", supportedWallet);
          }
        });
      }
    },
    {
      /**
      * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include
      *
      * @param wallet AdapterWallet | AdapterNotDetectedWallet
      * @returns boolean
      */
      key: "excludeWallet",
      value: function excludeWallet(wallet) {
        if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
          return true;
        }
        return false;
      }
    },
    {
      /**
      * A function that hides an AIP-62 compatible wallet from normal display.
      *
      * @param wallet AdapterWallet | AdapterNotDetectedWallet
      * @returns boolean
      */
      key: "hideWallet",
      value: function hideWallet(wallet) {
        return this._hideWallets.length > 0 && this._hideWallets.includes(wallet.name);
      }
    },
    {
      key: "recordEvent",
      value: function recordEvent(eventName, additionalInfo) {
        var _this__wallet, _this__network, _this__network1, _this_ga4;
        (_this_ga4 = this.ga4) === null || _this_ga4 === void 0 ? void 0 : _this_ga4.gtag("event", "wallet_adapter_".concat(eventName), _object_spread({
          wallet: (_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name,
          network: (_this__network = this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
          network_url: (_this__network1 = this._network) === null || _this__network1 === void 0 ? void 0 : _this__network1.url,
          adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
          send_to: "G-GNVVWBL3J9"
        }, additionalInfo));
      }
    },
    {
      /**
      * Helper function to ensure wallet exists
      *
      * @param wallet A wallet
      */
      key: "ensureWalletExists",
      value: function ensureWalletExists(wallet) {
        if (!wallet) {
          throw new WalletNotConnectedError().name;
        }
        if (!(wallet.readyState === "Installed")) throw new WalletNotReadyError("Wallet is not set").name;
      }
    },
    {
      /**
      * Helper function to ensure account exists
      *
      * @param account An account
      */
      key: "ensureAccountExists",
      value: function ensureAccountExists(account) {
        if (!account) {
          throw new WalletAccountError("Account is not set").name;
        }
      }
    },
    {
      key: "setAnsName",
      value: (
        /**
        * Queries and sets ANS name for the current connected wallet account
        */
        function setAnsName() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__network, aptosConfig, aptos, name, error;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (!(((_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.chainId) && _this._account)) return [
                    3,
                    4
                  ];
                  if (_this._account.ansName) return [
                    2
                  ];
                  if (!ChainIdToAnsSupportedNetworkMap[_this._network.chainId] || !isAptosNetwork(_this._network)) {
                    _this._account.ansName = void 0;
                    return [
                      2
                    ];
                  }
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new W(aptosConfig);
                  _state.label = 1;
                case 1:
                  _state.trys.push([
                    1,
                    3,
                    ,
                    4
                  ]);
                  return [
                    4,
                    aptos.ans.getPrimaryName({
                      address: _this._account.address.toString()
                    })
                  ];
                case 2:
                  name = _state.sent();
                  _this._account.ansName = name;
                  return [
                    3,
                    4
                  ];
                case 3:
                  error = _state.sent();
                  console.log("Error setting ANS name ".concat(error));
                  return [
                    3,
                    4
                  ];
                case 4:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      /**
      * Function to cleat wallet adapter data.
      *
      * - Removes current connected wallet state
      * - Removes current connected account state
      * - Removes current connected network state
      * - Removes autoconnect local storage value
      */
      key: "clearData",
      value: function clearData() {
        this._connected = false;
        this.setWallet(null);
        this.setAccount(null);
        this.setNetwork(null);
        removeLocalStorage();
      }
    },
    {
      /**
      * Sets the connected wallet
      *
      * @param wallet A wallet
      */
      key: "setWallet",
      value: function setWallet(wallet) {
        this._wallet = wallet;
      }
    },
    {
      /**
      * Sets the connected account
      *
      * @param account An account
      */
      key: "setAccount",
      value: function setAccount(account) {
        this._account = account;
      }
    },
    {
      /**
      * Sets the connected network
      *
      * @param network A network
      */
      key: "setNetwork",
      value: function setNetwork(network) {
        this._network = network;
      }
    },
    {
      /**
      * Helper function to detect whether a wallet is connected
      *
      * @returns boolean
      */
      key: "isConnected",
      value: function isConnected() {
        return this._connected;
      }
    },
    {
      key: "wallets",
      get: (
        /**
        * Getter to fetch all detected wallets
        */
        function get() {
          return this._standard_wallets;
        }
      )
    },
    {
      key: "hiddenWallets",
      get: (
        /**
        * Getter to fetch all hidden wallets
        */
        function get() {
          return this._standard_wallets_hidden;
        }
      )
    },
    {
      key: "notDetectedWallets",
      get: function get() {
        return this._standard_not_detected_wallets;
      }
    },
    {
      key: "wallet",
      get: (
        /**
        * Getter for the current connected wallet
        *
        * @return wallet info
        * @throws WalletNotSelectedError
        */
        function get() {
          try {
            if (!this._wallet) return null;
            return this._wallet;
          } catch (error) {
            throw new WalletNotSelectedError(error).message;
          }
        }
      )
    },
    {
      key: "account",
      get: (
        /**
        * Getter for the current connected account
        *
        * @return account info
        * @throws WalletAccountError
        */
        function get() {
          try {
            return this._account;
          } catch (error) {
            throw new WalletAccountError(error).message;
          }
        }
      )
    },
    {
      key: "network",
      get: (
        /**
        * Getter for the current wallet network
        *
        * @return network info
        * @throws WalletGetNetworkError
        */
        function get() {
          try {
            return this._network;
          } catch (error) {
            throw new WalletGetNetworkError(error).message;
          }
        }
      )
    },
    {
      key: "connect",
      value: (
        /**
        * Helper function to run some checks before we connect with a wallet.
        *
        * @param walletName. The wallet name we want to connect with.
        */
        function connect(walletName) {
          var _this = this;
          return _async_to_generator(function() {
            var selectedWallet2, uninstalledWallet, parameter, url, ref, location, allDetectedWallets, selectedWallet, _this__wallet;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (isRedirectable()) {
                    selectedWallet2 = _this._standard_not_detected_wallets.find(function(wallet) {
                      return wallet.name === walletName;
                    });
                    if (selectedWallet2) {
                      uninstalledWallet = selectedWallet2;
                      if (uninstalledWallet.deeplinkProvider) {
                        parameter = "";
                        if (uninstalledWallet.name.includes("Phantom")) {
                          url = encodeURIComponent(window.location.href);
                          ref = encodeURIComponent(window.location.origin);
                          parameter = "".concat(url, "?ref=").concat(ref);
                        } else if (uninstalledWallet.name.includes("Metamask")) {
                          parameter = window.location.href;
                        } else {
                          parameter = encodeURIComponent(window.location.href);
                        }
                        location = uninstalledWallet.deeplinkProvider.concat(parameter);
                        window.location.href = location;
                        return [
                          2
                        ];
                      }
                    }
                  }
                  allDetectedWallets = _to_consumable_array(_this._standard_wallets).concat(_to_consumable_array(_this._standard_wallets_hidden));
                  selectedWallet = allDetectedWallets.find(function(wallet) {
                    return wallet.name === walletName;
                  });
                  if (!selectedWallet) return [
                    2
                  ];
                  if (_this._connected && _this._account) {
                    ;
                    if (((_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name) === walletName) throw new WalletConnectionError("".concat(walletName, " wallet is already connected")).message;
                  }
                  return [
                    4,
                    _this.connectWallet(selectedWallet, _async_to_generator(function() {
                      var response;
                      return _ts_generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            return [
                              4,
                              selectedWallet.features["aptos:connect"].connect()
                            ];
                          case 1:
                            response = _state2.sent();
                            if (response.status === r3.REJECTED) {
                              throw new WalletConnectionError("User has rejected the request").message;
                            }
                            return [
                              2,
                              {
                                account: response.args,
                                output: void 0
                              }
                            ];
                        }
                      });
                    }))
                  ];
                case 1:
                  _state.sent();
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signIn",
      value: (
        /**
        * Signs into the wallet by connecting and signing an authentication messages.
        *
        * For more information, visit: https://siwa.aptos.dev
        *
        * @param args
        * @param args.input The AptosSignInInput which defines how the SIWA Message should be constructed
        * @param args.walletName The name of the wallet to sign into
        * @returns The AptosSignInOutput which contains the account and signature information
        */
        function signIn(args) {
          var _this = this;
          return _async_to_generator(function() {
            var input, walletName, allDetectedWallets, selectedWallet;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  input = args.input, walletName = args.walletName;
                  allDetectedWallets = _this._standard_wallets;
                  selectedWallet = allDetectedWallets.find(function(wallet) {
                    return wallet.name === walletName;
                  });
                  if (!selectedWallet) {
                    throw new WalletNotFoundError("Wallet ".concat(walletName, " not found")).message;
                  }
                  if (!selectedWallet.features["aptos:signIn"]) {
                    throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(walletName)).message;
                  }
                  return [
                    4,
                    _this.connectWallet(selectedWallet, _async_to_generator(function() {
                      var response;
                      return _ts_generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            if (!selectedWallet.features["aptos:signIn"]) {
                              throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(selectedWallet.name)).message;
                            }
                            return [
                              4,
                              selectedWallet.features["aptos:signIn"].signIn(input)
                            ];
                          case 1:
                            response = _state2.sent();
                            if (response.status === r3.REJECTED) {
                              throw new WalletConnectionError("User has rejected the request").message;
                            }
                            return [
                              2,
                              {
                                account: response.args.account,
                                output: response.args
                              }
                            ];
                        }
                      });
                    }))
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "connectWallet",
      value: (
        /**
        * Connects a wallet to the dapp.
        * On connect success, we set the current account and the network, and keeping the selected wallet
        * name in LocalStorage to support autoConnect function.
        *
        * @param selectedWallet. The wallet we want to connect.
        * @emit emits "connect" event
        * @throws WalletConnectionError
        */
        function connectWallet(selectedWallet, onConnect) {
          var _this = this;
          return _async_to_generator(function() {
            var _ref, account, output, network, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    4,
                    5,
                    6
                  ]);
                  _this._connecting = true;
                  _this.setWallet(selectedWallet);
                  return [
                    4,
                    onConnect()
                  ];
                case 1:
                  _ref = _state.sent(), account = _ref.account, output = _ref.output;
                  _this.setAccount(account);
                  return [
                    4,
                    selectedWallet.features["aptos:network"].network()
                  ];
                case 2:
                  network = _state.sent();
                  _this.setNetwork(network);
                  return [
                    4,
                    _this.setAnsName()
                  ];
                case 3:
                  _state.sent();
                  setLocalStorage(selectedWallet.name);
                  _this._connected = true;
                  _this.recordEvent("wallet_connect");
                  _this.emit("connect", account);
                  return [
                    2,
                    output
                  ];
                case 4:
                  error = _state.sent();
                  _this.clearData();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletConnectionError(errMsg).message;
                case 5:
                  _this._connecting = false;
                  return [
                    7
                  ];
                case 6:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "disconnect",
      value: (
        /**
        * Disconnect the current connected wallet. On success, we clear the
        * current account, current network and LocalStorage data.
        *
        * @emit emits "disconnect" event
        * @throws WalletDisconnectionError
        */
        function disconnect() {
          var _this = this;
          return _async_to_generator(function() {
            var error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    _this._wallet.features["aptos:disconnect"].disconnect()
                  ];
                case 1:
                  _state.sent();
                  _this.clearData();
                  _this.recordEvent("wallet_disconnect");
                  _this.emit("disconnect");
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletDisconnectionError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signAndSubmitTransaction",
      value: (
        /**
        * Signs and submits a transaction to chain
        *
        * @param transactionInput InputTransactionData
        * @returns AptosSignAndSubmitTransactionOutput
        */
        function signAndSubmitTransaction(transactionInput) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__dappConfig, ref, shouldUseTxnSubmitter, _transactionInput_options, _transactionInput_options1, aptosConfig2, aptos2, transaction2, signAndSubmitTransactionMethod, response3, response2, aptosConfig, aptos, transaction, signTransactionResponse, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    9,
                    ,
                    10
                  ]);
                  if ("function" in transactionInput.data) {
                    if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
                      throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
                    }
                    if (transactionInput.data.function === "0x1::code::publish_package_txn") {
                      ;
                      ref = handlePublishPackageTransaction(transactionInput), transactionInput.data.functionArguments[0] = ref.metadataBytes, transactionInput.data.functionArguments[1] = ref.byteCode, ref;
                    }
                  }
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_and_submit_transaction");
                  shouldUseTxnSubmitter = !!(((_this__dappConfig = _this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.transactionSubmitter) || transactionInput.transactionSubmitter);
                  if (!(_this._wallet.features["aptos:signAndSubmitTransaction"] && !shouldUseTxnSubmitter)) return [
                    3,
                    5
                  ];
                  if (!(_this._wallet.features["aptos:signAndSubmitTransaction"].version !== "1.1.0")) return [
                    3,
                    3
                  ];
                  aptosConfig2 = getAptosConfig(_this._network, _this._dappConfig);
                  aptos2 = new W(aptosConfig2);
                  return [
                    4,
                    aptos2.transaction.build.simple({
                      sender: _this._account.address.toString(),
                      data: transactionInput.data,
                      options: transactionInput.options
                    })
                  ];
                case 1:
                  transaction2 = _state.sent();
                  signAndSubmitTransactionMethod = _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction;
                  return [
                    4,
                    signAndSubmitTransactionMethod(transaction2)
                  ];
                case 2:
                  response3 = _state.sent();
                  if (response3.status === r3.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response3.args
                  ];
                case 3:
                  return [
                    4,
                    _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction({
                      payload: transactionInput.data,
                      gasUnitPrice: (_transactionInput_options = transactionInput.options) === null || _transactionInput_options === void 0 ? void 0 : _transactionInput_options.gasUnitPrice,
                      maxGasAmount: (_transactionInput_options1 = transactionInput.options) === null || _transactionInput_options1 === void 0 ? void 0 : _transactionInput_options1.maxGasAmount
                    })
                  ];
                case 4:
                  response2 = _state.sent();
                  if (response2.status === r3.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response2.args
                  ];
                case 5:
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new W(aptosConfig);
                  return [
                    4,
                    aptos.transaction.build.simple({
                      sender: _this._account.address.toString(),
                      data: transactionInput.data,
                      options: transactionInput.options,
                      withFeePayer: shouldUseTxnSubmitter
                    })
                  ];
                case 6:
                  transaction = _state.sent();
                  return [
                    4,
                    _this.signTransaction({
                      transactionOrPayload: transaction
                    })
                  ];
                case 7:
                  signTransactionResponse = _state.sent();
                  return [
                    4,
                    _this.submitTransaction({
                      transaction,
                      senderAuthenticator: signTransactionResponse.authenticator,
                      transactionSubmitter: transactionInput.transactionSubmitter,
                      pluginParams: transactionInput.pluginParams
                    })
                  ];
                case 8:
                  response = _state.sent();
                  return [
                    2,
                    {
                      hash: response.hash
                    }
                  ];
                case 9:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignAndSubmitMessageError(errMsg).message;
                case 10:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signTransaction",
      value: (
        /**
        * Signs a transaction
        *
        * This method supports 2 input types -
        * 1. A raw transaction that was already built by the dapp,
        * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing
        *
        * @param transactionOrPayload AnyRawTransaction | InputTransactionData
        * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer
        * @param options optional. Transaction options
        *
        * @returns AccountAuthenticator
        */
        function signTransaction(args) {
          var _this = this;
          return _async_to_generator(function() {
            var transactionOrPayload, asFeePayer, _this__wallet_features_aptossignTransaction, _this__wallet, response, _transactionOrPayload_options, _transactionOrPayload_options1, _transactionOrPayload_options2, _transactionOrPayload_options3, _transactionOrPayload_options4, _this__wallet1, signTransactionV1_1StandardInput, walletSignTransactionMethod, response1, _this__wallet2, aptosConfig, aptos, transaction, response2, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  transactionOrPayload = args.transactionOrPayload, asFeePayer = args.asFeePayer;
                  _state.label = 1;
                case 1:
                  _state.trys.push([
                    1,
                    9,
                    ,
                    10
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_transaction");
                  if (!("rawTransaction" in transactionOrPayload)) return [
                    3,
                    3
                  ];
                  return [
                    4,
                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.features["aptos:signTransaction"].signTransaction(transactionOrPayload, asFeePayer)
                  ];
                case 2:
                  response = _state.sent();
                  if (response.status === r3.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response.args,
                      rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()
                    }
                  ];
                case 3:
                  if (!(((_this__wallet_features_aptossignTransaction = _this._wallet.features["aptos:signTransaction"]) === null || _this__wallet_features_aptossignTransaction === void 0 ? void 0 : _this__wallet_features_aptossignTransaction.version) === "1.1.0")) return [
                    3,
                    5
                  ];
                  signTransactionV1_1StandardInput = {
                    payload: transactionOrPayload.data,
                    expirationTimestamp: (_transactionOrPayload_options = transactionOrPayload.options) === null || _transactionOrPayload_options === void 0 ? void 0 : _transactionOrPayload_options.expirationTimestamp,
                    expirationSecondsFromNow: (_transactionOrPayload_options1 = transactionOrPayload.options) === null || _transactionOrPayload_options1 === void 0 ? void 0 : _transactionOrPayload_options1.expirationSecondsFromNow,
                    gasUnitPrice: (_transactionOrPayload_options2 = transactionOrPayload.options) === null || _transactionOrPayload_options2 === void 0 ? void 0 : _transactionOrPayload_options2.gasUnitPrice,
                    maxGasAmount: (_transactionOrPayload_options3 = transactionOrPayload.options) === null || _transactionOrPayload_options3 === void 0 ? void 0 : _transactionOrPayload_options3.maxGasAmount,
                    sequenceNumber: (_transactionOrPayload_options4 = transactionOrPayload.options) === null || _transactionOrPayload_options4 === void 0 ? void 0 : _transactionOrPayload_options4.accountSequenceNumber,
                    sender: transactionOrPayload.sender ? {
                      address: l.from(transactionOrPayload.sender)
                    } : void 0
                  };
                  walletSignTransactionMethod = (_this__wallet1 = _this._wallet) === null || _this__wallet1 === void 0 ? void 0 : _this__wallet1.features["aptos:signTransaction"].signTransaction;
                  return [
                    4,
                    walletSignTransactionMethod(signTransactionV1_1StandardInput)
                  ];
                case 4:
                  response1 = _state.sent();
                  if (response1.status === r3.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response1.args.authenticator,
                      rawTransaction: response1.args.rawTransaction.bcsToBytes()
                    }
                  ];
                case 5:
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new W(aptosConfig);
                  return [
                    4,
                    aptos.transaction.build.simple({
                      sender: _this._account.address,
                      data: transactionOrPayload.data,
                      options: transactionOrPayload.options,
                      withFeePayer: transactionOrPayload.withFeePayer
                    })
                  ];
                case 6:
                  transaction = _state.sent();
                  return [
                    4,
                    (_this__wallet2 = _this._wallet) === null || _this__wallet2 === void 0 ? void 0 : _this__wallet2.features["aptos:signTransaction"].signTransaction(transaction, asFeePayer)
                  ];
                case 7:
                  response2 = _state.sent();
                  if (response2.status === r3.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response2.args,
                      rawTransaction: transaction.bcsToBytes()
                    }
                  ];
                case 8:
                  return [
                    3,
                    10
                  ];
                case 9:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignTransactionError(errMsg).message;
                case 10:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signMessage",
      value: (
        /**
        * Sign a message (doesnt submit to chain).
        *
        * @param message - AptosSignMessageInput
        *
        * @return response from the wallet's signMessage function
        * @throws WalletSignMessageError
        */
        function signMessage(message) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptossignMessage, _this__wallet, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.recordEvent("sign_message");
                  return [
                    4,
                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : (_this__wallet_features_aptossignMessage = _this__wallet.features["aptos:signMessage"]) === null || _this__wallet_features_aptossignMessage === void 0 ? void 0 : _this__wallet_features_aptossignMessage.signMessage(message)
                  ];
                case 1:
                  response = _state.sent();
                  if (response.status === r3.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response.args
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignMessageError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "submitTransaction",
      value: (
        /**
        * Submits transaction to chain
        *
        * @param transaction - InputSubmitTransactionData
        * @returns PendingTransactionResponse
        */
        function submitTransaction(transaction) {
          var _this = this;
          return _async_to_generator(function() {
            var additionalSignersAuthenticators, transactionType, aptosConfig, aptos, multiAgentTxn, errMsg;
            return _ts_generator(this, function(_state) {
              try {
                _this.ensureWalletExists(_this._wallet);
                additionalSignersAuthenticators = transaction.additionalSignersAuthenticators;
                transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
                _this.recordEvent("submit_transaction", {
                  transaction_type: transactionType
                });
                aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                aptos = new W(aptosConfig);
                if (additionalSignersAuthenticators !== void 0) {
                  multiAgentTxn = _object_spread_props(_object_spread({}, transaction), {
                    additionalSignersAuthenticators
                  });
                  return [
                    2,
                    aptos.transaction.submit.multiAgent(multiAgentTxn)
                  ];
                } else {
                  return [
                    2,
                    aptos.transaction.submit.simple(transaction)
                  ];
                }
              } catch (error) {
                errMsg = generalizedErrorMessage(error);
                throw new WalletSubmitTransactionError(errMsg).message;
              }
              return [
                2
              ];
            });
          })();
        }
      )
    },
    {
      key: "onAccountChange",
      value: (
        /**
        Event for when account has changed on the wallet
        @return the new account info
        @throws WalletAccountChangeError
        */
        function onAccountChange() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptosonAccountChange, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    (_this__wallet_features_aptosonAccountChange = _this._wallet.features["aptos:onAccountChange"]) === null || _this__wallet_features_aptosonAccountChange === void 0 ? void 0 : _this__wallet_features_aptosonAccountChange.onAccountChange(function() {
                      var _ref = _async_to_generator(function(data) {
                        return _ts_generator(this, function(_state2) {
                          switch (_state2.label) {
                            case 0:
                              _this.setAccount(data);
                              return [
                                4,
                                _this.setAnsName()
                              ];
                            case 1:
                              _state2.sent();
                              _this.recordEvent("account_change");
                              _this.emit("accountChange", _this._account);
                              return [
                                2
                              ];
                          }
                        });
                      });
                      return function(data) {
                        return _ref.apply(this, arguments);
                      };
                    }())
                  ];
                case 1:
                  _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletAccountChangeError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "onNetworkChange",
      value: (
        /**
        Event for when network has changed on the wallet
        @return the new network info
        @throws WalletNetworkChangeError
        */
        function onNetworkChange() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptosonNetworkChange, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    (_this__wallet_features_aptosonNetworkChange = _this._wallet.features["aptos:onNetworkChange"]) === null || _this__wallet_features_aptosonNetworkChange === void 0 ? void 0 : _this__wallet_features_aptosonNetworkChange.onNetworkChange(function() {
                      var _ref = _async_to_generator(function(data) {
                        return _ts_generator(this, function(_state2) {
                          switch (_state2.label) {
                            case 0:
                              _this.setNetwork(data);
                              return [
                                4,
                                _this.setAnsName()
                              ];
                            case 1:
                              _state2.sent();
                              _this.emit("networkChange", _this._network);
                              return [
                                2
                              ];
                          }
                        });
                      });
                      return function(data) {
                        return _ref.apply(this, arguments);
                      };
                    }())
                  ];
                case 1:
                  _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletNetworkChangeError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "changeNetwork",
      value: (
        /**
        * Sends a change network request to the wallet to change the connected network
        *
        * @param network - Network
        * @returns AptosChangeNetworkOutput
        */
        function changeNetwork(network) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__network, chainId, _tmp, networkInfo, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    6,
                    ,
                    7
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.recordEvent("change_network_request", {
                    from: (_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
                    to: network
                  });
                  if (!(network === e.DEVNET)) return [
                    3,
                    2
                  ];
                  return [
                    4,
                    fetchDevnetChainId()
                  ];
                case 1:
                  _tmp = _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  _tmp = r[network];
                  _state.label = 3;
                case 3:
                  chainId = _tmp;
                  networkInfo = {
                    name: network,
                    chainId
                  };
                  if (!_this._wallet.features["aptos:changeNetwork"]) return [
                    3,
                    5
                  ];
                  return [
                    4,
                    _this._wallet.features["aptos:changeNetwork"].changeNetwork(networkInfo)
                  ];
                case 4:
                  response = _state.sent();
                  if (response.status === r3.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response.args
                  ];
                case 5:
                  throw new WalletChangeNetworkError("".concat(_this._wallet.name, " does not support changing network request")).message;
                case 6:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletChangeNetworkError(errMsg).message;
                case 7:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signMessageAndVerify",
      value: (
        /**
        * Signs a message and verifies the signer
        * @param message - AptosSignMessageInput
        * @returns boolean
        */
        function signMessageAndVerify(message) {
          var _this = this;
          return _async_to_generator(function() {
            var response, aptosConfig, signingMessage, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    4,
                    ,
                    5
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_message_and_verify");
                  return [
                    4,
                    _this._wallet.features["aptos:signMessage"].signMessage(message)
                  ];
                case 1:
                  response = _state.sent();
                  if (response.status === r3.REJECTED) {
                    throw new WalletConnectionError("Failed to sign a message").message;
                  }
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  signingMessage = new TextEncoder().encode(response.args.fullMessage);
                  if (!("verifySignatureAsync" in _this._account.publicKey)) return [
                    3,
                    3
                  ];
                  return [
                    4,
                    _this._account.publicKey.verifySignatureAsync({
                      aptosConfig,
                      message: signingMessage,
                      signature: response.args.signature,
                      options: {
                        throwErrorWithReason: true
                      }
                    })
                  ];
                case 2:
                  return [
                    2,
                    _state.sent()
                  ];
                case 3:
                  return [
                    2,
                    _this._account.publicKey.verifySignature({
                      message: signingMessage,
                      signature: response.args.signature
                    })
                  ];
                case 4:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignMessageAndVerifyError(errMsg).message;
                case 5:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    }
  ]);
  return WalletCore2;
}(import_eventemitter3.default);
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i4 = 0; i4 < cleanups.length; i4++) {
          const cleanup = cleanups[i4];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i4], null);
          }
        }
      };
    }
  };
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use = React2[" use ".trim().toString()];
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
  return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React2.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React2.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props2);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a8, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp.call(b3, prop))
      __defNormalProp(a8, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a8, prop, b3[prop]);
    }
  return a8;
};
var __spreadProps = (a8, b3) => __defProps(a8, __getOwnPropDescs(b3));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e14) {
        reject(e14);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e14) {
        reject(e14);
      }
    };
    var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var DEFAULT_CONTEXT = {
  connected: false
};
var WalletContext = (0, import_react2.createContext)(
  DEFAULT_CONTEXT
);
function useWallet() {
  const context = (0, import_react2.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  optInWallets,
  hideWallets,
  autoConnect = false,
  dappConfig,
  disableTelemetry = false,
  onError
}) => {
  const didAttemptAutoConnectRef = (0, import_react.useRef)(false);
  const initialLoadCompletedRef = (0, import_react.useRef)(false);
  const [{ account, network, connected, wallet }, setState2] = (0, import_react.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [walletCore, setWalletCore] = (0, import_react.useState)();
  const [wallets, setWallets] = (0, import_react.useState)([]);
  const [hiddenWallets, setHiddenWallets] = (0, import_react.useState)([]);
  const [notDetectedWallets, setNotDetectedWallets] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    const walletCore2 = new WalletCore(
      optInWallets,
      dappConfig,
      disableTelemetry,
      hideWallets ? hideWallets : ["Petra Web"]
    );
    setWalletCore(walletCore2);
  }, []);
  (0, import_react.useEffect)(() => {
    var _a, _b, _c;
    setWallets((_a = walletCore == null ? void 0 : walletCore.wallets) != null ? _a : []);
    setHiddenWallets((_b = walletCore == null ? void 0 : walletCore.hiddenWallets) != null ? _b : []);
    setNotDetectedWallets((_c = walletCore == null ? void 0 : walletCore.notDetectedWallets) != null ? _c : []);
  }, [walletCore]);
  (0, import_react.useEffect)(() => {
    if (didAttemptAutoConnectRef.current || !(walletCore == null ? void 0 : walletCore.wallets.length)) {
      return;
    }
    if (!autoConnect) {
      if (!initialLoadCompletedRef.current) {
        initialLoadCompletedRef.current = true;
        setIsLoading(false);
      }
      return;
    }
    const walletName = localStorage.getItem("AptosWalletName");
    if (!walletName) {
      didAttemptAutoConnectRef.current = true;
      if (!initialLoadCompletedRef.current) {
        initialLoadCompletedRef.current = true;
        setIsLoading(false);
      }
      return;
    }
    const selectedWallet = walletCore.wallets.find(
      (e14) => e14.name === walletName
    );
    if (!selectedWallet || selectedWallet.readyState !== WalletReadyState.Installed) {
      if (!initialLoadCompletedRef.current) {
        initialLoadCompletedRef.current = true;
        setIsLoading(false);
      }
      return;
    }
    didAttemptAutoConnectRef.current = true;
    if (!connected) {
      (() => __async(void 0, null, function* () {
        try {
          let shouldConnect = true;
          if (typeof autoConnect === "function") {
            shouldConnect = yield autoConnect(walletCore, selectedWallet);
          } else {
            shouldConnect = autoConnect;
          }
          if (shouldConnect) yield connect(walletName);
        } catch (error) {
          if (onError) onError(error);
          return Promise.reject(error);
        } finally {
          initialLoadCompletedRef.current = true;
          setIsLoading(false);
        }
      }))();
    } else {
      initialLoadCompletedRef.current = true;
      setIsLoading(false);
    }
  }, [autoConnect, wallets]);
  const connect = (walletName) => __async(void 0, null, function* () {
    try {
      setIsLoading(true);
      yield walletCore == null ? void 0 : walletCore.connect(walletName);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  });
  const signIn = (args) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      setIsLoading(true);
      return yield walletCore == null ? void 0 : walletCore.signIn(args);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  });
  const disconnect = () => __async(void 0, null, function* () {
    try {
      yield walletCore == null ? void 0 : walletCore.disconnect();
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signAndSubmitTransaction = (transaction) => __async(void 0, null, function* () {
    try {
      if (!walletCore) {
        throw new Error("WalletCore is not initialized");
      }
      return yield walletCore.signAndSubmitTransaction(transaction);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signTransaction = (args) => __async(void 0, null, function* () {
    const { transactionOrPayload, asFeePayer, options } = args;
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore.signTransaction({
        transactionOrPayload,
        asFeePayer
      });
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const submitTransaction = (transaction) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.submitTransaction(transaction);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signMessage = (message) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.signMessage(message);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signMessageAndVerify = (message) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.signMessageAndVerify(message);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const changeNetwork = (network2) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.changeNetwork(network2);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const handleConnect = () => {
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        connected: true,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: (walletCore == null ? void 0 : walletCore.wallet) || null
      });
    });
  };
  const handleAccountChange = (0, import_react.useCallback)(() => {
    if (!connected) return;
    if (!(walletCore == null ? void 0 : walletCore.wallet)) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        account: (walletCore == null ? void 0 : walletCore.account) || null
      });
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react.useCallback)(() => {
    if (!connected) return;
    if (!(walletCore == null ? void 0 : walletCore.wallet)) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        network: (walletCore == null ? void 0 : walletCore.network) || null
      });
    });
  }, [connected]);
  (0, import_react.useEffect)(() => {
    if (connected) {
      walletCore == null ? void 0 : walletCore.onAccountChange();
      walletCore == null ? void 0 : walletCore.onNetworkChange();
    }
  }, [connected]);
  const handleDisconnect = () => {
    if (!connected) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        connected: false,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: null
      });
    });
  };
  const handleStandardWalletsAdded = (standardWallet) => {
    const existingWalletIndex = wallets.findIndex(
      (wallet2) => wallet2.name == standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setWallets((wallets2) => [
        ...wallets2.slice(0, existingWalletIndex),
        standardWallet,
        ...wallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setWallets((wallets2) => [...wallets2, standardWallet]);
    }
  };
  const handleStandardWalletsHiddenAdded = (standardWallet) => {
    const existingWalletIndex = hiddenWallets.findIndex(
      (wallet2) => wallet2.name === standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setHiddenWallets((hiddenWallets2) => [
        ...hiddenWallets2.slice(0, existingWalletIndex),
        standardWallet,
        ...hiddenWallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setHiddenWallets((hiddenWallets2) => [...hiddenWallets2, standardWallet]);
    }
  };
  const handleStandardNotDetectedWalletsAdded = (notDetectedWallet) => {
    const existingWalletIndex = wallets.findIndex(
      (wallet2) => wallet2.name == notDetectedWallet.name
    );
    if (existingWalletIndex !== -1) {
      setNotDetectedWallets((wallets2) => [
        ...wallets2.slice(0, existingWalletIndex),
        notDetectedWallet,
        ...wallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setNotDetectedWallets((wallets2) => [...wallets2, notDetectedWallet]);
    }
  };
  (0, import_react.useEffect)(() => {
    walletCore == null ? void 0 : walletCore.on("connect", handleConnect);
    walletCore == null ? void 0 : walletCore.on("accountChange", handleAccountChange);
    walletCore == null ? void 0 : walletCore.on("networkChange", handleNetworkChange);
    walletCore == null ? void 0 : walletCore.on("disconnect", handleDisconnect);
    walletCore == null ? void 0 : walletCore.on("standardWalletsAdded", handleStandardWalletsAdded);
    walletCore == null ? void 0 : walletCore.on(
      "standardWalletsHiddenAdded",
      handleStandardWalletsHiddenAdded
    );
    walletCore == null ? void 0 : walletCore.on(
      "standardNotDetectedWalletAdded",
      handleStandardNotDetectedWalletsAdded
    );
    return () => {
      walletCore == null ? void 0 : walletCore.off("connect", handleConnect);
      walletCore == null ? void 0 : walletCore.off("accountChange", handleAccountChange);
      walletCore == null ? void 0 : walletCore.off("networkChange", handleNetworkChange);
      walletCore == null ? void 0 : walletCore.off("disconnect", handleDisconnect);
      walletCore == null ? void 0 : walletCore.off("standardWalletsAdded", handleStandardWalletsAdded);
      walletCore == null ? void 0 : walletCore.off(
        "standardWalletsHiddenAdded",
        handleStandardWalletsHiddenAdded
      );
      walletCore == null ? void 0 : walletCore.off(
        "standardNotDetectedWalletAdded",
        handleStandardNotDetectedWalletsAdded
      );
    };
  }, [wallets, account]);
  return (0, import_jsx_runtime2.jsx)(
    WalletContext.Provider,
    {
      value: {
        connect,
        signIn,
        disconnect,
        signAndSubmitTransaction,
        signTransaction,
        signMessage,
        signMessageAndVerify,
        changeNetwork,
        submitTransaction,
        account,
        network,
        connected,
        wallet,
        wallets,
        notDetectedWallets,
        hiddenWallets,
        isLoading
      },
      children
    }
  );
};
var LinkGraphic = (0, import_react4.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime3.jsx)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "102",
        height: "132",
        viewBox: "0 0 102 132",
        fill: "none"
      }, props), {
        children: (0, import_jsx_runtime3.jsxs)("g", { stroke: "currentColor", strokeMiterlimit: "10", children: [
          (0, import_jsx_runtime3.jsx)("path", { d: "M59.633 80.66c11.742-2.814 17.48-7.018 20.925-13.254l17.518-31.69c6.257-11.317 2.142-25.55-9.189-31.798C82.737.53 75.723.188 69.593 2.398M60.7 69.565a14.09 14.09 0 0 1-6.907-1.767l-.228-.108" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "m52.365 41.075 12.507-22.627a14.146 14.146 0 0 1 4.727-5.062M32.407 118.619a14.139 14.139 0 0 1-7.034-1.768c-6.857-3.78-9.353-12.402-5.561-19.25l16.634-30.1a14.097 14.097 0 0 1 4.518-4.923" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M41.211 78.85c11.332 6.248 25.583 2.14 31.84-9.177l17.518-31.691c6.256-11.317 2.142-25.55-9.19-31.798-6.085-3.357-13.018-3.724-19.104-1.59A23.31 23.31 0 0 0 49.541 15.36L36.863 38.298l7.989 5.036 12.506-22.627c3.786-6.848 12.419-9.34 19.276-5.554 6.856 3.78 9.353 12.402 5.561 19.25l-16.634 30.1c-3.785 6.848-12.418 9.341-19.275 5.555l-5.075 8.791ZM29.5 130.447c12.361-1.37 19.2-6.994 22.966-13.804l12.678-22.936-8.305-5.239" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "m55.72 61.947-.442.764 5.511-9.55c-6.901-3.806-18.65-3.124-27.105.814M44.85 43.523l7.635-2.486m-4.221 23.264 7.217-1.723m-9.316 7.517 7.59-2.405m-.562-12.156 7.508-2.221m10.136-51.32L62.761 4.43M49.642 90.778l7.514-2.26m.474 7.448 7.514-2.26m-50.306-60.13c7.135 0 12.918-5.776 12.918-12.9 0-7.126-5.783-12.902-12.918-12.902-7.134 0-12.917 5.776-12.917 12.901s5.783 12.901 12.918 12.901Z" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M15.724 7.774h3.197c7.135 0 12.918 5.776 12.918 12.901 0 7.126-5.783 12.901-12.918 12.901h-3.425m65.112 66.935h3.198c7.135 0 12.918 5.775 12.918 12.901 0 7.125-5.783 12.9-12.918 12.9h-3.425" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M79.717 126.312c7.135 0 12.918-5.775 12.918-12.9s-5.783-12.901-12.918-12.901c-7.134 0-12.917 5.776-12.917 12.901s5.783 12.9 12.917 12.9ZM53.281 55.414c-11.33-6.248-25.582-2.14-31.839 9.177L3.924 96.281c-6.257 11.318-2.142 25.55 9.189 31.799 11.331 6.248 25.582 2.139 31.839-9.177l12.677-22.937-7.988-5.036-12.507 22.627c-3.785 6.848-12.418 9.341-19.275 5.554-6.857-3.781-9.353-12.402-5.561-19.25l16.633-30.1c3.786-6.848 12.419-9.341 19.276-5.555l5.074-8.792Z" })
        ] })
      })
    );
  }
);
LinkGraphic.displayName = "LinkGraphic";
var WalletGraphic = (0, import_react5.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime4.jsxs)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "128",
        height: "102",
        viewBox: "0 0 128 102",
        fill: "none"
      }, props), {
        children: [
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              fill: "currentColor",
              d: "m.96 25.93-.36-.35.36.85v-.5Zm7.79-7.81v-.5h-.21l-.15.15.36.35ZM1.3 26.28l7.79-7.8-.7-.71-7.8 7.8.7.71Zm7.44-7.66H10v-1H8.75v1Zm29.22 6.8h-37v1h37.01v-1Z"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M82.25 26.08c0 12.25-9.92 22.2-22.14 22.2a22.17 22.17 0 0 1-22.14-22.2H1.1v74.82h118.02V26.08H82.25Zm44.33 67.02h.33V18.27h-5.7"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M74.52 42.92a22.4 22.4 0 0 1-11.43 3.3 22.5 22.5 0 0 1-22.46-22.53H9.52M119.22 101l7.78-7.82m-7.88-67.1 7.79-7.81m-44.78 7.72 2.73-2.3m-46.89 2.39 2.39-2.4"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M9.86 23.69V5.72h107.97v18.04H84.65"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M117.83 20.46h3.39V1H13.25v4.72M9.36 23.69h31.78"
            }
          )
        ]
      })
    );
  }
);
WalletGraphic.displayName = "WalletGraphic";
var Web3Graphic = (0, import_react6.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime5.jsx)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "142",
        height: "108",
        viewBox: "0 0 142 108",
        fill: "none"
      }, props), {
        children: (0, import_jsx_runtime5.jsxs)("g", { stroke: "currentColor", strokeLinejoin: "round", children: [
          (0, import_jsx_runtime5.jsx)("path", { d: "m91.26 35.8.06-10.46L71.3 1v10.53L87 30.5m-36.11 5.24-.06-10.45L71.3 1v10.53L55 30.5" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.55V49.17L50.83 25.3l.06 10.45L57 42.5m14 17.05V49.18l20.33-23.84-.07 10.45L86 42M1 59.68l.22-9.07 35.33-19.8-.1 9L9 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M36.55 30.8s-.08 5.92-.1 9l.1-9ZM71 59.51v-9.07L36.55 30.8l-.1 9L63.5 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07L36.44 70.78l-.1 9.14L55.5 68.5" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M1.22 50.6a77387.2 77387.2 0 0 0 35.22 20.18l-.1 9.14L1 59.68l.23-9.07h-.01ZM141 59.68l-.23-9.07-35.33-19.8.11 9L133 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "m105.44 30.8.11 9-.1-9Z" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07l34.44-19.64.11 9L78.5 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07l34.56 20.34.1 9.14L87 69" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M140.78 50.6a78487.3 78487.3 0 0 1-35.23 20.18l.11 9.14L141 59.68l-.23-9.07ZM50.83 80.15l.06-6.33 20.1-23.38H71v9.26L55 79" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71.3 97.6 50.89 73.81l-.06 9.33L71.3 107v-9.4Zm20.03-14.5-.07-9.33L71 50.44v9.26l16 18.8" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "m71.3 97.6 19.96-23.83.06 9.33L71.3 107v-9.4Z" })
        ] })
      })
    );
  }
);
Web3Graphic.displayName = "Web3Graphic";
function createHeadlessComponent(displayName, elementType, props) {
  const component = (0, import_react7.forwardRef)(({ className, asChild, children }, ref) => {
    const Component = asChild ? Slot : elementType;
    const _a = typeof props === "function" ? props(displayName) : props != null ? props : {}, { children: defaultChildren } = _a, resolvedProps = __objRest(_a, ["children"]);
    const resolvedChildren = (
      /**
       * Use props' default children if no children are set in the component element's children and when asChild is true.
       */
      asChild && (0, import_react7.isValidElement)(children) && !children.props.children ? (0, import_react7.cloneElement)(children, {}, defaultChildren) : children != null ? children : defaultChildren
    );
    return (
      /**
       * Due to the complexity of the types at play, TypeScript reports the
       * following error for our JSX below:
       *
       * `Expression produces a union type that is too complex to represent.`
       *
       * We can safely ignore this error and retain accurate return types for
       * consumers of this function. The only drawback is that type-checking is
       * ignored for the JSX block below.
       */
      // @ts-expect-error
      (0, import_jsx_runtime6.jsx)(Component, __spreadProps(__spreadValues({ ref, className }, resolvedProps), { children: resolvedChildren }))
    );
  });
  component.displayName = displayName;
  return component;
}
var EXPLORE_ECOSYSTEM_URL = "https://aptosnetwork.com/ecosystem/directory/category/defi";
var AboutAptosConnectContext = (0, import_react3.createContext)(null);
function useAboutAptosConnectContext(displayName) {
  const context = (0, import_react3.useContext)(AboutAptosConnectContext);
  if (!context) {
    throw new Error(
      `\`${displayName}\` must be used within \`AboutAptosConnect\``
    );
  }
  return context;
}
var educationScreens = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Petra Web is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
        "Petra Web lets you take one account across any application built on Aptos.",
        " ",
        (0, import_jsx_runtime7.jsx)(
          "a",
          {
            href: EXPLORE_ECOSYSTEM_URL,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }
        ),
        "."
      ] })
    })
  }
];
var educationScreenIndicators = Array(educationScreens.length).fill(null).map(
  (_2, index) => createHeadlessComponent(
    "AboutAptosConnect.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutAptosConnectContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react3.useState)(0);
  const currentEducationScreen = (0, import_react3.useMemo)(
    () => educationScreens.map((screen, i4) => __spreadProps(__spreadValues({}, screen), {
      screenIndex: i4,
      totalScreens: educationScreens.length,
      screenIndicators: educationScreenIndicators,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime7.jsx)(AboutAptosConnectContext.Provider, { value: { screenIndex, setScreenIndex }, children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen) });
};
Root.displayName = "AboutAptosConnect";
var Trigger = createHeadlessComponent(
  "AboutAptosConnect.Trigger",
  "button",
  (displayName) => {
    const context = useAboutAptosConnectContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutAptosConnect = Object.assign(Root, {
  Trigger
});
var EXPLORE_ECOSYSTEM_URL2 = "https://aptosnetwork.com/ecosystem/directory/category/defi";
var AboutPetraWebContext = (0, import_react8.createContext)(null);
function useAboutPetraWebContext(displayName) {
  const context = (0, import_react8.useContext)(AboutPetraWebContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`AboutPetraWeb\``);
  }
  return context;
}
var educationScreens2 = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Petra Web is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
        "Petra Web lets you take one account across any application built on Aptos.",
        " ",
        (0, import_jsx_runtime8.jsx)(
          "a",
          {
            href: EXPLORE_ECOSYSTEM_URL2,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }
        ),
        "."
      ] })
    })
  }
];
var educationScreenIndicators2 = Array(educationScreens2.length).fill(null).map(
  (_2, index) => createHeadlessComponent(
    "AboutPetraWeb.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutPetraWebContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root2 = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react8.useState)(0);
  const currentEducationScreen = (0, import_react8.useMemo)(
    () => educationScreens2.map((screen, i4) => __spreadProps(__spreadValues({}, screen), {
      screenIndex: i4,
      totalScreens: educationScreens2.length,
      screenIndicators: educationScreenIndicators2,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens2.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime8.jsx)(AboutPetraWebContext.Provider, { value: { screenIndex, setScreenIndex }, children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen) });
};
Root2.displayName = "AboutPetraWeb";
var Trigger2 = createHeadlessComponent(
  "AboutPetraWeb.Trigger",
  "button",
  (displayName) => {
    const context = useAboutPetraWebContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutPetraWeb = Object.assign(Root2, {
  Trigger: Trigger2
});
var SmallAptosLogo = (0, import_react10.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime9.jsx)(
    "svg",
    __spreadProps(__spreadValues({
      ref,
      width: "12",
      height: "12",
      viewBox: "0 0 12 12",
      fill: "none"
    }, props), {
      children: (0, import_jsx_runtime9.jsx)(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M6 12C9.31371 12 12 9.31371 12 6C12 2.68629 9.31371 0 6 0C2.68629 0 0 2.68629 0 6C0 9.31371 2.68629 12 6 12ZM7.17547 3.67976C7.13401 3.72309 7.07649 3.74757 7.01648 3.74757H3.00775C3.69185 2.83824 4.77995 2.25 6.00569 2.25C7.23142 2.25 8.31953 2.83824 9.00362 3.74757H8.28524C8.20824 3.74757 8.13498 3.71468 8.08401 3.65701L7.81608 3.35416C7.77618 3.30896 7.71882 3.28308 7.6585 3.28308H7.6454C7.58805 3.28308 7.53318 3.30646 7.49343 3.34792L7.17547 3.67976ZM8.05656 4.75897H7.39569C7.31869 4.75897 7.24543 4.72593 7.19447 4.66842L6.92638 4.36557C6.88647 4.32036 6.82896 4.29465 6.7688 4.29465C6.70863 4.29465 6.65112 4.32052 6.61121 4.36557L6.38131 4.6254C6.30603 4.71034 6.19801 4.75913 6.08454 4.75913H2.46703C2.36401 5.05278 2.29683 5.36296 2.27002 5.68467H5.68505C5.74506 5.68467 5.80258 5.66019 5.84404 5.61686L6.16201 5.28502C6.20175 5.24356 6.25662 5.22018 6.31398 5.22018H6.32707C6.38739 5.22018 6.44475 5.24606 6.48465 5.29126L6.75258 5.59411C6.80355 5.65178 6.87681 5.68467 6.95381 5.68467H9.74133C9.71452 5.3628 9.64734 5.05263 9.54431 4.75913H8.05641L8.05656 4.75897ZM4.33651 7.63095C4.39652 7.63095 4.45404 7.60648 4.4955 7.56315L4.81347 7.23131C4.85321 7.18985 4.90808 7.16647 4.96544 7.16647H4.97853C5.03885 7.16647 5.09621 7.19234 5.13611 7.23739L5.40404 7.54024C5.45501 7.59791 5.52827 7.6308 5.60527 7.6308H9.38285C9.52438 7.33839 9.62803 7.02463 9.68975 6.69591H6.06383C5.98683 6.69591 5.91357 6.66287 5.8626 6.60535L5.59467 6.3025C5.55477 6.2573 5.49725 6.23158 5.43709 6.23158C5.37692 6.23158 5.31941 6.25746 5.27951 6.3025L5.0496 6.56233C4.97432 6.64728 4.86631 6.69606 4.75268 6.69606H2.32147C2.3832 7.02479 2.487 7.33855 2.62837 7.63095H4.33651ZM5.57359 8.55745H4.59116C4.51417 8.55745 4.44091 8.52441 4.38994 8.46689L4.12201 8.16404C4.0821 8.11884 4.02459 8.09312 3.96442 8.09312C3.90426 8.09312 3.84675 8.119 3.80684 8.16404L3.57694 8.42387C3.50166 8.50882 3.39364 8.55761 3.28001 8.55761H3.26474C3.94915 9.29096 4.92378 9.74998 6.00596 9.74998C7.08815 9.74998 8.06262 9.29096 8.74719 8.55761H5.57359V8.55745Z",
          fill: "currentColor"
        }
      )
    })
  );
});
SmallAptosLogo.displayName = "SmallAptosLogo";
var APTOS_PRIVACY_POLICY_URL = "https://aptoslabs.com/privacy";
var Root3 = createHeadlessComponent("AptosPrivacyPolicy.Root", "div");
var Disclaimer = createHeadlessComponent(
  "AptosPrivacyPolicy.Disclaimer",
  "span",
  { children: "By continuing, you agree to Aptos Labs'" }
);
var Link = createHeadlessComponent("AptosPrivacyPolicy.Disclaimer", "a", {
  href: APTOS_PRIVACY_POLICY_URL,
  target: "_blank",
  rel: "noopener noreferrer",
  children: "Privacy Policy"
});
var PoweredBy = (0, import_react9.forwardRef)(({ className }, ref) => {
  return (0, import_jsx_runtime10.jsxs)("div", { ref, className, children: [
    (0, import_jsx_runtime10.jsx)("span", { children: "Powered by" }),
    (0, import_jsx_runtime10.jsx)(SmallAptosLogo, {}),
    (0, import_jsx_runtime10.jsx)("span", { children: "Aptos Labs" })
  ] });
});
PoweredBy.displayName = "AptosPrivacyPolicy.PoweredBy";
var AptosPrivacyPolicy = Object.assign(Root3, {
  Disclaimer,
  Link,
  PoweredBy
});
function useWalletItemContext(displayName) {
  const context = (0, import_react11.useContext)(WalletItemContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`WalletItem\``);
  }
  return context;
}
var WalletItemContext = (0, import_react11.createContext)(null);
var Root4 = (0, import_react11.forwardRef)(
  ({ wallet, onConnect, className, asChild, children }, ref) => {
    const { connect } = useWallet();
    const isWalletReady = wallet.readyState === WalletReadyState.Installed;
    const mobileSupport = "deeplinkProvider" in wallet && wallet.deeplinkProvider;
    const connectWallet = (0, import_react11.useCallback)(() => {
      const connectionWallet = shouldUseFallbackWallet(wallet) ? wallet.fallbackWallet : wallet;
      if (!connectionWallet) return;
      connect(connectionWallet.name);
      onConnect == null ? void 0 : onConnect();
    }, [wallet, connect, onConnect]);
    if (!isWalletReady && isRedirectable() && !mobileSupport) return null;
    const Component = asChild ? Slot : "div";
    return (0, import_jsx_runtime11.jsx)(WalletItemContext.Provider, { value: { wallet, connectWallet }, children: (0, import_jsx_runtime11.jsx)(Component, { ref, className, children }) });
  }
);
Root4.displayName = "WalletItem";
var Icon = createHeadlessComponent(
  "WalletItem.Icon",
  "img",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      src: context.wallet.icon,
      alt: `${context.wallet.name} icon`
    };
  }
);
var Name = createHeadlessComponent(
  "WalletItem.Name",
  "div",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      children: context.wallet.name
    };
  }
);
var ConnectButton = createHeadlessComponent(
  "WalletItem.ConnectButton",
  "button",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      onClick: context.connectWallet,
      children: "Connect"
    };
  }
);
var InstallLink = createHeadlessComponent(
  "WalletItem.InstallLink",
  "a",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      href: context.wallet.url,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Install"
    };
  }
);
var WalletItem = Object.assign(Root4, {
  Icon,
  Name,
  ConnectButton,
  InstallLink
});
export {
  APTOS_CONNECT_ACCOUNT_URL,
  APTOS_CONNECT_BASE_URL,
  APTOS_PRIVACY_POLICY_URL,
  AboutAptosConnect,
  AboutPetraWeb,
  AptosPrivacyPolicy,
  AptosWalletAdapterProvider,
  ChainIdToAnsSupportedNetworkMap,
  DEFAULT_WALLET_CONNECTION_FALLBACKS,
  EXPLORE_ECOSYSTEM_URL2 as EXPLORE_ECOSYSTEM_URL,
  NetworkName2 as NetworkName,
  PETRA_WALLET_NAME,
  PETRA_WEB_ACCOUNT_URL,
  PETRA_WEB_BASE_URL,
  PETRA_WEB_GENERIC_WALLET_NAME,
  WalletContext,
  WalletCore,
  WalletItem,
  WalletReadyState,
  aptosStandardSupportedWalletList,
  convertNetwork,
  crossChainStandardSupportedWalletList,
  fetchDevnetChainId,
  generalizedErrorMessage,
  getAptosConfig,
  getAptosConnectWallets,
  getLocalStorage,
  getPetraWebWallets,
  getSDKWallets,
  groupAndSortWallets,
  handlePublishPackageTransaction,
  isAptosConnectWallet,
  isAptosLiveNetwork,
  isAptosNetwork,
  isInAppBrowser,
  isInstallRequired,
  isInstalledOrLoadable,
  isMobile,
  isPetraWebGenericWallet,
  isPetraWebWallet,
  isRedirectable,
  partitionWallets,
  removeLocalStorage,
  setLocalStorage,
  shouldUseFallbackWallet,
  truncateAddress,
  useWallet
};
//# sourceMappingURL=@aptos-labs_wallet-adapter-react.js.map
