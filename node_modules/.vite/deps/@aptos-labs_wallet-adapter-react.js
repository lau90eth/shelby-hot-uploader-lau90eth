import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  $a,
  G3 as G,
  I2 as I,
  Ie,
  Kt,
  L2 as L,
  O4 as O,
  Sr,
  W3 as W,
  W4 as W2,
  Y,
  _5 as _,
  _e,
  a,
  a10 as a3,
  a3 as a2,
  b4 as b,
  e,
  ee,
  gr,
  he,
  l2 as l,
  l5 as l2,
  lc,
  mc,
  n,
  p2 as p,
  sha3_256,
  t4 as t,
  v4 as v,
  x,
  yr,
  yt
} from "./chunk-OJMRC4F7.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l4 = handlers.length, ee3 = new Array(l4); i4 < l4; i4++) {
        ee3[i4] = handlers[i4].fn;
      }
      return ee3;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i4;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a32), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a32, a42), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a32, a42, a52), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length = listeners2.length, j3;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners2[i4].once) this.removeListener(event, listeners2[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i4].fn.call(listeners2[i4].context);
              break;
            case 2:
              listeners2[i4].fn.call(listeners2[i4].context, a1);
              break;
            case 3:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22);
              break;
            case 4:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a22, a32);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners2[i4].fn.apply(listeners2[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on2(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners2.length; i4 < length; i4++) {
          if (listeners2[i4].fn !== fn || once && !listeners2[i4].once || context && listeners2[i4].context !== context) {
            events.push(listeners2[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_3, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl3) {
      "use strict";
      var gf = function(init) {
        var i4, r9 = new Float64Array(16);
        if (init) for (i4 = 0; i4 < init.length; i4++) r9[i4] = init[i4];
        return r9;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X3 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y3 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I4 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x4, i4, h3, l4) {
        x4[i4] = h3 >> 24 & 255;
        x4[i4 + 1] = h3 >> 16 & 255;
        x4[i4 + 2] = h3 >> 8 & 255;
        x4[i4 + 3] = h3 & 255;
        x4[i4 + 4] = l4 >> 24 & 255;
        x4[i4 + 5] = l4 >> 16 & 255;
        x4[i4 + 6] = l4 >> 8 & 255;
        x4[i4 + 7] = l4 & 255;
      }
      function vn(x4, xi, y2, yi, n16) {
        var i4, d8 = 0;
        for (i4 = 0; i4 < n16; i4++) d8 |= x4[xi + i4] ^ y2[yi + i4];
        return (1 & d8 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x4, xi, y2, yi) {
        return vn(x4, xi, y2, yi, 16);
      }
      function crypto_verify_32(x4, xi, y2, yi) {
        return vn(x4, xi, y2, yi, 32);
      }
      function core_salsa20(o12, p6, k3, c3) {
        var j0 = c3[0] & 255 | (c3[1] & 255) << 8 | (c3[2] & 255) << 16 | (c3[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c3[4] & 255 | (c3[5] & 255) << 8 | (c3[6] & 255) << 16 | (c3[7] & 255) << 24, j6 = p6[0] & 255 | (p6[1] & 255) << 8 | (p6[2] & 255) << 16 | (p6[3] & 255) << 24, j7 = p6[4] & 255 | (p6[5] & 255) << 8 | (p6[6] & 255) << 16 | (p6[7] & 255) << 24, j8 = p6[8] & 255 | (p6[9] & 255) << 8 | (p6[10] & 255) << 16 | (p6[11] & 255) << 24, j9 = p6[12] & 255 | (p6[13] & 255) << 8 | (p6[14] & 255) << 16 | (p6[15] & 255) << 24, j10 = c3[8] & 255 | (c3[9] & 255) << 8 | (c3[10] & 255) << 16 | (c3[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c3[12] & 255 | (c3[13] & 255) << 8 | (c3[14] & 255) << 16 | (c3[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i4 = 0; i4 < 20; i4 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x32 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x32 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x32 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x32 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x32 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x32 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x22 = x22 + j22 | 0;
        x32 = x32 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o12[0] = x0 >>> 0 & 255;
        o12[1] = x0 >>> 8 & 255;
        o12[2] = x0 >>> 16 & 255;
        o12[3] = x0 >>> 24 & 255;
        o12[4] = x1 >>> 0 & 255;
        o12[5] = x1 >>> 8 & 255;
        o12[6] = x1 >>> 16 & 255;
        o12[7] = x1 >>> 24 & 255;
        o12[8] = x22 >>> 0 & 255;
        o12[9] = x22 >>> 8 & 255;
        o12[10] = x22 >>> 16 & 255;
        o12[11] = x22 >>> 24 & 255;
        o12[12] = x32 >>> 0 & 255;
        o12[13] = x32 >>> 8 & 255;
        o12[14] = x32 >>> 16 & 255;
        o12[15] = x32 >>> 24 & 255;
        o12[16] = x4 >>> 0 & 255;
        o12[17] = x4 >>> 8 & 255;
        o12[18] = x4 >>> 16 & 255;
        o12[19] = x4 >>> 24 & 255;
        o12[20] = x5 >>> 0 & 255;
        o12[21] = x5 >>> 8 & 255;
        o12[22] = x5 >>> 16 & 255;
        o12[23] = x5 >>> 24 & 255;
        o12[24] = x6 >>> 0 & 255;
        o12[25] = x6 >>> 8 & 255;
        o12[26] = x6 >>> 16 & 255;
        o12[27] = x6 >>> 24 & 255;
        o12[28] = x7 >>> 0 & 255;
        o12[29] = x7 >>> 8 & 255;
        o12[30] = x7 >>> 16 & 255;
        o12[31] = x7 >>> 24 & 255;
        o12[32] = x8 >>> 0 & 255;
        o12[33] = x8 >>> 8 & 255;
        o12[34] = x8 >>> 16 & 255;
        o12[35] = x8 >>> 24 & 255;
        o12[36] = x9 >>> 0 & 255;
        o12[37] = x9 >>> 8 & 255;
        o12[38] = x9 >>> 16 & 255;
        o12[39] = x9 >>> 24 & 255;
        o12[40] = x10 >>> 0 & 255;
        o12[41] = x10 >>> 8 & 255;
        o12[42] = x10 >>> 16 & 255;
        o12[43] = x10 >>> 24 & 255;
        o12[44] = x11 >>> 0 & 255;
        o12[45] = x11 >>> 8 & 255;
        o12[46] = x11 >>> 16 & 255;
        o12[47] = x11 >>> 24 & 255;
        o12[48] = x12 >>> 0 & 255;
        o12[49] = x12 >>> 8 & 255;
        o12[50] = x12 >>> 16 & 255;
        o12[51] = x12 >>> 24 & 255;
        o12[52] = x13 >>> 0 & 255;
        o12[53] = x13 >>> 8 & 255;
        o12[54] = x13 >>> 16 & 255;
        o12[55] = x13 >>> 24 & 255;
        o12[56] = x14 >>> 0 & 255;
        o12[57] = x14 >>> 8 & 255;
        o12[58] = x14 >>> 16 & 255;
        o12[59] = x14 >>> 24 & 255;
        o12[60] = x15 >>> 0 & 255;
        o12[61] = x15 >>> 8 & 255;
        o12[62] = x15 >>> 16 & 255;
        o12[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o12, p6, k3, c3) {
        var j0 = c3[0] & 255 | (c3[1] & 255) << 8 | (c3[2] & 255) << 16 | (c3[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c3[4] & 255 | (c3[5] & 255) << 8 | (c3[6] & 255) << 16 | (c3[7] & 255) << 24, j6 = p6[0] & 255 | (p6[1] & 255) << 8 | (p6[2] & 255) << 16 | (p6[3] & 255) << 24, j7 = p6[4] & 255 | (p6[5] & 255) << 8 | (p6[6] & 255) << 16 | (p6[7] & 255) << 24, j8 = p6[8] & 255 | (p6[9] & 255) << 8 | (p6[10] & 255) << 16 | (p6[11] & 255) << 24, j9 = p6[12] & 255 | (p6[13] & 255) << 8 | (p6[14] & 255) << 16 | (p6[15] & 255) << 24, j10 = c3[8] & 255 | (c3[9] & 255) << 8 | (c3[10] & 255) << 16 | (c3[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c3[12] & 255 | (c3[13] & 255) << 8 | (c3[14] & 255) << 16 | (c3[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i4 = 0; i4 < 20; i4 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x22 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x32 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x32 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x32 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x32 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x22 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x22 + x1 | 0;
          x32 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x32 + x22 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o12[0] = x0 >>> 0 & 255;
        o12[1] = x0 >>> 8 & 255;
        o12[2] = x0 >>> 16 & 255;
        o12[3] = x0 >>> 24 & 255;
        o12[4] = x5 >>> 0 & 255;
        o12[5] = x5 >>> 8 & 255;
        o12[6] = x5 >>> 16 & 255;
        o12[7] = x5 >>> 24 & 255;
        o12[8] = x10 >>> 0 & 255;
        o12[9] = x10 >>> 8 & 255;
        o12[10] = x10 >>> 16 & 255;
        o12[11] = x10 >>> 24 & 255;
        o12[12] = x15 >>> 0 & 255;
        o12[13] = x15 >>> 8 & 255;
        o12[14] = x15 >>> 16 & 255;
        o12[15] = x15 >>> 24 & 255;
        o12[16] = x6 >>> 0 & 255;
        o12[17] = x6 >>> 8 & 255;
        o12[18] = x6 >>> 16 & 255;
        o12[19] = x6 >>> 24 & 255;
        o12[20] = x7 >>> 0 & 255;
        o12[21] = x7 >>> 8 & 255;
        o12[22] = x7 >>> 16 & 255;
        o12[23] = x7 >>> 24 & 255;
        o12[24] = x8 >>> 0 & 255;
        o12[25] = x8 >>> 8 & 255;
        o12[26] = x8 >>> 16 & 255;
        o12[27] = x8 >>> 24 & 255;
        o12[28] = x9 >>> 0 & 255;
        o12[29] = x9 >>> 8 & 255;
        o12[30] = x9 >>> 16 & 255;
        o12[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k3, c3) {
        core_salsa20(out, inp, k3, c3);
      }
      function crypto_core_hsalsa20(out, inp, k3, c3) {
        core_hsalsa20(out, inp, k3, c3);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c3, cpos, m2, mpos, b4, n16, k3) {
        var z3 = new Uint8Array(16), x4 = new Uint8Array(64);
        var u2, i4;
        for (i4 = 0; i4 < 16; i4++) z3[i4] = 0;
        for (i4 = 0; i4 < 8; i4++) z3[i4] = n16[i4];
        while (b4 >= 64) {
          crypto_core_salsa20(x4, z3, k3, sigma);
          for (i4 = 0; i4 < 64; i4++) c3[cpos + i4] = m2[mpos + i4] ^ x4[i4];
          u2 = 1;
          for (i4 = 8; i4 < 16; i4++) {
            u2 = u2 + (z3[i4] & 255) | 0;
            z3[i4] = u2 & 255;
            u2 >>>= 8;
          }
          b4 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b4 > 0) {
          crypto_core_salsa20(x4, z3, k3, sigma);
          for (i4 = 0; i4 < b4; i4++) c3[cpos + i4] = m2[mpos + i4] ^ x4[i4];
        }
        return 0;
      }
      function crypto_stream_salsa20(c3, cpos, b4, n16, k3) {
        var z3 = new Uint8Array(16), x4 = new Uint8Array(64);
        var u2, i4;
        for (i4 = 0; i4 < 16; i4++) z3[i4] = 0;
        for (i4 = 0; i4 < 8; i4++) z3[i4] = n16[i4];
        while (b4 >= 64) {
          crypto_core_salsa20(x4, z3, k3, sigma);
          for (i4 = 0; i4 < 64; i4++) c3[cpos + i4] = x4[i4];
          u2 = 1;
          for (i4 = 8; i4 < 16; i4++) {
            u2 = u2 + (z3[i4] & 255) | 0;
            z3[i4] = u2 & 255;
            u2 >>>= 8;
          }
          b4 -= 64;
          cpos += 64;
        }
        if (b4 > 0) {
          crypto_core_salsa20(x4, z3, k3, sigma);
          for (i4 = 0; i4 < b4; i4++) c3[cpos + i4] = x4[i4];
        }
        return 0;
      }
      function crypto_stream(c3, cpos, d8, n16, k3) {
        var s4 = new Uint8Array(32);
        crypto_core_hsalsa20(s4, n16, k3, sigma);
        var sn = new Uint8Array(8);
        for (var i4 = 0; i4 < 8; i4++) sn[i4] = n16[i4 + 16];
        return crypto_stream_salsa20(c3, cpos, d8, sn, s4);
      }
      function crypto_stream_xor(c3, cpos, m2, mpos, d8, n16, k3) {
        var s4 = new Uint8Array(32);
        crypto_core_hsalsa20(s4, n16, k3, sigma);
        var sn = new Uint8Array(8);
        for (var i4 = 0; i4 < 8; i4++) sn[i4] = n16[i4 + 16];
        return crypto_stream_salsa20_xor(c3, cpos, m2, mpos, d8, sn, s4);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t22, t32, t42, t52, t62, t72;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t22 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t22 << 6) & 7939;
        t32 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t22 >>> 7 | t32 << 9) & 8191;
        t42 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t32 >>> 4 | t42 << 12) & 255;
        this.r[5] = t42 >>> 1 & 8190;
        t52 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t42 >>> 14 | t52 << 2) & 8191;
        t62 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t52 >>> 11 | t62 << 5) & 8065;
        t72 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t62 >>> 8 | t72 << 8) & 8191;
        this.r[9] = t72 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m2, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t22, t32, t42, t52, t62, t72, c3;
        var d0, d1, d22, d32, d42, d52, d62, d72, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h22 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r32 = this.r[3], r42 = this.r[4], r52 = this.r[5], r62 = this.r[6], r72 = this.r[7], r82 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t22 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
          h22 += (t1 >>> 10 | t22 << 6) & 8191;
          t32 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
          h3 += (t22 >>> 7 | t32 << 9) & 8191;
          t42 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
          h4 += (t32 >>> 4 | t42 << 12) & 8191;
          h5 += t42 >>> 1 & 8191;
          t52 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
          h6 += (t42 >>> 14 | t52 << 2) & 8191;
          t62 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
          h7 += (t52 >>> 11 | t62 << 5) & 8191;
          t72 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
          h8 += (t62 >>> 8 | t72 << 8) & 8191;
          h9 += t72 >>> 5 | hibit;
          c3 = 0;
          d0 = c3;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h22 * (5 * r82);
          d0 += h3 * (5 * r72);
          d0 += h4 * (5 * r62);
          c3 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r52);
          d0 += h6 * (5 * r42);
          d0 += h7 * (5 * r32);
          d0 += h8 * (5 * r22);
          d0 += h9 * (5 * r1);
          c3 += d0 >>> 13;
          d0 &= 8191;
          d1 = c3;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r9);
          d1 += h3 * (5 * r82);
          d1 += h4 * (5 * r72);
          c3 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r62);
          d1 += h6 * (5 * r52);
          d1 += h7 * (5 * r42);
          d1 += h8 * (5 * r32);
          d1 += h9 * (5 * r22);
          c3 += d1 >>> 13;
          d1 &= 8191;
          d22 = c3;
          d22 += h0 * r22;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h3 * (5 * r9);
          d22 += h4 * (5 * r82);
          c3 = d22 >>> 13;
          d22 &= 8191;
          d22 += h5 * (5 * r72);
          d22 += h6 * (5 * r62);
          d22 += h7 * (5 * r52);
          d22 += h8 * (5 * r42);
          d22 += h9 * (5 * r32);
          c3 += d22 >>> 13;
          d22 &= 8191;
          d32 = c3;
          d32 += h0 * r32;
          d32 += h1 * r22;
          d32 += h22 * r1;
          d32 += h3 * r0;
          d32 += h4 * (5 * r9);
          c3 = d32 >>> 13;
          d32 &= 8191;
          d32 += h5 * (5 * r82);
          d32 += h6 * (5 * r72);
          d32 += h7 * (5 * r62);
          d32 += h8 * (5 * r52);
          d32 += h9 * (5 * r42);
          c3 += d32 >>> 13;
          d32 &= 8191;
          d42 = c3;
          d42 += h0 * r42;
          d42 += h1 * r32;
          d42 += h22 * r22;
          d42 += h3 * r1;
          d42 += h4 * r0;
          c3 = d42 >>> 13;
          d42 &= 8191;
          d42 += h5 * (5 * r9);
          d42 += h6 * (5 * r82);
          d42 += h7 * (5 * r72);
          d42 += h8 * (5 * r62);
          d42 += h9 * (5 * r52);
          c3 += d42 >>> 13;
          d42 &= 8191;
          d52 = c3;
          d52 += h0 * r52;
          d52 += h1 * r42;
          d52 += h22 * r32;
          d52 += h3 * r22;
          d52 += h4 * r1;
          c3 = d52 >>> 13;
          d52 &= 8191;
          d52 += h5 * r0;
          d52 += h6 * (5 * r9);
          d52 += h7 * (5 * r82);
          d52 += h8 * (5 * r72);
          d52 += h9 * (5 * r62);
          c3 += d52 >>> 13;
          d52 &= 8191;
          d62 = c3;
          d62 += h0 * r62;
          d62 += h1 * r52;
          d62 += h22 * r42;
          d62 += h3 * r32;
          d62 += h4 * r22;
          c3 = d62 >>> 13;
          d62 &= 8191;
          d62 += h5 * r1;
          d62 += h6 * r0;
          d62 += h7 * (5 * r9);
          d62 += h8 * (5 * r82);
          d62 += h9 * (5 * r72);
          c3 += d62 >>> 13;
          d62 &= 8191;
          d72 = c3;
          d72 += h0 * r72;
          d72 += h1 * r62;
          d72 += h22 * r52;
          d72 += h3 * r42;
          d72 += h4 * r32;
          c3 = d72 >>> 13;
          d72 &= 8191;
          d72 += h5 * r22;
          d72 += h6 * r1;
          d72 += h7 * r0;
          d72 += h8 * (5 * r9);
          d72 += h9 * (5 * r82);
          c3 += d72 >>> 13;
          d72 &= 8191;
          d8 = c3;
          d8 += h0 * r82;
          d8 += h1 * r72;
          d8 += h22 * r62;
          d8 += h3 * r52;
          d8 += h4 * r42;
          c3 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r32;
          d8 += h6 * r22;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c3 += d8 >>> 13;
          d8 &= 8191;
          d9 = c3;
          d9 += h0 * r9;
          d9 += h1 * r82;
          d9 += h22 * r72;
          d9 += h3 * r62;
          d9 += h4 * r52;
          c3 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r42;
          d9 += h6 * r32;
          d9 += h7 * r22;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c3 += d9 >>> 13;
          d9 &= 8191;
          c3 = (c3 << 2) + c3 | 0;
          c3 = c3 + d0 | 0;
          d0 = c3 & 8191;
          c3 = c3 >>> 13;
          d1 += c3;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h3 = d32;
          h4 = d42;
          h5 = d52;
          h6 = d62;
          h7 = d72;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h22;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c3, mask, f6, i4;
        if (this.leftover) {
          i4 = this.leftover;
          this.buffer[i4++] = 1;
          for (; i4 < 16; i4++) this.buffer[i4] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c3 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i4 = 2; i4 < 10; i4++) {
          this.h[i4] += c3;
          c3 = this.h[i4] >>> 13;
          this.h[i4] &= 8191;
        }
        this.h[0] += c3 * 5;
        c3 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c3;
        c3 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c3;
        g2[0] = this.h[0] + 5;
        c3 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i4 = 1; i4 < 10; i4++) {
          g2[i4] = this.h[i4] + c3;
          c3 = g2[i4] >>> 13;
          g2[i4] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c3 ^ 1) - 1;
        for (i4 = 0; i4 < 10; i4++) g2[i4] &= mask;
        mask = ~mask;
        for (i4 = 0; i4 < 10; i4++) this.h[i4] = this.h[i4] & mask | g2[i4];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f6 = this.h[0] + this.pad[0];
        this.h[0] = f6 & 65535;
        for (i4 = 1; i4 < 8; i4++) {
          f6 = (this.h[i4] + this.pad[i4] | 0) + (f6 >>> 16) | 0;
          this.h[i4] = f6 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m2, mpos, bytes) {
        var i4, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i4 = 0; i4 < want; i4++)
            this.buffer[this.leftover + i4] = m2[mpos + i4];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i4 = 0; i4 < bytes; i4++)
            this.buffer[this.leftover + i4] = m2[mpos + i4];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m2, mpos, n16, k3) {
        var s4 = new poly1305(k3);
        s4.update(m2, mpos, n16);
        s4.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h3, hpos, m2, mpos, n16, k3) {
        var x4 = new Uint8Array(16);
        crypto_onetimeauth(x4, 0, m2, mpos, n16, k3);
        return crypto_verify_16(h3, hpos, x4, 0);
      }
      function crypto_secretbox(c3, m2, d8, n16, k3) {
        var i4;
        if (d8 < 32) return -1;
        crypto_stream_xor(c3, 0, m2, 0, d8, n16, k3);
        crypto_onetimeauth(c3, 16, c3, 32, d8 - 32, c3);
        for (i4 = 0; i4 < 16; i4++) c3[i4] = 0;
        return 0;
      }
      function crypto_secretbox_open(m2, c3, d8, n16, k3) {
        var i4;
        var x4 = new Uint8Array(32);
        if (d8 < 32) return -1;
        crypto_stream(x4, 0, 32, n16, k3);
        if (crypto_onetimeauth_verify(c3, 16, c3, 32, d8 - 32, x4) !== 0) return -1;
        crypto_stream_xor(m2, 0, c3, 0, d8, n16, k3);
        for (i4 = 0; i4 < 32; i4++) m2[i4] = 0;
        return 0;
      }
      function set25519(r9, a9) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) r9[i4] = a9[i4] | 0;
      }
      function car25519(o12) {
        var i4, v6, c3 = 1;
        for (i4 = 0; i4 < 16; i4++) {
          v6 = o12[i4] + c3 + 65535;
          c3 = Math.floor(v6 / 65536);
          o12[i4] = v6 - c3 * 65536;
        }
        o12[0] += c3 - 1 + 37 * (c3 - 1);
      }
      function sel25519(p6, q3, b4) {
        var t11, c3 = ~(b4 - 1);
        for (var i4 = 0; i4 < 16; i4++) {
          t11 = c3 & (p6[i4] ^ q3[i4]);
          p6[i4] ^= t11;
          q3[i4] ^= t11;
        }
      }
      function pack25519(o12, n16) {
        var i4, j3, b4;
        var m2 = gf(), t11 = gf();
        for (i4 = 0; i4 < 16; i4++) t11[i4] = n16[i4];
        car25519(t11);
        car25519(t11);
        car25519(t11);
        for (j3 = 0; j3 < 2; j3++) {
          m2[0] = t11[0] - 65517;
          for (i4 = 1; i4 < 15; i4++) {
            m2[i4] = t11[i4] - 65535 - (m2[i4 - 1] >> 16 & 1);
            m2[i4 - 1] &= 65535;
          }
          m2[15] = t11[15] - 32767 - (m2[14] >> 16 & 1);
          b4 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t11, m2, 1 - b4);
        }
        for (i4 = 0; i4 < 16; i4++) {
          o12[2 * i4] = t11[i4] & 255;
          o12[2 * i4 + 1] = t11[i4] >> 8;
        }
      }
      function neq25519(a9, b4) {
        var c3 = new Uint8Array(32), d8 = new Uint8Array(32);
        pack25519(c3, a9);
        pack25519(d8, b4);
        return crypto_verify_32(c3, 0, d8, 0);
      }
      function par25519(a9) {
        var d8 = new Uint8Array(32);
        pack25519(d8, a9);
        return d8[0] & 1;
      }
      function unpack25519(o12, n16) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o12[i4] = n16[2 * i4] + (n16[2 * i4 + 1] << 8);
        o12[15] &= 32767;
      }
      function A5(o12, a9, b4) {
        for (var i4 = 0; i4 < 16; i4++) o12[i4] = a9[i4] + b4[i4];
      }
      function Z3(o12, a9, b4) {
        for (var i4 = 0; i4 < 16; i4++) o12[i4] = a9[i4] - b4[i4];
      }
      function M3(o12, a9, b4) {
        var v6, c3, t0 = 0, t1 = 0, t22 = 0, t32 = 0, t42 = 0, t52 = 0, t62 = 0, t72 = 0, t82 = 0, t92 = 0, t102 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b4[0], b1 = b4[1], b22 = b4[2], b32 = b4[3], b42 = b4[4], b5 = b4[5], b6 = b4[6], b7 = b4[7], b8 = b4[8], b9 = b4[9], b10 = b4[10], b11 = b4[11], b12 = b4[12], b13 = b4[13], b14 = b4[14], b15 = b4[15];
        v6 = a9[0];
        t0 += v6 * b0;
        t1 += v6 * b1;
        t22 += v6 * b22;
        t32 += v6 * b32;
        t42 += v6 * b42;
        t52 += v6 * b5;
        t62 += v6 * b6;
        t72 += v6 * b7;
        t82 += v6 * b8;
        t92 += v6 * b9;
        t102 += v6 * b10;
        t11 += v6 * b11;
        t12 += v6 * b12;
        t13 += v6 * b13;
        t14 += v6 * b14;
        t15 += v6 * b15;
        v6 = a9[1];
        t1 += v6 * b0;
        t22 += v6 * b1;
        t32 += v6 * b22;
        t42 += v6 * b32;
        t52 += v6 * b42;
        t62 += v6 * b5;
        t72 += v6 * b6;
        t82 += v6 * b7;
        t92 += v6 * b8;
        t102 += v6 * b9;
        t11 += v6 * b10;
        t12 += v6 * b11;
        t13 += v6 * b12;
        t14 += v6 * b13;
        t15 += v6 * b14;
        t16 += v6 * b15;
        v6 = a9[2];
        t22 += v6 * b0;
        t32 += v6 * b1;
        t42 += v6 * b22;
        t52 += v6 * b32;
        t62 += v6 * b42;
        t72 += v6 * b5;
        t82 += v6 * b6;
        t92 += v6 * b7;
        t102 += v6 * b8;
        t11 += v6 * b9;
        t12 += v6 * b10;
        t13 += v6 * b11;
        t14 += v6 * b12;
        t15 += v6 * b13;
        t16 += v6 * b14;
        t17 += v6 * b15;
        v6 = a9[3];
        t32 += v6 * b0;
        t42 += v6 * b1;
        t52 += v6 * b22;
        t62 += v6 * b32;
        t72 += v6 * b42;
        t82 += v6 * b5;
        t92 += v6 * b6;
        t102 += v6 * b7;
        t11 += v6 * b8;
        t12 += v6 * b9;
        t13 += v6 * b10;
        t14 += v6 * b11;
        t15 += v6 * b12;
        t16 += v6 * b13;
        t17 += v6 * b14;
        t18 += v6 * b15;
        v6 = a9[4];
        t42 += v6 * b0;
        t52 += v6 * b1;
        t62 += v6 * b22;
        t72 += v6 * b32;
        t82 += v6 * b42;
        t92 += v6 * b5;
        t102 += v6 * b6;
        t11 += v6 * b7;
        t12 += v6 * b8;
        t13 += v6 * b9;
        t14 += v6 * b10;
        t15 += v6 * b11;
        t16 += v6 * b12;
        t17 += v6 * b13;
        t18 += v6 * b14;
        t19 += v6 * b15;
        v6 = a9[5];
        t52 += v6 * b0;
        t62 += v6 * b1;
        t72 += v6 * b22;
        t82 += v6 * b32;
        t92 += v6 * b42;
        t102 += v6 * b5;
        t11 += v6 * b6;
        t12 += v6 * b7;
        t13 += v6 * b8;
        t14 += v6 * b9;
        t15 += v6 * b10;
        t16 += v6 * b11;
        t17 += v6 * b12;
        t18 += v6 * b13;
        t19 += v6 * b14;
        t20 += v6 * b15;
        v6 = a9[6];
        t62 += v6 * b0;
        t72 += v6 * b1;
        t82 += v6 * b22;
        t92 += v6 * b32;
        t102 += v6 * b42;
        t11 += v6 * b5;
        t12 += v6 * b6;
        t13 += v6 * b7;
        t14 += v6 * b8;
        t15 += v6 * b9;
        t16 += v6 * b10;
        t17 += v6 * b11;
        t18 += v6 * b12;
        t19 += v6 * b13;
        t20 += v6 * b14;
        t21 += v6 * b15;
        v6 = a9[7];
        t72 += v6 * b0;
        t82 += v6 * b1;
        t92 += v6 * b22;
        t102 += v6 * b32;
        t11 += v6 * b42;
        t12 += v6 * b5;
        t13 += v6 * b6;
        t14 += v6 * b7;
        t15 += v6 * b8;
        t16 += v6 * b9;
        t17 += v6 * b10;
        t18 += v6 * b11;
        t19 += v6 * b12;
        t20 += v6 * b13;
        t21 += v6 * b14;
        t222 += v6 * b15;
        v6 = a9[8];
        t82 += v6 * b0;
        t92 += v6 * b1;
        t102 += v6 * b22;
        t11 += v6 * b32;
        t12 += v6 * b42;
        t13 += v6 * b5;
        t14 += v6 * b6;
        t15 += v6 * b7;
        t16 += v6 * b8;
        t17 += v6 * b9;
        t18 += v6 * b10;
        t19 += v6 * b11;
        t20 += v6 * b12;
        t21 += v6 * b13;
        t222 += v6 * b14;
        t23 += v6 * b15;
        v6 = a9[9];
        t92 += v6 * b0;
        t102 += v6 * b1;
        t11 += v6 * b22;
        t12 += v6 * b32;
        t13 += v6 * b42;
        t14 += v6 * b5;
        t15 += v6 * b6;
        t16 += v6 * b7;
        t17 += v6 * b8;
        t18 += v6 * b9;
        t19 += v6 * b10;
        t20 += v6 * b11;
        t21 += v6 * b12;
        t222 += v6 * b13;
        t23 += v6 * b14;
        t24 += v6 * b15;
        v6 = a9[10];
        t102 += v6 * b0;
        t11 += v6 * b1;
        t12 += v6 * b22;
        t13 += v6 * b32;
        t14 += v6 * b42;
        t15 += v6 * b5;
        t16 += v6 * b6;
        t17 += v6 * b7;
        t18 += v6 * b8;
        t19 += v6 * b9;
        t20 += v6 * b10;
        t21 += v6 * b11;
        t222 += v6 * b12;
        t23 += v6 * b13;
        t24 += v6 * b14;
        t25 += v6 * b15;
        v6 = a9[11];
        t11 += v6 * b0;
        t12 += v6 * b1;
        t13 += v6 * b22;
        t14 += v6 * b32;
        t15 += v6 * b42;
        t16 += v6 * b5;
        t17 += v6 * b6;
        t18 += v6 * b7;
        t19 += v6 * b8;
        t20 += v6 * b9;
        t21 += v6 * b10;
        t222 += v6 * b11;
        t23 += v6 * b12;
        t24 += v6 * b13;
        t25 += v6 * b14;
        t26 += v6 * b15;
        v6 = a9[12];
        t12 += v6 * b0;
        t13 += v6 * b1;
        t14 += v6 * b22;
        t15 += v6 * b32;
        t16 += v6 * b42;
        t17 += v6 * b5;
        t18 += v6 * b6;
        t19 += v6 * b7;
        t20 += v6 * b8;
        t21 += v6 * b9;
        t222 += v6 * b10;
        t23 += v6 * b11;
        t24 += v6 * b12;
        t25 += v6 * b13;
        t26 += v6 * b14;
        t27 += v6 * b15;
        v6 = a9[13];
        t13 += v6 * b0;
        t14 += v6 * b1;
        t15 += v6 * b22;
        t16 += v6 * b32;
        t17 += v6 * b42;
        t18 += v6 * b5;
        t19 += v6 * b6;
        t20 += v6 * b7;
        t21 += v6 * b8;
        t222 += v6 * b9;
        t23 += v6 * b10;
        t24 += v6 * b11;
        t25 += v6 * b12;
        t26 += v6 * b13;
        t27 += v6 * b14;
        t28 += v6 * b15;
        v6 = a9[14];
        t14 += v6 * b0;
        t15 += v6 * b1;
        t16 += v6 * b22;
        t17 += v6 * b32;
        t18 += v6 * b42;
        t19 += v6 * b5;
        t20 += v6 * b6;
        t21 += v6 * b7;
        t222 += v6 * b8;
        t23 += v6 * b9;
        t24 += v6 * b10;
        t25 += v6 * b11;
        t26 += v6 * b12;
        t27 += v6 * b13;
        t28 += v6 * b14;
        t29 += v6 * b15;
        v6 = a9[15];
        t15 += v6 * b0;
        t16 += v6 * b1;
        t17 += v6 * b22;
        t18 += v6 * b32;
        t19 += v6 * b42;
        t20 += v6 * b5;
        t21 += v6 * b6;
        t222 += v6 * b7;
        t23 += v6 * b8;
        t24 += v6 * b9;
        t25 += v6 * b10;
        t26 += v6 * b11;
        t27 += v6 * b12;
        t28 += v6 * b13;
        t29 += v6 * b14;
        t30 += v6 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t22 += 38 * t18;
        t32 += 38 * t19;
        t42 += 38 * t20;
        t52 += 38 * t21;
        t62 += 38 * t222;
        t72 += 38 * t23;
        t82 += 38 * t24;
        t92 += 38 * t25;
        t102 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c3 = 1;
        v6 = t0 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t0 = v6 - c3 * 65536;
        v6 = t1 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t1 = v6 - c3 * 65536;
        v6 = t22 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t22 = v6 - c3 * 65536;
        v6 = t32 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t32 = v6 - c3 * 65536;
        v6 = t42 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t42 = v6 - c3 * 65536;
        v6 = t52 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t52 = v6 - c3 * 65536;
        v6 = t62 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t62 = v6 - c3 * 65536;
        v6 = t72 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t72 = v6 - c3 * 65536;
        v6 = t82 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t82 = v6 - c3 * 65536;
        v6 = t92 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t92 = v6 - c3 * 65536;
        v6 = t102 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t102 = v6 - c3 * 65536;
        v6 = t11 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t11 = v6 - c3 * 65536;
        v6 = t12 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t12 = v6 - c3 * 65536;
        v6 = t13 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t13 = v6 - c3 * 65536;
        v6 = t14 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t14 = v6 - c3 * 65536;
        v6 = t15 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t15 = v6 - c3 * 65536;
        t0 += c3 - 1 + 37 * (c3 - 1);
        c3 = 1;
        v6 = t0 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t0 = v6 - c3 * 65536;
        v6 = t1 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t1 = v6 - c3 * 65536;
        v6 = t22 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t22 = v6 - c3 * 65536;
        v6 = t32 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t32 = v6 - c3 * 65536;
        v6 = t42 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t42 = v6 - c3 * 65536;
        v6 = t52 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t52 = v6 - c3 * 65536;
        v6 = t62 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t62 = v6 - c3 * 65536;
        v6 = t72 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t72 = v6 - c3 * 65536;
        v6 = t82 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t82 = v6 - c3 * 65536;
        v6 = t92 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t92 = v6 - c3 * 65536;
        v6 = t102 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t102 = v6 - c3 * 65536;
        v6 = t11 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t11 = v6 - c3 * 65536;
        v6 = t12 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t12 = v6 - c3 * 65536;
        v6 = t13 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t13 = v6 - c3 * 65536;
        v6 = t14 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t14 = v6 - c3 * 65536;
        v6 = t15 + c3 + 65535;
        c3 = Math.floor(v6 / 65536);
        t15 = v6 - c3 * 65536;
        t0 += c3 - 1 + 37 * (c3 - 1);
        o12[0] = t0;
        o12[1] = t1;
        o12[2] = t22;
        o12[3] = t32;
        o12[4] = t42;
        o12[5] = t52;
        o12[6] = t62;
        o12[7] = t72;
        o12[8] = t82;
        o12[9] = t92;
        o12[10] = t102;
        o12[11] = t11;
        o12[12] = t12;
        o12[13] = t13;
        o12[14] = t14;
        o12[15] = t15;
      }
      function S2(o12, a9) {
        M3(o12, a9, a9);
      }
      function inv25519(o12, i4) {
        var c3 = gf();
        var a9;
        for (a9 = 0; a9 < 16; a9++) c3[a9] = i4[a9];
        for (a9 = 253; a9 >= 0; a9--) {
          S2(c3, c3);
          if (a9 !== 2 && a9 !== 4) M3(c3, c3, i4);
        }
        for (a9 = 0; a9 < 16; a9++) o12[a9] = c3[a9];
      }
      function pow2523(o12, i4) {
        var c3 = gf();
        var a9;
        for (a9 = 0; a9 < 16; a9++) c3[a9] = i4[a9];
        for (a9 = 250; a9 >= 0; a9--) {
          S2(c3, c3);
          if (a9 !== 1) M3(c3, c3, i4);
        }
        for (a9 = 0; a9 < 16; a9++) o12[a9] = c3[a9];
      }
      function crypto_scalarmult(q3, n16, p6) {
        var z3 = new Uint8Array(32);
        var x4 = new Float64Array(80), r9, i4;
        var a9 = gf(), b4 = gf(), c3 = gf(), d8 = gf(), e14 = gf(), f6 = gf();
        for (i4 = 0; i4 < 31; i4++) z3[i4] = n16[i4];
        z3[31] = n16[31] & 127 | 64;
        z3[0] &= 248;
        unpack25519(x4, p6);
        for (i4 = 0; i4 < 16; i4++) {
          b4[i4] = x4[i4];
          d8[i4] = a9[i4] = c3[i4] = 0;
        }
        a9[0] = d8[0] = 1;
        for (i4 = 254; i4 >= 0; --i4) {
          r9 = z3[i4 >>> 3] >>> (i4 & 7) & 1;
          sel25519(a9, b4, r9);
          sel25519(c3, d8, r9);
          A5(e14, a9, c3);
          Z3(a9, a9, c3);
          A5(c3, b4, d8);
          Z3(b4, b4, d8);
          S2(d8, e14);
          S2(f6, a9);
          M3(a9, c3, a9);
          M3(c3, b4, e14);
          A5(e14, a9, c3);
          Z3(a9, a9, c3);
          S2(b4, a9);
          Z3(c3, d8, f6);
          M3(a9, c3, _121665);
          A5(a9, a9, d8);
          M3(c3, c3, a9);
          M3(a9, d8, f6);
          M3(d8, b4, x4);
          S2(b4, e14);
          sel25519(a9, b4, r9);
          sel25519(c3, d8, r9);
        }
        for (i4 = 0; i4 < 16; i4++) {
          x4[i4 + 16] = a9[i4];
          x4[i4 + 32] = c3[i4];
          x4[i4 + 48] = b4[i4];
          x4[i4 + 64] = d8[i4];
        }
        var x32 = x4.subarray(32);
        var x16 = x4.subarray(16);
        inv25519(x32, x32);
        M3(x16, x16, x32);
        pack25519(q3, x16);
        return 0;
      }
      function crypto_scalarmult_base(q3, n16) {
        return crypto_scalarmult(q3, n16, _9);
      }
      function crypto_box_keypair(y2, x4) {
        randombytes(x4, 32);
        return crypto_scalarmult_base(y2, x4);
      }
      function crypto_box_beforenm(k3, y2, x4) {
        var s4 = new Uint8Array(32);
        crypto_scalarmult(s4, x4, y2);
        return crypto_core_hsalsa20(k3, _0, s4, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c3, m2, d8, n16, y2, x4) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y2, x4);
        return crypto_box_afternm(c3, m2, d8, n16, k3);
      }
      function crypto_box_open(m2, c3, d8, n16, y2, x4) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y2, x4);
        return crypto_box_open_afternm(m2, c3, d8, n16, k3);
      }
      var K3 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m2, n16) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i4, j3, h3, l4, a9, b4, c3, d8;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n16 >= 128) {
          for (i4 = 0; i4 < 16; i4++) {
            j3 = 8 * i4 + pos;
            wh[i4] = m2[j3 + 0] << 24 | m2[j3 + 1] << 16 | m2[j3 + 2] << 8 | m2[j3 + 3];
            wl[i4] = m2[j3 + 4] << 24 | m2[j3 + 5] << 16 | m2[j3 + 6] << 8 | m2[j3 + 7];
          }
          for (i4 = 0; i4 < 80; i4++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h3 = ah7;
            l4 = al7;
            a9 = l4 & 65535;
            b4 = l4 >>> 16;
            c3 = h3 & 65535;
            d8 = h3 >>> 16;
            h3 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l4 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a9 += l4 & 65535;
            b4 += l4 >>> 16;
            c3 += h3 & 65535;
            d8 += h3 >>> 16;
            h3 = ah4 & ah5 ^ ~ah4 & ah6;
            l4 = al4 & al5 ^ ~al4 & al6;
            a9 += l4 & 65535;
            b4 += l4 >>> 16;
            c3 += h3 & 65535;
            d8 += h3 >>> 16;
            h3 = K3[i4 * 2];
            l4 = K3[i4 * 2 + 1];
            a9 += l4 & 65535;
            b4 += l4 >>> 16;
            c3 += h3 & 65535;
            d8 += h3 >>> 16;
            h3 = wh[i4 % 16];
            l4 = wl[i4 % 16];
            a9 += l4 & 65535;
            b4 += l4 >>> 16;
            c3 += h3 & 65535;
            d8 += h3 >>> 16;
            b4 += a9 >>> 16;
            c3 += b4 >>> 16;
            d8 += c3 >>> 16;
            th = c3 & 65535 | d8 << 16;
            tl = a9 & 65535 | b4 << 16;
            h3 = th;
            l4 = tl;
            a9 = l4 & 65535;
            b4 = l4 >>> 16;
            c3 = h3 & 65535;
            d8 = h3 >>> 16;
            h3 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l4 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a9 += l4 & 65535;
            b4 += l4 >>> 16;
            c3 += h3 & 65535;
            d8 += h3 >>> 16;
            h3 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l4 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a9 += l4 & 65535;
            b4 += l4 >>> 16;
            c3 += h3 & 65535;
            d8 += h3 >>> 16;
            b4 += a9 >>> 16;
            c3 += b4 >>> 16;
            d8 += c3 >>> 16;
            bh7 = c3 & 65535 | d8 << 16;
            bl7 = a9 & 65535 | b4 << 16;
            h3 = bh3;
            l4 = bl3;
            a9 = l4 & 65535;
            b4 = l4 >>> 16;
            c3 = h3 & 65535;
            d8 = h3 >>> 16;
            h3 = th;
            l4 = tl;
            a9 += l4 & 65535;
            b4 += l4 >>> 16;
            c3 += h3 & 65535;
            d8 += h3 >>> 16;
            b4 += a9 >>> 16;
            c3 += b4 >>> 16;
            d8 += c3 >>> 16;
            bh3 = c3 & 65535 | d8 << 16;
            bl3 = a9 & 65535 | b4 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i4 % 16 === 15) {
              for (j3 = 0; j3 < 16; j3++) {
                h3 = wh[j3];
                l4 = wl[j3];
                a9 = l4 & 65535;
                b4 = l4 >>> 16;
                c3 = h3 & 65535;
                d8 = h3 >>> 16;
                h3 = wh[(j3 + 9) % 16];
                l4 = wl[(j3 + 9) % 16];
                a9 += l4 & 65535;
                b4 += l4 >>> 16;
                c3 += h3 & 65535;
                d8 += h3 >>> 16;
                th = wh[(j3 + 1) % 16];
                tl = wl[(j3 + 1) % 16];
                h3 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l4 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a9 += l4 & 65535;
                b4 += l4 >>> 16;
                c3 += h3 & 65535;
                d8 += h3 >>> 16;
                th = wh[(j3 + 14) % 16];
                tl = wl[(j3 + 14) % 16];
                h3 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l4 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a9 += l4 & 65535;
                b4 += l4 >>> 16;
                c3 += h3 & 65535;
                d8 += h3 >>> 16;
                b4 += a9 >>> 16;
                c3 += b4 >>> 16;
                d8 += c3 >>> 16;
                wh[j3] = c3 & 65535 | d8 << 16;
                wl[j3] = a9 & 65535 | b4 << 16;
              }
            }
          }
          h3 = ah0;
          l4 = al0;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[0];
          l4 = hl[0];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[0] = ah0 = c3 & 65535 | d8 << 16;
          hl[0] = al0 = a9 & 65535 | b4 << 16;
          h3 = ah1;
          l4 = al1;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[1];
          l4 = hl[1];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[1] = ah1 = c3 & 65535 | d8 << 16;
          hl[1] = al1 = a9 & 65535 | b4 << 16;
          h3 = ah2;
          l4 = al2;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[2];
          l4 = hl[2];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[2] = ah2 = c3 & 65535 | d8 << 16;
          hl[2] = al2 = a9 & 65535 | b4 << 16;
          h3 = ah3;
          l4 = al3;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[3];
          l4 = hl[3];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[3] = ah3 = c3 & 65535 | d8 << 16;
          hl[3] = al3 = a9 & 65535 | b4 << 16;
          h3 = ah4;
          l4 = al4;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[4];
          l4 = hl[4];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[4] = ah4 = c3 & 65535 | d8 << 16;
          hl[4] = al4 = a9 & 65535 | b4 << 16;
          h3 = ah5;
          l4 = al5;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[5];
          l4 = hl[5];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[5] = ah5 = c3 & 65535 | d8 << 16;
          hl[5] = al5 = a9 & 65535 | b4 << 16;
          h3 = ah6;
          l4 = al6;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[6];
          l4 = hl[6];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[6] = ah6 = c3 & 65535 | d8 << 16;
          hl[6] = al6 = a9 & 65535 | b4 << 16;
          h3 = ah7;
          l4 = al7;
          a9 = l4 & 65535;
          b4 = l4 >>> 16;
          c3 = h3 & 65535;
          d8 = h3 >>> 16;
          h3 = hh[7];
          l4 = hl[7];
          a9 += l4 & 65535;
          b4 += l4 >>> 16;
          c3 += h3 & 65535;
          d8 += h3 >>> 16;
          b4 += a9 >>> 16;
          c3 += b4 >>> 16;
          d8 += c3 >>> 16;
          hh[7] = ah7 = c3 & 65535 | d8 << 16;
          hl[7] = al7 = a9 & 65535 | b4 << 16;
          pos += 128;
          n16 -= 128;
        }
        return n16;
      }
      function crypto_hash(out, m2, n16) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x4 = new Uint8Array(256), i4, b4 = n16;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m2, n16);
        n16 %= 128;
        for (i4 = 0; i4 < n16; i4++) x4[i4] = m2[b4 - n16 + i4];
        x4[n16] = 128;
        n16 = 256 - 128 * (n16 < 112 ? 1 : 0);
        x4[n16 - 9] = 0;
        ts64(x4, n16 - 8, b4 / 536870912 | 0, b4 << 3);
        crypto_hashblocks_hl(hh, hl, x4, n16);
        for (i4 = 0; i4 < 8; i4++) ts64(out, 8 * i4, hh[i4], hl[i4]);
        return 0;
      }
      function add(p6, q3) {
        var a9 = gf(), b4 = gf(), c3 = gf(), d8 = gf(), e14 = gf(), f6 = gf(), g2 = gf(), h3 = gf(), t11 = gf();
        Z3(a9, p6[1], p6[0]);
        Z3(t11, q3[1], q3[0]);
        M3(a9, a9, t11);
        A5(b4, p6[0], p6[1]);
        A5(t11, q3[0], q3[1]);
        M3(b4, b4, t11);
        M3(c3, p6[3], q3[3]);
        M3(c3, c3, D22);
        M3(d8, p6[2], q3[2]);
        A5(d8, d8, d8);
        Z3(e14, b4, a9);
        Z3(f6, d8, c3);
        A5(g2, d8, c3);
        A5(h3, b4, a9);
        M3(p6[0], e14, f6);
        M3(p6[1], h3, g2);
        M3(p6[2], g2, f6);
        M3(p6[3], e14, h3);
      }
      function cswap(p6, q3, b4) {
        var i4;
        for (i4 = 0; i4 < 4; i4++) {
          sel25519(p6[i4], q3[i4], b4);
        }
      }
      function pack(r9, p6) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p6[2]);
        M3(tx, p6[0], zi);
        M3(ty, p6[1], zi);
        pack25519(r9, ty);
        r9[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p6, q3, s4) {
        var b4, i4;
        set25519(p6[0], gf0);
        set25519(p6[1], gf1);
        set25519(p6[2], gf1);
        set25519(p6[3], gf0);
        for (i4 = 255; i4 >= 0; --i4) {
          b4 = s4[i4 / 8 | 0] >> (i4 & 7) & 1;
          cswap(p6, q3, b4);
          add(q3, p6);
          add(p6, p6);
          cswap(p6, q3, b4);
        }
      }
      function scalarbase(p6, s4) {
        var q3 = [gf(), gf(), gf(), gf()];
        set25519(q3[0], X3);
        set25519(q3[1], Y3);
        set25519(q3[2], gf1);
        M3(q3[3], X3, Y3);
        scalarmult(p6, q3, s4);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d8 = new Uint8Array(64);
        var p6 = [gf(), gf(), gf(), gf()];
        var i4;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d8, sk, 32);
        d8[0] &= 248;
        d8[31] &= 127;
        d8[31] |= 64;
        scalarbase(p6, d8);
        pack(pk, p6);
        for (i4 = 0; i4 < 32; i4++) sk[i4 + 32] = pk[i4];
        return 0;
      }
      var L4 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r9, x4) {
        var carry, i4, j3, k3;
        for (i4 = 63; i4 >= 32; --i4) {
          carry = 0;
          for (j3 = i4 - 32, k3 = i4 - 12; j3 < k3; ++j3) {
            x4[j3] += carry - 16 * x4[i4] * L4[j3 - (i4 - 32)];
            carry = Math.floor((x4[j3] + 128) / 256);
            x4[j3] -= carry * 256;
          }
          x4[j3] += carry;
          x4[i4] = 0;
        }
        carry = 0;
        for (j3 = 0; j3 < 32; j3++) {
          x4[j3] += carry - (x4[31] >> 4) * L4[j3];
          carry = x4[j3] >> 8;
          x4[j3] &= 255;
        }
        for (j3 = 0; j3 < 32; j3++) x4[j3] -= carry * L4[j3];
        for (i4 = 0; i4 < 32; i4++) {
          x4[i4 + 1] += x4[i4] >> 8;
          r9[i4] = x4[i4] & 255;
        }
      }
      function reduce(r9) {
        var x4 = new Float64Array(64), i4;
        for (i4 = 0; i4 < 64; i4++) x4[i4] = r9[i4];
        for (i4 = 0; i4 < 64; i4++) r9[i4] = 0;
        modL(r9, x4);
      }
      function crypto_sign(sm, m2, n16, sk) {
        var d8 = new Uint8Array(64), h3 = new Uint8Array(64), r9 = new Uint8Array(64);
        var i4, j3, x4 = new Float64Array(64);
        var p6 = [gf(), gf(), gf(), gf()];
        crypto_hash(d8, sk, 32);
        d8[0] &= 248;
        d8[31] &= 127;
        d8[31] |= 64;
        var smlen = n16 + 64;
        for (i4 = 0; i4 < n16; i4++) sm[64 + i4] = m2[i4];
        for (i4 = 0; i4 < 32; i4++) sm[32 + i4] = d8[32 + i4];
        crypto_hash(r9, sm.subarray(32), n16 + 32);
        reduce(r9);
        scalarbase(p6, r9);
        pack(sm, p6);
        for (i4 = 32; i4 < 64; i4++) sm[i4] = sk[i4];
        crypto_hash(h3, sm, n16 + 64);
        reduce(h3);
        for (i4 = 0; i4 < 64; i4++) x4[i4] = 0;
        for (i4 = 0; i4 < 32; i4++) x4[i4] = r9[i4];
        for (i4 = 0; i4 < 32; i4++) {
          for (j3 = 0; j3 < 32; j3++) {
            x4[i4 + j3] += h3[i4] * d8[j3];
          }
        }
        modL(sm.subarray(32), x4);
        return smlen;
      }
      function unpackneg(r9, p6) {
        var t11 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r9[2], gf1);
        unpack25519(r9[1], p6);
        S2(num, r9[1]);
        M3(den, num, D2);
        Z3(num, num, r9[2]);
        A5(den, r9[2], den);
        S2(den2, den);
        S2(den4, den2);
        M3(den6, den4, den2);
        M3(t11, den6, num);
        M3(t11, t11, den);
        pow2523(t11, t11);
        M3(t11, t11, num);
        M3(t11, t11, den);
        M3(t11, t11, den);
        M3(r9[0], t11, den);
        S2(chk, r9[0]);
        M3(chk, chk, den);
        if (neq25519(chk, num)) M3(r9[0], r9[0], I4);
        S2(chk, r9[0]);
        M3(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r9[0]) === p6[31] >> 7) Z3(r9[0], gf0, r9[0]);
        M3(r9[3], r9[0], r9[1]);
        return 0;
      }
      function crypto_sign_open(m2, sm, n16, pk) {
        var i4;
        var t11 = new Uint8Array(32), h3 = new Uint8Array(64);
        var p6 = [gf(), gf(), gf(), gf()], q3 = [gf(), gf(), gf(), gf()];
        if (n16 < 64) return -1;
        if (unpackneg(q3, pk)) return -1;
        for (i4 = 0; i4 < n16; i4++) m2[i4] = sm[i4];
        for (i4 = 0; i4 < 32; i4++) m2[i4 + 32] = pk[i4];
        crypto_hash(h3, m2, n16);
        reduce(h3);
        scalarmult(p6, q3, h3);
        scalarbase(q3, sm.subarray(32));
        add(p6, q3);
        pack(t11, p6);
        n16 -= 64;
        if (crypto_verify_32(sm, 0, t11, 0)) {
          for (i4 = 0; i4 < n16; i4++) m2[i4] = 0;
          return -1;
        }
        for (i4 = 0; i4 < n16; i4++) m2[i4] = sm[i4 + 64];
        return n16;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl3.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D2,
        L: L4,
        pack25519,
        unpack25519,
        M: M3,
        A: A5,
        S: S2,
        Z: Z3,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k3, n16) {
        if (k3.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n16.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i4 = 0; i4 < arguments.length; i4++) {
          if (!(arguments[i4] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i4 = 0; i4 < arr.length; i4++) arr[i4] = 0;
      }
      nacl3.randomBytes = function(n16) {
        var b4 = new Uint8Array(n16);
        randombytes(b4, n16);
        return b4;
      };
      nacl3.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c3 = new Uint8Array(m2.length);
        for (var i4 = 0; i4 < msg.length; i4++) m2[i4 + crypto_secretbox_ZEROBYTES] = msg[i4];
        crypto_secretbox(c3, m2, m2.length, nonce, key);
        return c3.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl3.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c3 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m2 = new Uint8Array(c3.length);
        for (var i4 = 0; i4 < box.length; i4++) c3[i4 + crypto_secretbox_BOXZEROBYTES] = box[i4];
        if (c3.length < 32) return null;
        if (crypto_secretbox_open(m2, c3, c3.length, nonce, key) !== 0) return null;
        return m2.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl3.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl3.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl3.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl3.scalarMult = function(n16, p6) {
        checkArrayTypes(n16, p6);
        if (n16.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p6.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q3 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q3, n16, p6);
        return q3;
      };
      nacl3.scalarMult.base = function(n16) {
        checkArrayTypes(n16);
        if (n16.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q3 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q3, n16);
        return q3;
      };
      nacl3.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl3.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl3.box = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox(msg, nonce, k3);
      };
      nacl3.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k3 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k3, publicKey, secretKey);
        return k3;
      };
      nacl3.box.after = nacl3.secretbox;
      nacl3.box.open = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl3.box.before(publicKey, secretKey);
        return nacl3.secretbox.open(msg, nonce, k3);
      };
      nacl3.box.open.after = nacl3.secretbox.open;
      nacl3.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl3.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl3.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl3.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl3.box.nonceLength = crypto_box_NONCEBYTES;
      nacl3.box.overheadLength = nacl3.secretbox.overheadLength;
      nacl3.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl3.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m2 = new Uint8Array(mlen);
        for (var i4 = 0; i4 < m2.length; i4++) m2[i4] = tmp[i4];
        return m2;
      };
      nacl3.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl3.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i4 = 0; i4 < sig.length; i4++) sig[i4] = signedMsg[i4];
        return sig;
      };
      nacl3.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i4;
        for (i4 = 0; i4 < crypto_sign_BYTES; i4++) sm[i4] = sig[i4];
        for (i4 = 0; i4 < msg.length; i4++) sm[i4 + crypto_sign_BYTES] = msg[i4];
        return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
      };
      nacl3.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i4 = 0; i4 < pk.length; i4++) pk[i4] = secretKey[32 + i4];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl3.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i4 = 0; i4 < 32; i4++) sk[i4] = seed[i4];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl3.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl3.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl3.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl3.sign.signatureLength = crypto_sign_BYTES;
      nacl3.hash = function(msg) {
        checkArrayTypes(msg);
        var h3 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h3, msg, msg.length);
        return h3;
      };
      nacl3.hash.hashLength = crypto_hash_BYTES;
      nacl3.verify = function(x4, y2) {
        checkArrayTypes(x4, y2);
        if (x4.length === 0 || y2.length === 0) return false;
        if (x4.length !== y2.length) return false;
        return vn(x4, 0, y2, 0, x4.length) === 0 ? true : false;
      };
      nacl3.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl3.setPRNG(function(x4, n16) {
            var i4, v6 = new Uint8Array(n16);
            for (i4 = 0; i4 < n16; i4 += QUOTA) {
              crypto2.getRandomValues(v6.subarray(i4, i4 + Math.min(n16 - i4, QUOTA)));
            }
            for (i4 = 0; i4 < n16; i4++) x4[i4] = v6[i4];
            cleanup(v6);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto();
          if (crypto2 && crypto2.randomBytes) {
            nacl3.setPRNG(function(x4, n16) {
              var i4, v6 = crypto2.randomBytes(n16);
              for (i4 = 0; i4 < n16; i4++) x4[i4] = v6[i4];
              cleanup(v6);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/ed2curve/ed2curve.js
var require_ed2curve = __commonJS({
  "node_modules/ed2curve/ed2curve.js"(exports, module) {
    (function(root, f6) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) module.exports = f6(require_nacl_fast());
      else root.ed2curve = f6(root.nacl);
    })(exports, function(nacl3) {
      "use strict";
      if (!nacl3) throw new Error("tweetnacl not loaded");
      var gf = function(init) {
        var i4, r9 = new Float64Array(16);
        if (init) for (i4 = 0; i4 < init.length; i4++) r9[i4] = init[i4];
        return r9;
      };
      var gf0 = gf(), gf1 = gf([1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I4 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function car25519(o12) {
        var c3;
        var i4;
        for (i4 = 0; i4 < 16; i4++) {
          o12[i4] += 65536;
          c3 = Math.floor(o12[i4] / 65536);
          o12[(i4 + 1) * (i4 < 15 ? 1 : 0)] += c3 - 1 + 37 * (c3 - 1) * (i4 === 15 ? 1 : 0);
          o12[i4] -= c3 * 65536;
        }
      }
      function sel25519(p6, q3, b4) {
        var t11, c3 = ~(b4 - 1);
        for (var i4 = 0; i4 < 16; i4++) {
          t11 = c3 & (p6[i4] ^ q3[i4]);
          p6[i4] ^= t11;
          q3[i4] ^= t11;
        }
      }
      function unpack25519(o12, n16) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o12[i4] = n16[2 * i4] + (n16[2 * i4 + 1] << 8);
        o12[15] &= 32767;
      }
      function A5(o12, a9, b4) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o12[i4] = a9[i4] + b4[i4] | 0;
      }
      function Z3(o12, a9, b4) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o12[i4] = a9[i4] - b4[i4] | 0;
      }
      function M3(o12, a9, b4) {
        var i4, j3, t11 = new Float64Array(31);
        for (i4 = 0; i4 < 31; i4++) t11[i4] = 0;
        for (i4 = 0; i4 < 16; i4++) {
          for (j3 = 0; j3 < 16; j3++) {
            t11[i4 + j3] += a9[i4] * b4[j3];
          }
        }
        for (i4 = 0; i4 < 15; i4++) {
          t11[i4] += 38 * t11[i4 + 16];
        }
        for (i4 = 0; i4 < 16; i4++) o12[i4] = t11[i4];
        car25519(o12);
        car25519(o12);
      }
      function S2(o12, a9) {
        M3(o12, a9, a9);
      }
      function inv25519(o12, i4) {
        var c3 = gf();
        var a9;
        for (a9 = 0; a9 < 16; a9++) c3[a9] = i4[a9];
        for (a9 = 253; a9 >= 0; a9--) {
          S2(c3, c3);
          if (a9 !== 2 && a9 !== 4) M3(c3, c3, i4);
        }
        for (a9 = 0; a9 < 16; a9++) o12[a9] = c3[a9];
      }
      function pack25519(o12, n16) {
        var i4, j3, b4;
        var m2 = gf(), t11 = gf();
        for (i4 = 0; i4 < 16; i4++) t11[i4] = n16[i4];
        car25519(t11);
        car25519(t11);
        car25519(t11);
        for (j3 = 0; j3 < 2; j3++) {
          m2[0] = t11[0] - 65517;
          for (i4 = 1; i4 < 15; i4++) {
            m2[i4] = t11[i4] - 65535 - (m2[i4 - 1] >> 16 & 1);
            m2[i4 - 1] &= 65535;
          }
          m2[15] = t11[15] - 32767 - (m2[14] >> 16 & 1);
          b4 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t11, m2, 1 - b4);
        }
        for (i4 = 0; i4 < 16; i4++) {
          o12[2 * i4] = t11[i4] & 255;
          o12[2 * i4 + 1] = t11[i4] >> 8;
        }
      }
      function par25519(a9) {
        var d8 = new Uint8Array(32);
        pack25519(d8, a9);
        return d8[0] & 1;
      }
      function vn(x4, xi, y2, yi, n16) {
        var i4, d8 = 0;
        for (i4 = 0; i4 < n16; i4++) d8 |= x4[xi + i4] ^ y2[yi + i4];
        return (1 & d8 - 1 >>> 8) - 1;
      }
      function crypto_verify_32(x4, xi, y2, yi) {
        return vn(x4, xi, y2, yi, 32);
      }
      function neq25519(a9, b4) {
        var c3 = new Uint8Array(32), d8 = new Uint8Array(32);
        pack25519(c3, a9);
        pack25519(d8, b4);
        return crypto_verify_32(c3, 0, d8, 0);
      }
      function pow2523(o12, i4) {
        var c3 = gf();
        var a9;
        for (a9 = 0; a9 < 16; a9++) c3[a9] = i4[a9];
        for (a9 = 250; a9 >= 0; a9--) {
          S2(c3, c3);
          if (a9 !== 1) M3(c3, c3, i4);
        }
        for (a9 = 0; a9 < 16; a9++) o12[a9] = c3[a9];
      }
      function set25519(r9, a9) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) r9[i4] = a9[i4] | 0;
      }
      function unpackneg(r9, p6) {
        var t11 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r9[2], gf1);
        unpack25519(r9[1], p6);
        S2(num, r9[1]);
        M3(den, num, D2);
        Z3(num, num, r9[2]);
        A5(den, r9[2], den);
        S2(den2, den);
        S2(den4, den2);
        M3(den6, den4, den2);
        M3(t11, den6, num);
        M3(t11, t11, den);
        pow2523(t11, t11);
        M3(t11, t11, num);
        M3(t11, t11, den);
        M3(t11, t11, den);
        M3(r9[0], t11, den);
        S2(chk, r9[0]);
        M3(chk, chk, den);
        if (neq25519(chk, num)) M3(r9[0], r9[0], I4);
        S2(chk, r9[0]);
        M3(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r9[0]) === p6[31] >> 7) Z3(r9[0], gf0, r9[0]);
        M3(r9[3], r9[0], r9[1]);
        return 0;
      }
      function convertPublicKey(pk) {
        var z3 = new Uint8Array(32), q3 = [gf(), gf(), gf(), gf()], a9 = gf(), b4 = gf();
        if (unpackneg(q3, pk)) return null;
        var y2 = q3[1];
        A5(a9, gf1, y2);
        Z3(b4, gf1, y2);
        inv25519(b4, b4);
        M3(a9, a9, b4);
        pack25519(z3, a9);
        return z3;
      }
      function convertSecretKey(sk) {
        var d8 = new Uint8Array(64), o12 = new Uint8Array(32), i4;
        nacl3.lowlevel.crypto_hash(d8, sk, 32);
        d8[0] &= 248;
        d8[31] &= 127;
        d8[31] |= 64;
        for (i4 = 0; i4 < 32; i4++) o12[i4] = d8[i4];
        for (i4 = 0; i4 < 64; i4++) d8[i4] = 0;
        return o12;
      }
      function convertKeyPair(edKeyPair) {
        var publicKey = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey) return null;
        return {
          publicKey,
          secretKey: convertSecretKey(edKeyPair.secretKey)
        };
      }
      return {
        convertPublicKey,
        convertSecretKey,
        convertKeyPair
      };
    });
  }
});

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// node_modules/@wallet-standard/app/lib/esm/wallets.js
var __classPrivateFieldGet = function(receiver, state, kind, f6) {
  if (kind === "a" && !f6) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f6 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f6 : kind === "a" ? f6.call(receiver) : f6 ? f6.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f6) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f6) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f6 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f6.call(receiver, value) : f6 ? f6.value = value : state.set(receiver, value), value;
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registeredWalletsSet = /* @__PURE__ */ new Set();
function addRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.add(wallet);
}
function removeRegisteredWallet(wallet) {
  cachedWalletsArray = void 0;
  registeredWalletsSet.delete(wallet);
}
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get, on });
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  var _a;
  wallets2 = wallets2.filter((wallet) => !registeredWalletsSet.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => addRegisteredWallet(wallet));
  (_a = listeners["register"]) == null ? void 0 : _a.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    var _a2;
    wallets2.forEach((wallet) => removeRegisteredWallet(wallet));
    (_a2 = listeners["unregister"]) == null ? void 0 : _a2.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
var cachedWalletsArray;
function get() {
  if (!cachedWalletsArray) {
    cachedWalletsArray = [...registeredWalletsSet];
  }
  return cachedWalletsArray;
}
function on(event, listener) {
  var _a;
  ((_a = listeners[event]) == null ? void 0 : _a.push(listener)) || (listeners[event] = [listener]);
  return function off() {
    var _a2;
    listeners[event] = (_a2 = listeners[event]) == null ? void 0 : _a2.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
var AppReadyEvent = class extends Event {
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/errors/lib/esm/codes.js
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND = 3834e3;
var WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND = 3834001;
var WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED = 4001e3;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED = 616e4;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED = 6160001;
var WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED = 6160002;

// node_modules/@wallet-standard/errors/lib/esm/messages.js
var WalletStandardErrorMessages = {
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_CHAIN_UNSUPPORTED]: "The wallet account $address does not support the chain `$chain`",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_ACCOUNT_FEATURE_UNIMPLEMENTED]: "The wallet account $address does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__FEATURES__WALLET_FEATURE_UNIMPLEMENTED]: "The wallet '$walletName' does not support the `$featureName` feature",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_ACCOUNT_NOT_FOUND]: "No account with address $address could be found in the '$walletName' wallet",
  [WALLET_STANDARD_ERROR__REGISTRY__WALLET_NOT_FOUND]: "No underlying Wallet Standard wallet could be found for this handle. This can happen if the wallet associated with the handle has been unregistered.",
  [WALLET_STANDARD_ERROR__USER__REQUEST_REJECTED]: "The user rejected the request"
};

// node_modules/@wallet-standard/errors/lib/esm/message-formatter.js
var StateType;
(function(StateType2) {
  StateType2[StateType2["EscapeSequence"] = 0] = "EscapeSequence";
  StateType2[StateType2["Text"] = 1] = "Text";
  StateType2[StateType2["Variable"] = 2] = "Variable";
})(StateType || (StateType = {}));

// node_modules/@wallet-standard/wallet/lib/esm/register.js
var _RegisterWalletEvent_detail;
_RegisterWalletEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/wallet/lib/esm/util.js
var _ReadonlyWalletAccount_address;
var _ReadonlyWalletAccount_publicKey;
var _ReadonlyWalletAccount_chains;
var _ReadonlyWalletAccount_features;
var _ReadonlyWalletAccount_label;
var _ReadonlyWalletAccount_icon;
_ReadonlyWalletAccount_address = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_publicKey = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_chains = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_features = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_label = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_icon = /* @__PURE__ */ new WeakMap();

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7OMCNXQ7.mjs
var n2 = ["aptos:account", "aptos:connect", "aptos:disconnect", "aptos:network", "aptos:onAccountChange", "aptos:onNetworkChange", "aptos:signMessage", "aptos:signTransaction"];
function i(t11, e14 = []) {
  return [...n2, ...e14].every((s4) => s4 in t11.features);
}
function d() {
  let { get: t11, on: e14 } = getWallets(), s4 = t11(), a9 = [];
  return s4.map((l4) => {
    i(l4) && a9.push(l4);
  }), { aptosWallets: a9, on: e14 };
}

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-J4LEOBAE.mjs
var a4 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(a4 || {});
var r = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r2 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r2 || {});

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-N2SQW5WO.mjs
var n7 = "aptos:signAndSubmitTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MECB2PDY.mjs
var n8 = "aptos:signIn";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-BIF2XL2R.mjs
var e6 = "aptos:signMessage";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FOFHRLON.mjs
var n9 = "aptos:signTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-OYMA2PWW.mjs
var o4 = "aptos:connect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7KTK52MK.mjs
var o5 = "aptos:disconnect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-EKJ7Y4LP.mjs
var t5 = "aptos:account";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FTTDX4QF.mjs
var t6 = "aptos:network";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MNFE4AOY.mjs
var n10 = "aptos:onAccountChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MJDSOKP4.mjs
var e7 = "aptos:onNetworkChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-GQXE77Y5.mjs
var d3 = class o6 extends x {
  constructor({ address: e14, publicKey: n16, ansName: t11 }) {
    super(), this.address = l.from(e14), this.publicKey = n16, this.ansName = t11;
  }
  serialize(e14) {
    if (this.address.serialize(e14), this.publicKey instanceof b) e14.serializeU32AsUleb128(W.Ed25519);
    else if (this.publicKey instanceof Y) e14.serializeU32AsUleb128(W.MultiEd25519);
    else if (this.publicKey instanceof I) e14.serializeU32AsUleb128(W.SingleKey);
    else if (this.publicKey instanceof G) e14.serializeU32AsUleb128(W.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e14), e14.serializeStr(this.ansName ?? "");
  }
  static deserialize(e14) {
    let n16 = l.deserialize(e14), t11 = e14.deserializeUleb128AsU32(), s4;
    switch (t11) {
      case W.Ed25519:
        s4 = b.deserialize(e14);
        break;
      case W.MultiEd25519:
        s4 = Y.deserialize(e14);
        break;
      case W.SingleKey:
        s4 = I.deserialize(e14);
        break;
      case W.MultiKey:
        s4 = G.deserialize(e14);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t11}`);
    }
    let b4 = e14.deserializeStr() || void 0;
    return new o6({ address: n16, publicKey: s4, ansName: b4 });
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
var t7 = "aptos:devnet";
var o7 = "aptos:testnet";
var A2 = "aptos:localnet";
var T2 = "aptos:mainnet";
var e8 = [t7, o7, A2, T2];

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-J4LEOBAE.mjs
var a5 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(a5 || {});
var r3 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });
var s2 = class n11 extends Error {
  constructor(t11, o12) {
    var _a, _b;
    super(o12 ?? ((_a = r3[t11]) == null ? void 0 : _a.message) ?? "Unknown error occurred"), this.code = t11, this.status = ((_b = r3[t11]) == null ? void 0 : _b.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, n11.prototype);
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r4 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r4 || {});

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-GQXE77Y5.mjs
var d5 = class o8 extends x {
  constructor({ address: e14, publicKey: n16, ansName: t11 }) {
    super(), this.address = l.from(e14), this.publicKey = n16, this.ansName = t11;
  }
  serialize(e14) {
    if (this.address.serialize(e14), this.publicKey instanceof b) e14.serializeU32AsUleb128(W.Ed25519);
    else if (this.publicKey instanceof Y) e14.serializeU32AsUleb128(W.MultiEd25519);
    else if (this.publicKey instanceof I) e14.serializeU32AsUleb128(W.SingleKey);
    else if (this.publicKey instanceof G) e14.serializeU32AsUleb128(W.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e14), e14.serializeStr(this.ansName ?? "");
  }
  static deserialize(e14) {
    let n16 = l.deserialize(e14), t11 = e14.deserializeUleb128AsU32(), s4;
    switch (t11) {
      case W.Ed25519:
        s4 = b.deserialize(e14);
        break;
      case W.MultiEd25519:
        s4 = Y.deserialize(e14);
        break;
      case W.SingleKey:
        s4 = I.deserialize(e14);
        break;
      case W.MultiKey:
        s4 = G.deserialize(e14);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t11}`);
    }
    let b4 = e14.deserializeStr() || void 0;
    return new o8({ address: n16, publicKey: s4, ansName: b4 });
  }
};

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-J4LEOBAE.mjs
var a6 = ((e14) => (e14[e14.Unauthorized = 4100] = "Unauthorized", e14[e14.Unsupported = 4200] = "Unsupported", e14[e14.InternalError = -30001] = "InternalError", e14))(a6 || {});
var r5 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r6 = ((e14) => (e14.APPROVED = "Approved", e14.REJECTED = "Rejected", e14))(r6 || {});

// node_modules/@aptos-connect/wallet-api/dist/index.mjs
function base64ToBytes(base64) {
  const binaryString = atob(base64);
  return Uint8Array.from(binaryString, (m2) => m2.charCodeAt(0));
}
function bytesToBase64(bytes) {
  const binaryString = String.fromCharCode(...bytes);
  return btoa(binaryString);
}
function bytesToBase64url(bytes) {
  return bytesToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function serializeAccountAuthenticatorInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serialize(value.authenticator);
}
function deserializeAccountAuthenticatorInput(deserializer) {
  const address = deserializer.deserialize(l);
  const authenticator = deserializer.deserialize(W2);
  return { address, authenticator };
}
function serializePublicKey(serializer, value) {
  if (value instanceof b) {
    serializer.serializeU32AsUleb128(W.Ed25519);
  } else if (value instanceof Y) {
    serializer.serializeU32AsUleb128(W.MultiEd25519);
  } else if (value instanceof I) {
    serializer.serializeU32AsUleb128(W.SingleKey);
  } else if (value instanceof G) {
    serializer.serializeU32AsUleb128(W.MultiKey);
  } else {
    throw new Error("Unexpected public key type");
  }
  serializer.serialize(value);
}
function deserializePublicKey(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case W.Ed25519:
      return deserializer.deserialize(b);
    case W.MultiEd25519:
      return deserializer.deserialize(Y);
    case W.SingleKey:
      return deserializer.deserialize(I);
    case W.MultiKey:
      return deserializer.deserialize(G);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
function serializeAccountInfo(serializer, value) {
  serializer.serialize(value.address);
  serializePublicKey(serializer, value.publicKey);
  serializer.serializeStr(value.name ?? "");
}
function deserializeAccountInfo(deserializer) {
  const address = deserializer.deserialize(l);
  const publicKey = deserializePublicKey(deserializer);
  const name = deserializer.deserializeStr();
  return {
    address,
    publicKey,
    ...name.length > 0 ? { name } : void 0
  };
}
function serializeAccountInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serializeBool(value.publicKey !== void 0);
  if (value.publicKey) {
    serializePublicKey(serializer, value.publicKey);
  }
}
function deserializeAccountInput(deserializer) {
  const address = deserializer.deserialize(l);
  const hasPublicKey = deserializer.deserializeBool();
  const publicKey = hasPublicKey ? deserializePublicKey(deserializer) : void 0;
  return { address, publicKey };
}
function serializeDappInfo(serializer, value) {
  serializer.serializeStr(value.domain);
  serializer.serializeStr(value.name);
  serializer.serializeBool(value.imageURI !== void 0);
  if (value.imageURI !== void 0) {
    serializer.serializeStr(value.imageURI);
  }
}
function deserializeDappInfo(deserializer) {
  const domain = deserializer.deserializeStr();
  const name = deserializer.deserializeStr();
  const hasImageUri = deserializer.deserializeBool();
  const imageURI = hasImageUri ? deserializer.deserializeStr() : void 0;
  return { domain, imageURI, name };
}
var EntryFunctionArgumentVariant = ((EntryFunctionArgumentVariant2) => {
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Undefined"] = 0] = "Undefined";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Array"] = 1] = "Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["String"] = 2] = "String";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Uint8Array"] = 3] = "Uint8Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["AccountAddress"] = 4] = "AccountAddress";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["FixedBytes"] = 5] = "FixedBytes";
  return EntryFunctionArgumentVariant2;
})(EntryFunctionArgumentVariant || {});
function serializeEntryFunctionArgument(serializer, argument) {
  if (argument === void 0 || argument === null) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    return;
  }
  if (Array.isArray(argument)) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.length);
    for (const subArgument of argument) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || typeof argument === "bigint") {
    serializer.serializeU32AsUleb128(
      2
      /* String */
    );
    serializer.serializeStr(argument.toString());
    return;
  }
  if (argument instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(argument);
    return;
  }
  if (argument instanceof ArrayBuffer) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(new Uint8Array(argument));
    return;
  }
  if ("values" in argument) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.values.length);
    for (const subArgument of argument.values) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if ("data" in argument) {
    serializer.serializeU32AsUleb128(
      4
      /* AccountAddress */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value === void 0) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      5
      /* FixedBytes */
    );
    serializer.serializeBytes(argument.value);
    return;
  }
  serializer.serializeU32AsUleb128(
    2
    /* String */
  );
  serializer.serializeStr(argument.value.toString());
}
function deserializeEntryFunctionArgument(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 0: {
      return void 0;
    }
    case 1: {
      const length = deserializer.deserializeUleb128AsU32();
      const args = [];
      for (let i4 = 0; i4 < length; i4 += 1) {
        const argument = deserializeEntryFunctionArgument(deserializer);
        args.push(argument);
      }
      return args;
    }
    case 3: {
      return deserializer.deserializeBytes();
    }
    case 4: {
      return deserializer.deserialize(l);
    }
    case 2: {
      return deserializer.deserializeStr();
    }
    case 5: {
      const bytes = deserializer.deserializeBytes();
      return new t(bytes);
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
var devnetBaseUrl = "https://api.devnet.aptoslabs.com";
var shelbynetBaseUrl = "https://api.shelbynet.aptoslabs.com";
var shelbynet = {
  // This is not reliable and might change in future releases, but it's useful to keep around as "unique id" for
  // the frontend
  chainId: 59,
  faucetUrl: "https://faucet.shelbynet.shelby.xyz",
  indexerUrl: `${shelbynetBaseUrl}/v1/graphql`,
  name: "shelbynet",
  nodeUrl: `${shelbynetBaseUrl}/v1`,
  // Note: using devnet's keyless services, so we don't have to spin up separate ones
  pepperUrl: `${devnetBaseUrl}/keyless/pepper/v0`,
  proverUrl: `${devnetBaseUrl}/keyless/prover/v0`
};
function serializeSignature(serializer, value) {
  if (value instanceof v) {
    serializer.serializeU32AsUleb128(W.Ed25519);
  } else if (value instanceof Ie) {
    serializer.serializeU32AsUleb128(W.MultiEd25519);
  } else if (value instanceof O) {
    serializer.serializeU32AsUleb128(W.SingleKey);
  } else {
    throw new Error("Unexpected signature type");
  }
  serializer.serialize(value);
}
function deserializeSignature(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case W.Ed25519:
      return deserializer.deserialize(v);
    case W.MultiEd25519:
      return deserializer.deserialize(Ie);
    case W.SingleKey:
      return deserializer.deserialize(O);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
var TransactionPayloadInputVariant = ((TransactionPayloadInputVariant2) => {
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["EntryFunction"] = 0] = "EntryFunction";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Script"] = 1] = "Script";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Multisig"] = 2] = "Multisig";
  return TransactionPayloadInputVariant2;
})(TransactionPayloadInputVariant || {});
function serializeTypeArguments(serializer, typeArguments) {
  serializer.serializeU32AsUleb128(typeArguments.length);
  for (const typeArgument of typeArguments) {
    const typeTag = typeof typeArgument === "string" ? _e(typeArgument, { allowGenerics: true }) : typeArgument;
    serializer.serialize(typeTag);
  }
}
function deserializeTypeArguments(deserializer) {
  const typeArguments = [];
  const typeArgumentsLength = deserializer.deserializeUleb128AsU32();
  for (let i4 = 0; i4 < typeArgumentsLength; i4 += 1) {
    const typeTag = deserializer.deserialize(_);
    typeArguments.push(typeTag);
  }
  return typeArguments;
}
function serializeEntryFunctionArguments(serializer, functionArguments) {
  serializer.serializeU32AsUleb128(functionArguments.length);
  for (const functionArgument of functionArguments) {
    serializeEntryFunctionArgument(serializer, functionArgument);
  }
}
function deserializeEntryFunctionArguments(deserializer) {
  const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
  const functionArguments = [];
  for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
    const functionArgument = deserializeEntryFunctionArgument(deserializer);
    functionArguments.push(functionArgument);
  }
  return functionArguments;
}
function serializeTransactionPayloadInput(serializer, value) {
  if ("multisigAddress" in value) {
    serializer.serializeU32AsUleb128(
      2
      /* Multisig */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
    const multisigAddress = l.from(value.multisigAddress);
    serializer.serialize(multisigAddress);
  } else if ("function" in value) {
    serializer.serializeU32AsUleb128(
      0
      /* EntryFunction */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  } else {
    serializer.serializeU32AsUleb128(
      1
      /* Script */
    );
    const bytecode = a.fromHexInput(value.bytecode);
    serializer.serializeBytes(bytecode.toUint8Array());
    serializer.serializeU32AsUleb128(value.functionArguments.length);
    for (const argument of value.functionArguments) {
      argument.serializeForScriptFunction(serializer);
    }
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  }
}
function deserializeTransactionPayloadInput(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 2: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      const multisigAddress = deserializer.deserialize(l);
      return {
        function: functionId,
        functionArguments,
        multisigAddress,
        typeArguments
      };
    }
    case 0: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        function: functionId,
        functionArguments,
        typeArguments
      };
    }
    case 1: {
      const bytecode = deserializer.deserializeBytes();
      const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
      const functionArguments = [];
      for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
        const argument = $a(deserializer);
        functionArguments.push(argument);
      }
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        bytecode,
        functionArguments,
        typeArguments
      };
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function chainIdToNetwork(chainId) {
  if (chainId === l2.mainnet) {
    return e.MAINNET;
  }
  if (chainId === l2.testnet) {
    return e.TESTNET;
  }
  if (chainId >= 50 && chainId < 100 || chainId >= 100 && chainId < 125) {
    return shelbynet.name;
  }
  return e.DEVNET;
}
function isSupportedNetwork(network) {
  return [
    e.MAINNET,
    e.TESTNET,
    e.DEVNET,
    shelbynet.name
  ].includes(network);
}
function serializeWalletRequest({
  dappInfo,
  name,
  version
}) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  const data = serializer.toUint8Array();
  return { data, name, version };
}
function deserializeWalletRequest({
  data,
  name,
  version
}) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  return { dappInfo, name, version };
}
function serializeWalletRequestWithArgs({
  args,
  dappInfo,
  name,
  version
}, serializeArgsFn) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  serializeArgsFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data, name, version };
}
function deserializeWalletRequestWithArgs({ data, name, version }, deserializeArgsFn) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  const args = deserializeArgsFn(deserializer);
  return { args, dappInfo, name, version };
}
var ConnectRequest;
((ConnectRequest2) => {
  ConnectRequest2.name = "connect";
  ConnectRequest2.supportedVersions = [1, 2, 3, 4];
  ConnectRequest2.currentVersion = 4;
  function serializeArgs(serializer, value) {
    serializer.serializeOptionStr(value.dappId);
    serializer.serializeOptionStr(value.dappEd25519PublicKeyB64);
    serializer.serializeOptionStr(value.preferredWalletName);
    serializer.serializeBool(value.claimOptions !== void 0);
    if (value.claimOptions) {
      serializer.serialize(value.claimOptions.secretKey);
      serializer.serializeStr(value.claimOptions.network);
      serializer.serializeOptionStr(value.claimOptions.asset);
      if (!isSupportedNetwork(value.claimOptions.network)) {
        throw new Error(`Unsupported network '${value.claimOptions.network}'`);
      }
    }
  }
  ConnectRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version) {
    if (version === 1) {
      return {};
    }
    const dappId = deserializer.deserializeOption("string");
    const dappEd25519PublicKeyB64 = deserializer.deserializeOption("string");
    const preferredWalletName = version >= 3 ? deserializer.deserializeOption("string") : void 0;
    const hasClaimOptions = version >= 4 ? deserializer.deserializeBool() : false;
    let claimOptions;
    if (hasClaimOptions) {
      const secretKey = deserializer.deserialize(L);
      const network = deserializer.deserializeStr();
      const asset = deserializer.deserializeOption("string");
      if (!isSupportedNetwork(network) || network === shelbynet.name) {
        throw new Error(`Unsupported network '${network}'`);
      }
      claimOptions = { asset, network, secretKey };
    }
    return {
      claimOptions,
      dappEd25519PublicKeyB64,
      dappId,
      preferredWalletName
    };
  }
  ConnectRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args = {}) {
    return serializeWalletRequestWithArgs(
      { args, dappInfo, name: ConnectRequest2.name, version: ConnectRequest2.currentVersion },
      serializeArgs
    );
  }
  ConnectRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequestWithArgs(
      request,
      (d8) => deserializeArgs(d8, request.version)
    );
  }
  ConnectRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === ConnectRequest2.name && ConnectRequest2.supportedVersions.includes(request.version);
  }
  ConnectRequest2.isSerialized = isSerialized;
})(ConnectRequest || (ConnectRequest = {}));
function makeUserApproval(args) {
  return { args, status: "approved" };
}
function makeUserResponseSerializeFn(serializeArgs) {
  return (serializer, value) => {
    serializer.serializeBool(value.status === "approved");
    if (value.status === "approved") {
      serializeArgs(serializer, value.args);
    }
  };
}
function makeUserResponseDeserializeFn(deserializeArgs) {
  return (deserializer) => {
    const isApproved = deserializer.deserializeBool();
    return isApproved ? { args: deserializeArgs(deserializer), status: "approved" } : { status: "dismissed" };
  };
}
function serializeWalletResponse(args, serializeFn) {
  const serializer = new n();
  serializeFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data };
}
function deserializeWalletResponse({ data }, deserializeFn) {
  const deserializer = new a2(data);
  const args = deserializeFn(deserializer);
  return { args };
}
var ConnectResponse;
((ConnectResponse2) => {
  ConnectResponse2.supportedVersions = [1, 2];
  ConnectResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAccountInfo(serializer, value.account);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAccountInfo(serializer, value.account);
    serializer.serializeOptionStr(
      value.pairing !== void 0 ? JSON.stringify(value.pairing) : void 0
    );
  }
  function deserializeApprovalArgs(deserializer) {
    const account = deserializeAccountInfo(deserializer);
    const serializedPairing = deserializer.deserializeOption("string");
    const pairing = serializedPairing !== void 0 ? JSON.parse(serializedPairing) : void 0;
    return { account, pairing };
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args, version = ConnectResponse2.currentVersion) {
    return serializeWalletResponse(
      args,
      version === 1 ? serializeArgsV1 : serializeArgs
    );
  }
  ConnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  ConnectResponse2.deserialize = deserialize;
})(ConnectResponse || (ConnectResponse = {}));
var DisconnectRequest;
((DisconnectRequest2) => {
  DisconnectRequest2.name = "disconnect";
  DisconnectRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: DisconnectRequest2.name, version: DisconnectRequest2.currentVersion });
  }
  DisconnectRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  DisconnectRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === DisconnectRequest2.name && request.version === DisconnectRequest2.currentVersion;
  }
  DisconnectRequest2.isSerialized = isSerialized;
})(DisconnectRequest || (DisconnectRequest = {}));
var DisconnectResponse;
((DisconnectResponse2) => {
  function serialize(args) {
    return serializeWalletResponse(args, () => {
    });
  }
  DisconnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, () => ({}));
  }
  DisconnectResponse2.deserialize = deserialize;
})(DisconnectResponse || (DisconnectResponse = {}));
var GetConnectedAccountsRequest;
((GetConnectedAccountsRequest2) => {
  GetConnectedAccountsRequest2.name = "getConnectedAccounts";
  GetConnectedAccountsRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: GetConnectedAccountsRequest2.name, version: GetConnectedAccountsRequest2.currentVersion });
  }
  GetConnectedAccountsRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  GetConnectedAccountsRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === GetConnectedAccountsRequest2.name && request.version === GetConnectedAccountsRequest2.currentVersion;
  }
  GetConnectedAccountsRequest2.isSerialized = isSerialized;
})(GetConnectedAccountsRequest || (GetConnectedAccountsRequest = {}));
var GetConnectedAccountsResponse;
((GetConnectedAccountsResponse2) => {
  function serializeArgs(serializer, args) {
    serializer.serializeU32AsUleb128(args.length);
    for (const account of args) {
      serializeAccountInfo(serializer, account);
    }
  }
  function deserializeArgs(deserializer) {
    const length = deserializer.deserializeUleb128AsU32();
    const accounts = [];
    for (let i4 = 0; i4 < length; i4 += 1) {
      accounts.push(deserializeAccountInfo(deserializer));
    }
    return accounts;
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  GetConnectedAccountsResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  GetConnectedAccountsResponse2.deserialize = deserialize;
})(GetConnectedAccountsResponse || (GetConnectedAccountsResponse = {}));
var IsConnectedRequest;
((IsConnectedRequest2) => {
  IsConnectedRequest2.name = "isConnected";
  IsConnectedRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: IsConnectedRequest2.name, version: IsConnectedRequest2.currentVersion });
  }
  IsConnectedRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  IsConnectedRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === IsConnectedRequest2.name && request.version === IsConnectedRequest2.currentVersion;
  }
  IsConnectedRequest2.isSerialized = isSerialized;
})(IsConnectedRequest || (IsConnectedRequest = {}));
var IsConnectedResponse;
((IsConnectedResponse2) => {
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value);
  }
  function deserializeArgs(deserializer) {
    return deserializer.deserializeBool();
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  IsConnectedResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  IsConnectedResponse2.deserialize = deserialize;
})(IsConnectedResponse || (IsConnectedResponse = {}));
var SignAndSubmitTransactionRequest;
((SignAndSubmitTransactionRequest2) => {
  SignAndSubmitTransactionRequest2.name = "signAndSubmitTransaction";
  SignAndSubmitTransactionRequest2.supportedVersions = [1, 2, 3, 4];
  SignAndSubmitTransactionRequest2.currentVersion = 4;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOption(value.network);
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeU32AsUleb128(value.feePayer ? 1 : 0);
    if (value.feePayer) {
      serializeAccountAuthenticatorInput(serializer, value.feePayer);
    }
  }
  SignAndSubmitTransactionRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const isPayloadBcsSerializable = version === 1 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(yt) : deserializeTransactionPayloadInput(deserializer);
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeUleb128AsU32();
    const feePayer = hasFeePayer ? deserializeAccountAuthenticatorInput(deserializer) : void 0;
    return {
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      signerAddress
    };
  }
  SignAndSubmitTransactionRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignAndSubmitTransactionRequest2.name, version: SignAndSubmitTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignAndSubmitTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignAndSubmitTransactionRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignAndSubmitTransactionRequest2.name && SignAndSubmitTransactionRequest2.supportedVersions.includes(request.version);
  }
  SignAndSubmitTransactionRequest2.isSerialized = isSerialized;
})(SignAndSubmitTransactionRequest || (SignAndSubmitTransactionRequest = {}));
var SignAndSubmitTransactionResponse;
((SignAndSubmitTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.txnHash);
  }
  function deserializeApprovalArgs(deserializer) {
    const txnHash = deserializer.deserializeStr();
    return { txnHash };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignAndSubmitTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignAndSubmitTransactionResponse2.deserialize = deserialize;
})(SignAndSubmitTransactionResponse || (SignAndSubmitTransactionResponse = {}));
function serializeAptosSignInInput(serializer, value) {
  serializer.serializeStr(JSON.stringify(value));
}
function deserializeAptosSignInInput(deserializer) {
  return JSON.parse(deserializer.deserializeStr());
}
var SignInRequest;
((SignInRequest2) => {
  SignInRequest2.name = "signIn";
  SignInRequest2.supportedVersions = [1, 2, 3];
  SignInRequest2.currentVersion = 3;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(
        `Unsupported network '${value.network}' in SignInRequest.serializeArgs`
      );
    }
    serializeAptosSignInInput(serializer, value);
    serializer.serializeStr(value.network);
  }
  SignInRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, _3) {
    return {
      ...deserializeAptosSignInInput(deserializer),
      network: deserializer.deserializeStr()
    };
  }
  SignInRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    return serializeWalletRequestWithArgs(
      { args, dappInfo, name: SignInRequest2.name, version: SignInRequest2.currentVersion },
      serializeArgs
    );
  }
  SignInRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequestWithArgs(
      request,
      (d8) => deserializeArgs(d8, request.version)
    );
  }
  SignInRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignInRequest2.name && SignInRequest2.supportedVersions.includes(request.version);
  }
  SignInRequest2.isSerialized = isSerialized;
})(SignInRequest || (SignInRequest = {}));
function serializeAptosSignInOutputV1(serializer, value) {
  serializeAccountInfo(serializer, value.account);
  serializer.serializeStr(JSON.stringify(value.input));
  serializer.serializeStr(value.plainText);
  serializeSignature(serializer, value.signature);
  serializer.serializeBytes(value.signingMessage);
  serializer.serializeStr(value.type);
}
function deserializeAptosSignInOutputV1(deserializer) {
  return {
    account: new d5(deserializeAccountInfo(deserializer)),
    input: JSON.parse(deserializer.deserializeStr()),
    plainText: deserializer.deserializeStr(),
    signature: deserializeSignature(deserializer),
    signingMessage: deserializer.deserializeBytes(),
    type: deserializer.deserializeStr()
  };
}
function serializeAptosSignInOutput(serializer, value) {
  serializeAccountInfo(serializer, value.account);
  serializer.serializeStr(JSON.stringify(value.input));
  serializeSignature(serializer, value.signature);
  serializer.serializeStr(value.type);
}
function deserializeAptosSignInOutput(deserializer) {
  return {
    account: new d5(deserializeAccountInfo(deserializer)),
    input: JSON.parse(deserializer.deserializeStr()),
    signature: deserializeSignature(deserializer),
    type: deserializer.deserializeStr()
  };
}
var SignInResponse;
((SignInResponse2) => {
  SignInResponse2.supportedVersions = [1, 2];
  SignInResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAptosSignInOutputV1(serializer, value);
  }
  function deserializeApprovalArgsV1(deserializer) {
    return deserializeAptosSignInOutputV1(deserializer);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAptosSignInOutput(serializer, value);
  }
  function deserializeApprovalArgs(deserializer) {
    return deserializeAptosSignInOutput(deserializer);
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgsV1 = makeUserResponseDeserializeFn(
    deserializeApprovalArgsV1
  );
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args, version = SignInResponse2.currentVersion) {
    return serializeWalletResponse(
      args,
      version === 1 ? serializeArgsV1 : serializeArgs
    );
  }
  SignInResponse2.serialize = serialize;
  function deserialize(serializedResponse, version = SignInResponse2.currentVersion) {
    return deserializeWalletResponse(
      serializedResponse,
      version === 1 ? deserializeArgsV1 : deserializeArgs
    );
  }
  SignInResponse2.deserialize = deserialize;
})(SignInResponse || (SignInResponse = {}));
var SignMessageRequest;
((SignMessageRequest2) => {
  SignMessageRequest2.name = "signMessage";
  SignMessageRequest2.supportedVersions = [1, 2];
  SignMessageRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeU8(value.chainId);
    serializer.serializeBytes(value.nonce);
    serializer.serializeBytes(value.message);
  }
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 2 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const chainId = deserializer.deserializeU8();
    const nonce = deserializer.deserializeBytes();
    const message = deserializer.deserializeBytes();
    return { chainId, message, nonce, signerAddress };
  }
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignMessageRequest2.name, version: SignMessageRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignMessageRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (d8) => deserializeArgs(d8, serializedRequest.version)
    );
  }
  SignMessageRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignMessageRequest2.name && request.version === SignMessageRequest2.currentVersion;
  }
  SignMessageRequest2.isSerialized = isSerialized;
})(SignMessageRequest || (SignMessageRequest = {}));
var SignMessageResponse;
((SignMessageResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.fullMessage);
    serializeSignature(serializer, value.signature);
  }
  function deserializeApprovalArgs(deserializer) {
    const fullMessage = deserializer.deserializeStr();
    const signature = deserializeSignature(deserializer);
    return { fullMessage, signature };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignMessageResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignMessageResponse2.deserialize = deserialize;
})(SignMessageResponse || (SignMessageResponse = {}));
var SignTransactionRequest;
((SignTransactionRequest2) => {
  SignTransactionRequest2.name = "signTransaction";
  SignTransactionRequest2.supportedVersions = [1, 2, 3, 4, 5];
  SignTransactionRequest2.currentVersion = 5;
  function normalizeArgs(args) {
    const {
      feePayer,
      secondarySigners,
      senderPublicKey,
      signerAddress,
      transaction
    } = args;
    const sender = {
      address: transaction.sender,
      publicKey: senderPublicKey
    };
    const network = chainIdToNetwork(args.transaction.chain_id.chainId);
    return {
      expirationTimestamp: Number(transaction.expiration_timestamp_secs),
      feePayer,
      gasUnitPrice: Number(transaction.gas_unit_price),
      maxGasAmount: Number(transaction.max_gas_amount),
      network,
      payload: transaction.payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  SignTransactionRequest2.normalizeArgs = normalizeArgs;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOption(value.network);
    serializer.serializeBool(value.sender !== void 0);
    if (value.sender !== void 0) {
      serializeAccountInput(serializer, value.sender);
    }
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU32AsUleb128(value.expirationSecondsFromNow ?? 0);
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeBool(value.feePayer !== void 0);
    if (value.feePayer !== void 0) {
      serializeAccountInput(serializer, value.feePayer);
    }
    const secondarySigners = value.secondarySigners ?? [];
    serializer.serializeU32AsUleb128(secondarySigners.length);
    for (const signer of secondarySigners) {
      serializeAccountInput(serializer, signer);
    }
  }
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const hasSender = deserializer.deserializeBool();
    const sender = hasSender ? deserializeAccountInput(deserializer) : void 0;
    const isPayloadBcsSerializable = version < 4 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(yt) : deserializeTransactionPayloadInput(deserializer);
    const expirationSecondsFromNow = deserializer.deserializeUleb128AsU32();
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeBool();
    const feePayer = hasFeePayer ? deserializeAccountInput(deserializer) : void 0;
    const secondarySignersLength = deserializer.deserializeUleb128AsU32();
    const secondarySigners = [];
    for (let i4 = 0; i4 < secondarySignersLength; i4 += 1) {
      secondarySigners.push(deserializeAccountInput(deserializer));
    }
    return {
      expirationSecondsFromNow: expirationSecondsFromNow > 0 ? expirationSecondsFromNow : void 0,
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignTransactionRequest2.name, version: SignTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignTransactionRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignTransactionRequest2.name && SignTransactionRequest2.supportedVersions.includes(request.version);
  }
  SignTransactionRequest2.isSerialized = isSerialized;
})(SignTransactionRequest || (SignTransactionRequest = {}));
var SignTransactionResponse;
((SignTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serialize(value.authenticator);
    serializer.serializeBool(value.rawTransaction !== void 0);
    if (value.rawTransaction !== void 0) {
      serializer.serialize(value.rawTransaction);
    }
  }
  function deserializeApprovalArgs(deserializer) {
    const authenticator = deserializer.deserialize(W2);
    const hasRawTransaction = deserializer.deserializeBool();
    const rawTransaction = hasRawTransaction ? deserializer.deserialize(he) : void 0;
    return {
      authenticator,
      rawTransaction
    };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(
    deserializeApprovalArgs
  );
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignTransactionResponse2.deserialize = deserialize;
})(SignTransactionResponse || (SignTransactionResponse = {}));
function isTypedMessage(messageCls, message) {
  return (message == null ? void 0 : message.__messageType) === messageCls.TYPE;
}
var _PromptConnectionRequestMessage = class _PromptConnectionRequestMessage2 {
  constructor() {
    this.__messageType = _PromptConnectionRequestMessage2.TYPE;
  }
};
_PromptConnectionRequestMessage.TYPE = "PromptConnectionRequest";
var PromptConnectionRequestMessage = _PromptConnectionRequestMessage;
var _PromptConnectionResponseMessage = class _PromptConnectionResponseMessage2 {
  constructor(serializedRequest) {
    this.serializedRequest = serializedRequest;
    this.__messageType = _PromptConnectionResponseMessage2.TYPE;
  }
};
_PromptConnectionResponseMessage.TYPE = "PromptConnectionResponse";
var PromptConnectionResponseMessage = _PromptConnectionResponseMessage;
var _PromptApprovalResponseMessage = class _PromptApprovalResponseMessage2 {
  constructor(serializedValue) {
    this.serializedValue = serializedValue;
    this.__messageType = _PromptApprovalResponseMessage2.TYPE;
  }
};
_PromptApprovalResponseMessage.TYPE = "PromptApprovalResponse";
var PromptApprovalResponseMessage = _PromptApprovalResponseMessage;
var _PromptUnauthorizedErrorMessage = class _PromptUnauthorizedErrorMessage2 {
  constructor() {
    this.__messageType = _PromptUnauthorizedErrorMessage2.TYPE;
  }
};
_PromptUnauthorizedErrorMessage.TYPE = "PromptUnauthorizedError";
var PromptUnauthorizedErrorMessage = _PromptUnauthorizedErrorMessage;
function encodeWalletRequestBody({
  data,
  ...rest
}) {
  const serialized = JSON.stringify(
    { data, ...rest },
    (key, value) => key === "data" ? bytesToBase64(value) : value
  );
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64(utf8Encoded);
}
function encodePopupWalletRequest(request) {
  const serialized = JSON.stringify(request, (key, value) => {
    switch (key) {
      case "body":
        return encodeWalletRequestBody(value);
      case "clientIdentityKey":
        return bytesToBase64(value.toUint8Array());
      case "signature":
        return bytesToBase64(value.toUint8Array());
      default:
        return value;
    }
  });
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64url(utf8Encoded);
}
function makePopupWalletRequestChallenge({
  accountAddress,
  body,
  id,
  timestamp
}) {
  const serializer = new n();
  serializer.serializeStr("SignedPopupWalletRequest");
  serializer.serializeStr(id);
  serializer.serializeU64(timestamp);
  serializer.serializeBool(accountAddress !== void 0);
  if (accountAddress !== void 0) {
    serializer.serialize(l.from(accountAddress));
  }
  serializer.serializeStr(body.name);
  serializer.serializeU8(body.version);
  serializer.serializeBytes(body.data);
  return serializer.toUint8Array();
}

// node_modules/@identity-connect/crypto/dist/index.mjs
var import_ed2curve = __toESM(require_ed2curve(), 1);
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var EncryptionEnvelopeError = class extends Error {
};
var EnvelopeMessageMismatchError = class _EnvelopeMessageMismatchError extends EncryptionEnvelopeError {
  constructor(message, field) {
    super(message);
    this.field = field;
    this.name = "EnvelopeMessageMismatchError";
    Object.setPrototypeOf(this, _EnvelopeMessageMismatchError.prototype);
  }
};
var DecryptionError = class _DecryptionError extends EncryptionEnvelopeError {
  constructor(message) {
    super(message);
    this.name = "DecryptionError";
    Object.setPrototypeOf(this, _DecryptionError.prototype);
  }
};
var KeyTypes = ((KeyTypes2) => {
  KeyTypes2["Ed25519PublicKey"] = "Ed25519PublicKey";
  KeyTypes2["Ed25519SecretKey"] = "Ed25519SecretKey";
  KeyTypes2["X25519PublicKey"] = "X25519PublicKey";
  KeyTypes2["X25519SecretKey"] = "X25519SecretKey";
  return KeyTypes2;
})(KeyTypes || {});
function createX25519KeyPair() {
  return keypairToX25519(import_tweetnacl2.default.box.keyPair());
}
function createEd25519KeyPair() {
  return keypairToEd25519(import_tweetnacl2.default.sign.keyPair());
}
function toKey(rawKey, type) {
  return {
    key: rawKey,
    type
  };
}
function keypairToEd25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "Ed25519PublicKey"
      /* Ed25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "Ed25519SecretKey"
      /* Ed25519SecretKey */
    )
  };
}
function keypairToX25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "X25519PublicKey"
      /* X25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "X25519SecretKey"
      /* X25519SecretKey */
    )
  };
}
function decodeBase64(base64Str) {
  if (globalThis.Buffer) {
    return new Uint8Array(Buffer.from(base64Str, "base64"));
  }
  return Uint8Array.from(atob(base64Str), (m2) => m2.codePointAt(0));
}
function encodeBase64(bytes) {
  if (globalThis.Buffer) {
    return Buffer.from(bytes).toString("base64");
  }
  return btoa(Array.from(bytes, (x4) => String.fromCodePoint(x4)).join(""));
}
function concatUint8array(arrayOne, arrayTwo) {
  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
  mergedArray.set(arrayOne);
  mergedArray.set(arrayTwo, arrayOne.length);
  return mergedArray;
}
var SIGNATURE_PREFIX = "APTOS::IDENTITY_CONNECT";
function convertEd25519PublicKeyToX25519PublicKey(ed25519PublicKey, errorKeyName) {
  const x25519PublicKey = import_ed2curve.default.convertPublicKey(
    ed25519PublicKey.key.slice(0, 32)
  );
  if (!x25519PublicKey) {
    throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);
  }
  return toKey(
    x25519PublicKey,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
}
function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey) {
  const x25519SecretKey = import_ed2curve.default.convertSecretKey(
    ed25519SecretKey.key.slice(0, 32)
  );
  return toKey(
    x25519SecretKey,
    "X25519SecretKey"
    /* X25519SecretKey */
  );
}
function serializeEncryptionResult(enc) {
  return {
    nonceB64: encodeBase64(enc.nonce),
    securedB64: encodeBase64(enc.secured)
  };
}
function deserializeEncryptionResult(enc) {
  return {
    nonce: decodeBase64(enc.nonceB64),
    secured: decodeBase64(enc.securedB64)
  };
}
function encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
  const messageUint8 = new TextEncoder().encode(message);
  const secured = import_tweetnacl.default.box(
    messageUint8,
    nonce,
    receiverX25519PublicKey.key,
    senderX25519SecretKey.key.slice(0, 32)
  );
  return { nonce, secured };
}
function encryptObject(senderX25519SecretKey, receiverEd25519PublicKey, message) {
  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(
    receiverEd25519PublicKey,
    "receiver public key"
  );
  return encryptObjectDirect(
    senderX25519SecretKey,
    receiverX25519PublicKey,
    message
  );
}
function encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  return encryptMessageDirect(
    senderX25519SecretKey,
    receiverX25519PublicKey,
    JSON.stringify(message)
  );
}
function decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  let decryptedUint8;
  try {
    decryptedUint8 = import_tweetnacl.default.box.open(
      securedMessage,
      nonce,
      senderX25519PublicKey.key.slice(0, 32),
      receiverX25519SecretKey.key.slice(0, 32)
    );
  } catch (e14) {
    throw new DecryptionError(`Could not decrypt message: ${e14.message}`);
  }
  if (!decryptedUint8) {
    throw new DecryptionError("Could not decrypt message");
  }
  return new TextDecoder().decode(decryptedUint8);
}
function decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {
  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(
    receiverEd25519SecretKey
  );
  return decryptObjectDirect(
    senderX25519PublicKey,
    receiverX25519SecretKey,
    securedMessage,
    nonce
  );
}
function decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  const decryptedStr = decryptMessageDirect(
    senderX25519PublicKey,
    receiverX25519SecretKey,
    securedMessage,
    nonce
  );
  return JSON.parse(decryptedStr);
}
function messageHash(message, purpose) {
  const signaturePrefixHash = new Uint8Array(
    sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`)
  );
  return new Uint8Array(
    sha3_256(concatUint8array(signaturePrefixHash, message))
  );
}
function signWithEd25519SecretKey(message, signingEd25519SecretKey, purpose) {
  return import_tweetnacl.default.sign.detached(
    messageHash(message, purpose),
    signingEd25519SecretKey.key
  );
}
function verifySignature(message, signature, signingPublicKey, purpose) {
  return signingPublicKey.verifySignature({
    message: messageHash(message, purpose),
    signature
  });
}
var REQUIRED_FIELDS = [
  "receiverEd25519PublicKeyB64",
  "senderEd25519PublicKeyB64",
  "senderX25519PublicKeyB64",
  "sequence",
  "timestampMillis"
].sort();
function ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage) {
  const intersection = Object.keys(privateMessage).filter(
    (x4) => Object.keys(publicMessage).includes(x4)
  );
  if (intersection.length > 0) {
    const field = intersection[0];
    throw new EnvelopeMessageMismatchError(
      `Field ${field} appears in both private and public message fields`,
      field
    );
  }
}
function ensureMetadataFields(message) {
  const messageKeys = Object.keys(message).sort();
  const extraFields = messageKeys.filter(
    (key) => !REQUIRED_FIELDS.includes(key)
  );
  const missingFields = REQUIRED_FIELDS.filter(
    (key) => !messageKeys.includes(key)
  );
  if (extraFields.length > 0 || missingFields.length > 0) {
    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(", ")})` : "";
    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(", ")})` : "";
    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;
    throw new EnvelopeMessageMismatchError(
      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,
      "_metadata"
    );
  }
}
function encryptAndSignEnvelope(senderEd25519SecretKey, senderEd25519PublicKey, receiverEd25519PublicKey, sequence, publicMessage, privateMessage) {
  const senderEphemeralX25519KeyPair = createX25519KeyPair();
  const metadata = constructMetadata(
    senderEd25519PublicKey,
    receiverEd25519PublicKey,
    sequence,
    senderEphemeralX25519KeyPair.publicKey
  );
  ensureMetadataFields(metadata);
  ensurePrivatePublicFieldsDisjoint(
    privateMessage,
    publicMessage
  );
  return dangerouslyEncryptAndSignEnvelopeUnvalidated(
    senderEd25519SecretKey,
    receiverEd25519PublicKey,
    metadata,
    privateMessage,
    publicMessage,
    senderEphemeralX25519KeyPair
  );
}
function constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519PublicKey) {
  return {
    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),
    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),
    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),
    sequence,
    timestampMillis: Date.now()
  };
}
function dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair) {
  const encryptionResult = encryptObject(
    senderEphemeralX25519KeyPair.secretKey,
    receiverEd25519PublicKey,
    privateMessage
  );
  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);
  const encryptedPrivateMessageBytes = decodeBase64(
    encryptedPrivateMessage.securedB64
  );
  const serializedPublicMessage = JSON.stringify({
    ...publicMessage,
    _metadata: metadata
  });
  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);
  const messageSignature = signEnvelope(
    publicMessageBytes,
    encryptedPrivateMessageBytes,
    senderEd25519SecretKey
  );
  return {
    encryptedPrivateMessage,
    messageSignature,
    serializedPublicMessage
  };
}
function combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes) {
  const publicMessageBytesHash = sha3_256(publicMessageBytes);
  const privateMessageBytesHash = sha3_256(privateMessageBytes);
  const combinedHash = new Uint8Array(
    publicMessageBytesHash.length + privateMessageBytesHash.length
  );
  combinedHash.set(publicMessageBytesHash);
  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);
  return sha3_256(combinedHash);
}
function signEnvelope(publicMessageBytes, privateMessageBytes, senderEd25519SecretKey) {
  const messageHashBytes = combineHashedEnvelopeMessageBytes(
    publicMessageBytes,
    privateMessageBytes
  );
  const signatureBytes = signWithEd25519SecretKey(
    messageHashBytes,
    senderEd25519SecretKey,
    "SECURED_ENVELOPE"
  );
  return a.fromHexInput(signatureBytes).toString();
}
function verifyEnvelopeSignature(publicMessageBytes, privateMessageBytes, messageSignatureInput, senderEd25519PublicKey) {
  const messageSignature = new v(
    a.fromHexInput(messageSignatureInput).toUint8Array()
  );
  const senderPublicKey = new b(senderEd25519PublicKey.key);
  const messageHashBytes = combineHashedEnvelopeMessageBytes(
    publicMessageBytes,
    privateMessageBytes
  );
  const messageVerified = verifySignature(
    messageHashBytes,
    messageSignature,
    senderPublicKey,
    "SECURED_ENVELOPE"
  );
  if (!messageVerified) {
    throw new EnvelopeMessageMismatchError(
      "Could not verify SecuredEnvelope signature",
      "messageSignature"
    );
  }
}
function decryptEnvelope(senderEd25519PublicKey, receiverEd25519SecretKey, message) {
  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;
  const publicMessage = JSON.parse(serializedPublicMessage);
  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);
  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);
  verifyEnvelopeSignature(
    rawPublicMessage,
    rawPrivateMessage,
    messageSignature,
    senderEd25519PublicKey
  );
  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);
  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;
  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {
    throw new EnvelopeMessageMismatchError(
      "senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey",
      "senderPublicKey"
    );
  }
  const senderX25519PublicKeyBytes = decodeBase64(
    publicMessage._metadata.senderX25519PublicKeyB64
  );
  const senderX25519PublicKey = toKey(
    senderX25519PublicKeyBytes,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);
  const privateMessage = decryptObject(
    senderX25519PublicKey,
    receiverEd25519SecretKey,
    encryptionResult.secured,
    encryptionResult.nonce
  );
  ensureMetadataFields(publicMessage._metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return {
    messageSignature,
    privateMessage,
    publicMessage
  };
}
function serializePublicKeyB64(publicKey) {
  const serializer = new n();
  serializePublicKey(serializer, publicKey);
  return bytesToBase64(serializer.toUint8Array());
}
function deserializePublicKeyB64(publicKeyB64) {
  const serializedPublicKey = base64ToBytes(publicKeyB64);
  const deserializer = new a2(serializedPublicKey);
  return deserializePublicKey(deserializer);
}
function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64) {
  return new b(decodeBase64(ed25519PublicKeyB64));
}
var AccountConnectionAction = ((AccountConnectionAction2) => {
  AccountConnectionAction2["ADD"] = "add";
  AccountConnectionAction2["REMOVE"] = "remove";
  return AccountConnectionAction2;
})(AccountConnectionAction || {});

// node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: (config2 == null ? void 0 : config2.lang) ?? (store == null ? void 0 : store.lang),
    message: config2 == null ? void 0 : config2.message,
    abortEarly: (config2 == null ? void 0 : config2.abortEarly) ?? (store == null ? void 0 : store.abortEarly),
    abortPipeEarly: (config2 == null ? void 0 : config2.abortPipeEarly) ?? (store == null ? void 0 : store.abortPipeEarly)
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2 == null ? void 0 : store2.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3 == null ? void 0 : store3.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  var _a;
  return (_a = store4 == null ? void 0 : store4.get(reference)) == null ? void 0 : _a.get(lang);
}
function _stringify(input) {
  var _a, _b;
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && ((_b = (_a = Object.getPrototypeOf(input)) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name)) ?? "null";
  }
  return type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = (other == null ? void 0 : other.expected) ?? context.expects ?? null;
  const received = (other == null ? void 0 : other.received) ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other == null ? void 0 : other.path,
    issues: other == null ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = (other == null ? void 0 : other.message) ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message !== void 0) {
    issue.message = typeof message === "function" ? (
      // @ts-expect-error
      message(issue)
    ) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value2) {
      return context["~run"]({ value: value2 }, getGlobalConfig());
    }
  };
}
function _isValidObjectKey(object2, key) {
  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};
var EMOJI_REGEX = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
  new RegExp("^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$", "u")
);
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function is(schema, input) {
  return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function function_(message) {
  return {
    kind: "schema",
    type: "function",
    reference: function_,
    expects: "Function",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "function") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function looseObject(entries, message) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: false,
    entries,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      var _a;
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
          valueSchema.default !== void 0) {
            const value2 = key in input ? (
              // @ts-expect-error
              input[key]
            ) : getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value2 }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value2
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                (_a = dataset.issues) == null ? void 0 : _a.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) {
            dataset.value[key] = getFallback(valueSchema);
          } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config2, {
              input: void 0,
              expected: `"${key}"`,
              path: [
                {
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  // @ts-expect-error
                  value: input[key]
                }
              ]
            });
            if (config2.abortEarly) {
              break;
            }
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (const key in input) {
            if (_isValidObjectKey(input, key) && !(key in this.entries)) {
              dataset.value[key] = input[key];
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function nullish(wrapped, default_) {
  return {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${wrapped.expects} | null | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === null || dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === null || dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
function number(message) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = getDefault(this, dataset, config2);
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset) {
      dataset.typed = true;
      return dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema["~run"]({ value: input }, getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    get "~standard"() {
      return _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      for (const item of pipe2) {
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item["~run"](dataset, config2);
          }
        }
      }
      return dataset;
    }
  };
}

// node_modules/better-promises/dist/index.js
var $ = Object.defineProperty;
var k = (r9, t11, e14) => t11 in r9 ? $(r9, t11, { enumerable: true, configurable: true, writable: true, value: e14 }) : r9[t11] = e14;
var q = (r9, t11, e14) => k(r9, t11 + "", e14);
function z(r9, t11) {
  return (e14) => e14 instanceof r9 && e14.type === t11;
}
function P(r9, t11) {
  t11 || (t11 = []);
  const e14 = Symbol(r9);
  class c3 extends Error {
    constructor(...s4) {
      const a9 = typeof t11 == "function" ? t11(...s4) : typeof t11 == "string" ? [t11] : t11 || [];
      super(...a9), q(this, "type", e14), this.name = r9;
    }
  }
  return Object.defineProperty(c3, "name", { value: r9 }), [c3, z(c3, e14)];
}
var [G2, M] = P("CancelledError", "Promise was canceled");
var [H, N] = P(
  "TimeoutError",
  (r9, t11) => [`Timeout reached: ${r9}ms`, { cause: t11 }]
);
var B = Symbol("Resolved");

// node_modules/@telegram-apps/toolkit/dist/index.js
function O2(o12, e14) {
  e14 || (e14 = {});
  const {
    textColor: r9,
    bgColor: t11,
    shouldLog: s4
  } = e14, c3 = s4 === void 0 ? true : s4, d8 = typeof c3 == "boolean" ? () => c3 : c3, u2 = (n16, a9, ...i4) => {
    if (a9 || d8()) {
      const l4 = "font-weight:bold;padding:0 5px;border-radius:100px", [b4, m2, p6] = {
        log: ["#0089c3", "white", "INFO"],
        error: ["#ff0000F0", "white", "ERR"],
        warn: ["#D38E15", "white", "WARN"]
      }[n16];
      console[n16](
        `%c${p6} ${Intl.DateTimeFormat("en-GB", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          fractionalSecondDigits: 3,
          timeZone: "UTC"
        }).format(/* @__PURE__ */ new Date())}%c %c${o12}`,
        `${l4};background-color:${b4};color:${m2}`,
        "",
        `${l4};${r9 ? `color:${r9};` : ""}${t11 ? `background-color:${t11}` : ""}`,
        ...i4
      );
    }
  };
  return [
    ["log", "forceLog"],
    ["warn", "forceWarn"],
    ["error", "forceError"]
  ].reduce((n16, [a9, i4]) => (n16[a9] = u2.bind(void 0, a9, false), n16[i4] = u2.bind(void 0, a9, true), n16), {});
}

// node_modules/@telegram-apps/transformers/dist/index.js
var b2;
function N2(e14) {
  return {
    lang: (e14 == null ? void 0 : e14.lang) ?? (b2 == null ? void 0 : b2.lang),
    message: e14 == null ? void 0 : e14.message,
    abortEarly: (e14 == null ? void 0 : e14.abortEarly) ?? (b2 == null ? void 0 : b2.abortEarly),
    abortPipeEarly: (e14 == null ? void 0 : e14.abortPipeEarly) ?? (b2 == null ? void 0 : b2.abortPipeEarly)
  };
}
var D;
function Z(e14) {
  return D == null ? void 0 : D.get(e14);
}
var P2;
function ee2(e14) {
  return P2 == null ? void 0 : P2.get(e14);
}
var j;
function ne(e14, n16) {
  var r9;
  return (r9 = j == null ? void 0 : j.get(e14)) == null ? void 0 : r9.get(n16);
}
function re(e14) {
  var r9, t11;
  const n16 = typeof e14;
  return n16 === "string" ? `"${e14}"` : n16 === "number" || n16 === "bigint" || n16 === "boolean" ? `${e14}` : n16 === "object" || n16 === "function" ? (e14 && ((t11 = (r9 = Object.getPrototypeOf(e14)) == null ? void 0 : r9.constructor) == null ? void 0 : t11.name)) ?? "null" : n16;
}
function f(e14, n16, r9, t11, s4) {
  const u2 = s4 && "input" in s4 ? s4.input : r9.value, i4 = (s4 == null ? void 0 : s4.expected) ?? e14.expects ?? null, l4 = (s4 == null ? void 0 : s4.received) ?? re(u2), o12 = {
    kind: e14.kind,
    type: e14.type,
    input: u2,
    expected: i4,
    received: l4,
    message: `Invalid ${n16}: ${i4 ? `Expected ${i4} but r` : "R"}eceived ${l4}`,
    requirement: e14.requirement,
    path: s4 == null ? void 0 : s4.path,
    issues: s4 == null ? void 0 : s4.issues,
    lang: t11.lang,
    abortEarly: t11.abortEarly,
    abortPipeEarly: t11.abortPipeEarly
  }, y2 = e14.kind === "schema", p6 = (s4 == null ? void 0 : s4.message) ?? e14.message ?? ne(e14.reference, o12.lang) ?? (y2 ? ee2(o12.lang) : null) ?? t11.message ?? Z(o12.lang);
  p6 && (o12.message = typeof p6 == "function" ? (
    // @ts-expect-error
    p6(o12)
  ) : p6), y2 && (r9.typed = false), r9.issues ? r9.issues.push(o12) : r9.issues = [o12];
}
function h(e14) {
  return {
    version: 1,
    vendor: "valibot",
    validate(n16) {
      return e14["~run"]({ value: n16 }, N2());
    }
  };
}
function W3(e14, n16) {
  return Object.hasOwn(e14, n16) && n16 !== "__proto__" && n16 !== "prototype" && n16 !== "constructor";
}
function te(e14, n16) {
  const r9 = [...new Set(e14)];
  return r9.length > 1 ? `(${r9.join(` ${n16} `)})` : r9[0] ?? "never";
}
var se = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(e14) {
    super(e14[0].message), this.name = "ValiError", this.issues = e14;
  }
};
function L2(e14, n16) {
  return {
    kind: "validation",
    type: "check",
    reference: L2,
    async: false,
    expects: null,
    requirement: e14,
    message: n16,
    "~run"(r9, t11) {
      return r9.typed && !this.requirement(r9.value) && f(this, "input", r9, t11), r9;
    }
  };
}
function R(e14) {
  return {
    kind: "validation",
    type: "integer",
    reference: R,
    async: false,
    expects: null,
    requirement: Number.isInteger,
    message: e14,
    "~run"(n16, r9) {
      return n16.typed && !this.requirement(n16.value) && f(this, "integer", n16, r9), n16;
    }
  };
}
function d7(e14) {
  return {
    kind: "transformation",
    type: "transform",
    reference: d7,
    async: false,
    operation: e14,
    "~run"(n16) {
      return n16.value = this.operation(n16.value), n16;
    }
  };
}
function U(e14, n16, r9) {
  return typeof e14.default == "function" ? (
    // @ts-expect-error
    e14.default(n16, r9)
  ) : (
    // @ts-expect-error
    e14.default
  );
}
function _2(e14) {
  return {
    kind: "schema",
    type: "boolean",
    reference: _2,
    expects: "boolean",
    async: false,
    message: e14,
    get "~standard"() {
      return h(this);
    },
    "~run"(n16, r9) {
      return typeof n16.value == "boolean" ? n16.typed = true : f(this, "type", n16, r9), n16;
    }
  };
}
function z2(e14) {
  return {
    kind: "schema",
    type: "date",
    reference: z2,
    expects: "Date",
    async: false,
    message: e14,
    get "~standard"() {
      return h(this);
    },
    "~run"(n16, r9) {
      return n16.value instanceof Date ? isNaN(n16.value) ? f(this, "type", n16, r9, {
        received: '"Invalid Date"'
      }) : n16.typed = true : f(this, "type", n16, r9), n16;
    }
  };
}
function J(e14, n16) {
  return {
    kind: "schema",
    type: "instance",
    reference: J,
    expects: e14.name,
    async: false,
    class: e14,
    message: n16,
    get "~standard"() {
      return h(this);
    },
    "~run"(r9, t11) {
      return r9.value instanceof this.class ? r9.typed = true : f(this, "type", r9, t11), r9;
    }
  };
}
function A4(e14) {
  return {
    kind: "schema",
    type: "lazy",
    reference: A4,
    expects: "unknown",
    async: false,
    getter: e14,
    get "~standard"() {
      return h(this);
    },
    "~run"(n16, r9) {
      return this.getter(n16.value)["~run"](n16, r9);
    }
  };
}
function k2(e14, n16) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: k2,
    expects: "Object",
    async: false,
    entries: e14,
    message: n16,
    get "~standard"() {
      return h(this);
    },
    "~run"(r9, t11) {
      var u2;
      const s4 = r9.value;
      if (s4 && typeof s4 == "object") {
        r9.typed = true, r9.value = {};
        for (const i4 in this.entries) {
          const l4 = this.entries[i4];
          if (i4 in s4 || (l4.type === "exact_optional" || l4.type === "optional" || l4.type === "nullish") && // @ts-expect-error
          l4.default !== void 0) {
            const o12 = i4 in s4 ? (
              // @ts-expect-error
              s4[i4]
            ) : U(l4), y2 = l4["~run"]({ value: o12 }, t11);
            if (y2.issues) {
              const p6 = {
                type: "object",
                origin: "value",
                input: s4,
                key: i4,
                value: o12
              };
              for (const m2 of y2.issues)
                m2.path ? m2.path.unshift(p6) : m2.path = [p6], (u2 = r9.issues) == null || u2.push(m2);
              if (r9.issues || (r9.issues = y2.issues), t11.abortEarly) {
                r9.typed = false;
                break;
              }
            }
            y2.typed || (r9.typed = false), r9.value[i4] = y2.value;
          } else if (l4.type !== "exact_optional" && l4.type !== "optional" && l4.type !== "nullish" && (f(this, "key", r9, t11, {
            input: void 0,
            expected: `"${i4}"`,
            path: [
              {
                type: "object",
                origin: "key",
                input: s4,
                key: i4,
                // @ts-expect-error
                value: s4[i4]
              }
            ]
          }), t11.abortEarly))
            break;
        }
        if (!r9.issues || !t11.abortEarly)
          for (const i4 in s4)
            W3(s4, i4) && !(i4 in this.entries) && (r9.value[i4] = s4[i4]);
      } else
        f(this, "type", r9, t11);
      return r9;
    }
  };
}
function E(e14) {
  return {
    kind: "schema",
    type: "number",
    reference: E,
    expects: "number",
    async: false,
    message: e14,
    get "~standard"() {
      return h(this);
    },
    "~run"(n16, r9) {
      return typeof n16.value == "number" && !isNaN(n16.value) ? n16.typed = true : f(this, "type", n16, r9), n16;
    }
  };
}
function c(e14, n16) {
  return {
    kind: "schema",
    type: "optional",
    reference: c,
    expects: `(${e14.expects} | undefined)`,
    async: false,
    wrapped: e14,
    default: n16,
    get "~standard"() {
      return h(this);
    },
    "~run"(r9, t11) {
      return r9.value === void 0 && (this.default !== void 0 && (r9.value = U(this, r9, t11)), r9.value === void 0) ? (r9.typed = true, r9) : this.wrapped["~run"](r9, t11);
    }
  };
}
function V(e14, n16, r9) {
  return {
    kind: "schema",
    type: "record",
    reference: V,
    expects: "Object",
    async: false,
    key: e14,
    value: n16,
    message: r9,
    get "~standard"() {
      return h(this);
    },
    "~run"(t11, s4) {
      var i4, l4;
      const u2 = t11.value;
      if (u2 && typeof u2 == "object") {
        t11.typed = true, t11.value = {};
        for (const o12 in u2)
          if (W3(u2, o12)) {
            const y2 = u2[o12], p6 = this.key["~run"]({ value: o12 }, s4);
            if (p6.issues) {
              const S2 = {
                type: "object",
                origin: "key",
                input: u2,
                key: o12,
                value: y2
              };
              for (const g2 of p6.issues)
                g2.path = [S2], (i4 = t11.issues) == null || i4.push(g2);
              if (t11.issues || (t11.issues = p6.issues), s4.abortEarly) {
                t11.typed = false;
                break;
              }
            }
            const m2 = this.value["~run"](
              { value: y2 },
              s4
            );
            if (m2.issues) {
              const S2 = {
                type: "object",
                origin: "value",
                input: u2,
                key: o12,
                value: y2
              };
              for (const g2 of m2.issues)
                g2.path ? g2.path.unshift(S2) : g2.path = [S2], (l4 = t11.issues) == null || l4.push(g2);
              if (t11.issues || (t11.issues = m2.issues), s4.abortEarly) {
                t11.typed = false;
                break;
              }
            }
            (!p6.typed || !m2.typed) && (t11.typed = false), p6.typed && (t11.value[p6.value] = m2.value);
          }
      } else
        f(this, "type", t11, s4);
      return t11;
    }
  };
}
function a7(e14) {
  return {
    kind: "schema",
    type: "string",
    reference: a7,
    expects: "string",
    async: false,
    message: e14,
    get "~standard"() {
      return h(this);
    },
    "~run"(n16, r9) {
      return typeof n16.value == "string" ? n16.typed = true : f(this, "type", n16, r9), n16;
    }
  };
}
function O3(e14) {
  let n16;
  if (e14)
    for (const r9 of e14)
      n16 ? n16.push(...r9.issues) : n16 = r9.issues;
  return n16;
}
function $2(e14, n16) {
  return {
    kind: "schema",
    type: "union",
    reference: $2,
    expects: te(
      e14.map((r9) => r9.expects),
      "|"
    ),
    async: false,
    options: e14,
    message: n16,
    get "~standard"() {
      return h(this);
    },
    "~run"(r9, t11) {
      let s4, u2, i4;
      for (const l4 of this.options) {
        const o12 = l4["~run"]({ value: r9.value }, t11);
        if (o12.typed)
          if (o12.issues)
            u2 ? u2.push(o12) : u2 = [o12];
          else {
            s4 = o12;
            break;
          }
        else
          i4 ? i4.push(o12) : i4 = [o12];
      }
      if (s4)
        return s4;
      if (u2) {
        if (u2.length === 1)
          return u2[0];
        f(this, "type", r9, t11, {
          issues: O3(u2)
        }), r9.typed = true;
      } else {
        if ((i4 == null ? void 0 : i4.length) === 1)
          return i4[0];
        f(this, "type", r9, t11, {
          issues: O3(i4)
        });
      }
      return r9;
    }
  };
}
function q2() {
  return {
    kind: "schema",
    type: "unknown",
    reference: q2,
    expects: "unknown",
    async: false,
    get "~standard"() {
      return h(this);
    },
    "~run"(e14) {
      return e14.typed = true, e14;
    }
  };
}
function B2(e14, n16, r9) {
  const t11 = e14["~run"]({ value: n16 }, N2(r9));
  if (t11.issues)
    throw new se(t11.issues);
  return t11.value;
}
function v2(...e14) {
  return {
    ...e14[0],
    pipe: e14,
    get "~standard"() {
      return h(this);
    },
    "~run"(n16, r9) {
      for (const t11 of e14)
        if (t11.kind !== "metadata") {
          if (n16.issues && (t11.kind === "schema" || t11.kind === "transformation")) {
            n16.typed = false;
            break;
          }
          (!n16.issues || !r9.abortEarly && !r9.abortPipeEarly) && (n16 = t11["~run"](n16, r9));
        }
      return n16;
    }
  };
}
function ue(e14) {
  return e14.replace(/_[a-z]/g, (n16) => n16[1].toUpperCase());
}
function ae(e14) {
  return Object.entries(e14).reduce((n16, [r9, t11]) => (n16[ue(r9)] = t11, n16), {});
}
function w(e14) {
  const n16 = ae(e14);
  for (const r9 in n16) {
    const t11 = n16[r9];
    t11 && typeof t11 == "object" && !(t11 instanceof Date) && (n16[r9] = Array.isArray(t11) ? t11.map(w) : w(t11));
  }
  return n16;
}
function I2(e14) {
  return d7((n16) => e14 ? w(n16) : n16);
}
function M2(e14) {
  return (n16) => v2(
    e14,
    I2(n16)
  );
}
function T4(e14) {
  return (n16, r9) => B2(
    v2(e14, I2(r9)),
    n16
  );
}
function oe() {
  return d7(JSON.parse);
}
function C(e14) {
  const n16 = M2(e14);
  return (r9) => v2(
    a7(),
    oe(),
    n16(r9)
  );
}
function ce(e14) {
  return d7((n16) => {
    const r9 = {};
    return new URLSearchParams(n16).forEach((t11, s4) => {
      const u2 = r9[s4];
      Array.isArray(u2) ? u2.push(t11) : u2 === void 0 ? r9[s4] = t11 : r9[s4] = [u2, t11];
    }), B2(e14, r9);
  });
}
function K(e14) {
  return (n16) => v2(
    $2([a7(), J(URLSearchParams)]),
    ce(e14),
    I2(n16)
  );
}
var Q = c(A4(() => he2()));
var le = k2({
  id: E(),
  photo_url: c(a7()),
  type: a7(),
  title: a7(),
  username: c(a7())
});
var pe = k2({
  added_to_attachment_menu: c(_2()),
  allows_write_to_pm: c(_2()),
  first_name: a7(),
  id: E(),
  is_bot: c(_2()),
  is_premium: c(_2()),
  last_name: c(a7()),
  language_code: c(a7()),
  photo_url: c(a7()),
  username: c(a7())
});
var fe = k2({
  auth_date: v2(
    a7(),
    d7((e14) => new Date(Number(e14) * 1e3)),
    z2()
  ),
  can_send_after: c(v2(a7(), d7(Number), R())),
  chat: c(A4(() => ye())),
  chat_type: c(a7()),
  chat_instance: c(a7()),
  hash: a7(),
  query_id: c(a7()),
  receiver: Q,
  start_param: c(a7()),
  signature: a7(),
  user: Q
});
var ye = C(le);
var he2 = C(pe);
var F = K(fe);
function H2(e14) {
  return /^#[\da-f]{6}$/i.test(e14);
}
var be = M2(
  V(
    a7(),
    v2(
      $2([a7(), E()]),
      d7((e14) => typeof e14 == "number" ? `#${(e14 & 16777215).toString(16).padStart(6, "0")}` : e14),
      L2(H2)
    )
  )
);
var x2 = c(
  v2(a7(), d7((e14) => e14 === "1"))
);
var G3 = C(be());
var de = k2({
  tgWebAppBotInline: x2,
  tgWebAppData: c(F()),
  tgWebAppDefaultColors: c(G3()),
  tgWebAppFullscreen: x2,
  tgWebAppPlatform: a7(),
  tgWebAppShowSettings: x2,
  tgWebAppStartParam: c(a7()),
  tgWebAppThemeParams: G3(),
  tgWebAppVersion: a7()
});
var X = K(de);
var ke = T4(F());
var _e2 = T4(X());
var Se = k2({
  eventType: a7(),
  eventData: c(q2())
});

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n16) {
  return { all: n16 = n16 || /* @__PURE__ */ new Map(), on: function(t11, e14) {
    var i4 = n16.get(t11);
    i4 ? i4.push(e14) : n16.set(t11, [e14]);
  }, off: function(t11, e14) {
    var i4 = n16.get(t11);
    i4 && (e14 ? i4.splice(i4.indexOf(e14) >>> 0, 1) : n16.set(t11, []));
  }, emit: function(t11, e14) {
    var i4 = n16.get(t11);
    i4 && i4.slice().map(function(n17) {
      n17(e14);
    }), (i4 = n16.get("*")) && i4.slice().map(function(n17) {
      n17(t11, e14);
    });
  } };
}

// node_modules/@telegram-apps/signals/dist/index.js
var r8;
function y(e14, c3) {
  r8 && r8.set(e14, c3) || c3();
}
function S(e14, c3) {
  c3 || (c3 = {});
  const g2 = c3.equals || Object.is;
  let u2 = [], s4 = e14;
  const i4 = (t11) => {
    if (!g2(s4, t11)) {
      const l4 = s4;
      s4 = t11, y(o12, () => {
        [...u2].forEach(([f6, d8]) => {
          f6(t11, l4), d8 && n16(f6, true);
        });
      });
    }
  };
  function a9(t11) {
    const l4 = typeof t11 != "object" ? { once: t11 } : t11;
    return {
      once: l4.once || false,
      signal: l4.signal || false
    };
  }
  const n16 = (t11, l4) => {
    const f6 = a9(l4), d8 = u2.findIndex(([h3, p6]) => h3 === t11 && p6.once === f6.once && p6.signal === f6.signal);
    d8 >= 0 && u2.splice(d8, 1);
  }, o12 = Object.assign(
    function() {
      return j2(o12), s4;
    },
    {
      destroy() {
        u2 = [];
      },
      set: i4,
      reset() {
        i4(e14);
      },
      sub(t11, l4) {
        return u2.push([t11, a9(l4)]), () => n16(t11, l4);
      },
      unsub: n16,
      unsubAll() {
        u2 = u2.filter((t11) => t11[1].signal);
      }
    }
  );
  return o12;
}
var b3 = [];
function j2(e14) {
  b3.length && b3[b3.length - 1].add(e14);
}

// node_modules/error-kid/dist/index.js
var f2 = Object.defineProperty;
var u = (r9, t11, e14) => t11 in r9 ? f2(r9, t11, { enumerable: true, configurable: true, writable: true, value: e14 }) : r9[t11] = e14;
var c2 = (r9, t11, e14) => u(r9, typeof t11 != "symbol" ? t11 + "" : t11, e14);
function a8(r9, t11) {
  return (e14) => e14 instanceof r9 && e14.type === t11;
}
function p5(r9, t11) {
  t11 || (t11 = []);
  const e14 = Symbol(r9);
  class n16 extends Error {
    constructor(...i4) {
      const o12 = typeof t11 == "function" ? t11(...i4) : typeof t11 == "string" ? [t11] : t11 || [];
      super(...o12);
      c2(this, "type", e14);
      this.name = r9;
    }
  }
  return Object.defineProperty(n16, "name", { value: r9 }), [n16, a8(n16, e14)];
}
function l3(r9, t11, e14) {
  const n16 = Symbol(r9);
  class s4 extends p5(r9, e14)[0] {
    constructor(...o12) {
      super(...o12);
      c2(this, "data");
      c2(this, "type", n16);
      this.data = t11(...o12);
    }
  }
  return Object.defineProperty(s4, "name", { value: r9 }), [s4, a8(s4, n16)];
}

// node_modules/@telegram-apps/bridge/dist/index.js
function H3(e14) {
  return is(
    looseObject({ TelegramWebviewProxy: looseObject({ postEvent: function_() }) }),
    e14
  );
}
function K2() {
  try {
    return window.self !== window.top;
  } catch {
    return true;
  }
}
function le2(e14, t11) {
  const r9 = /* @__PURE__ */ new Map(), n16 = mitt_default(), a9 = (o12, s4, c3) => {
    c3 || (c3 = false);
    const i4 = r9.get(o12) || /* @__PURE__ */ new Map();
    r9.set(o12, i4);
    const _3 = i4.get(s4) || [];
    i4.set(s4, _3);
    const l4 = _3.findIndex((w3) => w3[1] === c3);
    if (l4 >= 0 && (n16.off(o12, _3[l4][0]), _3.splice(l4, 1), !_3.length && (i4.delete(s4), !i4.size))) {
      const w3 = r9.size;
      r9.delete(o12), w3 && !r9.size && t11();
    }
  };
  return [
    function(s4, c3, i4) {
      !r9.size && e14();
      const _3 = () => {
        a9(s4, c3, i4);
      }, l4 = (...M3) => {
        i4 && _3(), s4 === "*" ? c3(M3) : c3(...M3);
      };
      n16.on(s4, l4);
      const w3 = r9.get(s4) || /* @__PURE__ */ new Map();
      r9.set(s4, w3);
      const T6 = w3.get(c3) || [];
      return w3.set(c3, T6), T6.push([l4, i4 || false]), _3;
    },
    a9,
    // eslint-disable-next-line @typescript-eslint/unbound-method
    n16.emit,
    function() {
      const s4 = r9.size;
      n16.all.clear(), r9.clear(), s4 && t11();
    }
  ];
}
function v3(e14, t11) {
  window.dispatchEvent(new MessageEvent("message", {
    data: JSON.stringify({ eventType: e14, eventData: t11 }),
    // We specify window.parent to imitate the case, the parent iframe sent us this event.
    source: window.parent
  }));
}
var h2 = false;
var f4 = S(O2("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog() {
    return h2;
  }
}));
function Y2(e14, t11, r9, n16) {
  Object.defineProperty(e14, t11, {
    enumerable: true,
    configurable: true,
    get: r9,
    set: n16
  });
}
function W4(e14, t11) {
  const r9 = e14[t11];
  Y2(e14, t11, () => r9, (n16) => {
    Object.entries(n16).forEach(([a9, o12]) => {
      r9[a9] = o12;
    });
  });
}
function U2(e14, t11, r9) {
  Object.defineProperty(e14, t11, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: r9
  });
}
function E2(e14, t11, r9) {
  const n16 = e14[t11], a9 = [r9];
  typeof n16 == "function" && a9.push(n16);
  const o12 = (...c3) => {
    a9.forEach((i4) => {
      i4(...c3);
    });
  }, s4 = Object.assign((...c3) => {
    o12(...c3);
  }, {
    // Unwraps the composer.
    unwrap() {
      const { length: c3 } = a9;
      if (c3 === 1) {
        delete e14[t11];
        return;
      }
      if (c3 === 2) {
        U2(e14, t11, a9[1]);
        return;
      }
      a9.unshift(1), U2(e14, t11, o12);
    }
  });
  Y2(
    e14,
    t11,
    () => s4,
    (c3) => {
      a9.push(c3);
    }
  );
}
var we = {
  clipboard_text_received: looseObject({
    req_id: string(),
    data: nullish(string())
  }),
  custom_method_invoked: looseObject({
    req_id: string(),
    result: optional(unknown()),
    error: optional(string())
  }),
  popup_closed: nullish(
    looseObject({ button_id: nullish(string(), () => {
    }) }),
    {}
  ),
  viewport_changed: looseObject({
    height: number(),
    width: nullish(number(), () => window.innerWidth),
    is_state_stable: boolean(),
    is_expanded: boolean()
  }),
  theme_changed: looseObject({
    theme_params: be()
  })
};
function I3(e14) {
  if (e14.source !== window.parent)
    return;
  let t11;
  try {
    t11 = parse(pipe(string(), oe(), Se), e14.data);
  } catch {
    return;
  }
  const { eventType: r9, eventData: n16 } = t11, a9 = we[r9];
  let o12;
  try {
    o12 = a9 ? parse(a9, n16) : n16;
  } catch (s4) {
    return f4().forceError(
      [
        `An error occurred processing the "${r9}" event from the Telegram application.`,
        "Please, file an issue here:",
        "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"
      ].join(`
`),
      t11,
      s4
    );
  }
  ge(r9, o12);
}
var [
  X2,
  me,
  ge,
  be2
] = le2(
  () => {
    const e14 = window;
    !e14.TelegramGameProxy && (e14.TelegramGameProxy = {}), E2(e14.TelegramGameProxy, "receiveEvent", v3), W4(e14, "TelegramGameProxy"), !e14.Telegram && (e14.Telegram = {}), !e14.Telegram.WebView && (e14.Telegram.WebView = {}), E2(e14.Telegram.WebView, "receiveEvent", v3), W4(e14.Telegram, "WebView"), E2(e14, "TelegramGameProxy_receiveEvent", v3), window.addEventListener("message", I3);
  },
  () => {
    [
      ["TelegramGameProxy_receiveEvent"],
      ["TelegramGameProxy", "receiveEvent"],
      ["Telegram", "WebView", "receiveEvent"]
    ].forEach((e14) => {
      const t11 = window;
      let r9 = [void 0, t11];
      for (const o12 of e14)
        if (r9 = [r9[1], r9[1][o12]], !r9[1])
          return;
      const [n16, a9] = r9;
      "unwrap" in a9 && (a9.unwrap(), n16 && n16 !== t11 && !Object.keys(n16).length && delete t11[e14[0]]);
    }), window.removeEventListener("message", I3);
  }
);
var [
  de2,
  Ie2
] = p5(
  "MethodUnsupportedError",
  (e14, t11) => [
    `Method "${e14}" is unsupported in Mini Apps version ${t11}`
  ]
);
var [
  he3,
  Re
] = p5(
  "MethodParameterUnsupportedError",
  (e14, t11, r9) => [
    `Parameter "${t11}" of "${e14}" method is unsupported in Mini Apps version ${r9}`
  ]
);
var [
  ye2,
  je
] = l3(
  "LaunchParamsRetrieveError",
  (e14) => ({ errors: e14 }),
  (e14) => [
    [
      "Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?",
      " Refer to docs for more information:",
      "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment",
      "",
      "Collected errors:",
      ...e14.map(([t11, r9]) => `Source: ${t11} / ${r9 instanceof Error ? r9.message : String(r9)}`)
    ].join(`
`)
  ]
);
var [
  ve,
  $e
] = p5(
  "InvalidLaunchParamsError",
  (e14, t11) => [
    `Invalid value for launch params: ${e14}`,
    { cause: t11 }
  ]
);
var [Ee2, ze] = p5("UnknownEnvError");
var [
  Pe,
  Ne
] = p5(
  "InvokeCustomMethodError",
  (e14) => [`Server returned error: ${e14}`]
);
var g = S((...e14) => {
  try {
    window.parent.postMessage(...e14);
  } catch (t11) {
    t11 instanceof SyntaxError ? f4().forceError(
      "Unable to call window.parent.postMessage due to incorrectly configured target origin. Use the setTargetOrigin method to allow this origin to receive events",
      t11
    ) : f4().forceError(t11);
  }
});
var ke2 = (...e14) => g()(...e14);
var x3 = S("https://web.telegram.org");
function Z2(e14, t11) {
  f4().log("Posting event:", t11 ? { eventType: e14, eventData: t11 } : { eventType: e14 });
  const r9 = window, n16 = JSON.stringify({ eventType: e14, eventData: t11 });
  if (K2())
    return ke2(n16, x3());
  if (H3(r9)) {
    r9.TelegramWebviewProxy.postEvent(e14, JSON.stringify(t11));
    return;
  }
  if (is(looseObject({ external: looseObject({ notify: function_() }) }), r9)) {
    r9.external.notify(n16);
    return;
  }
  throw new Ee2();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i4 = 0; i4 < 256; ++i4) {
  byteToHex.push((i4 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  const arr = new Uint8Array(16);
  arr[0] = (v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v6 >>> 16 & 255;
  arr[2] = v6 >>> 8 & 255;
  arr[3] = v6 & 255;
  arr[4] = (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v6 & 255;
  arr[6] = (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v6 & 255;
  arr[8] = (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v6 & 255;
  arr[10] = (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v6 / 4294967296 & 255;
  arr[12] = v6 >>> 24 & 255;
  arr[13] = v6 >>> 16 & 255;
  arr[14] = v6 >>> 8 & 255;
  arr[15] = v6 & 255;
  return arr;
}
var parse_default = parse2;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i4 = 0; i4 < str.length; ++i4) {
    bytes.push(str.charCodeAt(i4));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i4 = 0; i4 < 16; ++i4) {
        buf[offset + i4] = bytes[i4];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes[i4] = msg.charCodeAt(i4);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i4 = 0; i4 < length32; i4 += 8) {
    const x4 = input[i4 >> 5] >>> i4 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x4 >>> 4 & 15) + hexTab.charAt(x4 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x4, len) {
  x4[len >> 5] |= 128 << len % 32;
  x4[getOutputLength(len) - 1] = len;
  let a9 = 1732584193;
  let b4 = -271733879;
  let c3 = -1732584194;
  let d8 = 271733878;
  for (let i4 = 0; i4 < x4.length; i4 += 16) {
    const olda = a9;
    const oldb = b4;
    const oldc = c3;
    const oldd = d8;
    a9 = md5ff(a9, b4, c3, d8, x4[i4], 7, -680876936);
    d8 = md5ff(d8, a9, b4, c3, x4[i4 + 1], 12, -389564586);
    c3 = md5ff(c3, d8, a9, b4, x4[i4 + 2], 17, 606105819);
    b4 = md5ff(b4, c3, d8, a9, x4[i4 + 3], 22, -1044525330);
    a9 = md5ff(a9, b4, c3, d8, x4[i4 + 4], 7, -176418897);
    d8 = md5ff(d8, a9, b4, c3, x4[i4 + 5], 12, 1200080426);
    c3 = md5ff(c3, d8, a9, b4, x4[i4 + 6], 17, -1473231341);
    b4 = md5ff(b4, c3, d8, a9, x4[i4 + 7], 22, -45705983);
    a9 = md5ff(a9, b4, c3, d8, x4[i4 + 8], 7, 1770035416);
    d8 = md5ff(d8, a9, b4, c3, x4[i4 + 9], 12, -1958414417);
    c3 = md5ff(c3, d8, a9, b4, x4[i4 + 10], 17, -42063);
    b4 = md5ff(b4, c3, d8, a9, x4[i4 + 11], 22, -1990404162);
    a9 = md5ff(a9, b4, c3, d8, x4[i4 + 12], 7, 1804603682);
    d8 = md5ff(d8, a9, b4, c3, x4[i4 + 13], 12, -40341101);
    c3 = md5ff(c3, d8, a9, b4, x4[i4 + 14], 17, -1502002290);
    b4 = md5ff(b4, c3, d8, a9, x4[i4 + 15], 22, 1236535329);
    a9 = md5gg(a9, b4, c3, d8, x4[i4 + 1], 5, -165796510);
    d8 = md5gg(d8, a9, b4, c3, x4[i4 + 6], 9, -1069501632);
    c3 = md5gg(c3, d8, a9, b4, x4[i4 + 11], 14, 643717713);
    b4 = md5gg(b4, c3, d8, a9, x4[i4], 20, -373897302);
    a9 = md5gg(a9, b4, c3, d8, x4[i4 + 5], 5, -701558691);
    d8 = md5gg(d8, a9, b4, c3, x4[i4 + 10], 9, 38016083);
    c3 = md5gg(c3, d8, a9, b4, x4[i4 + 15], 14, -660478335);
    b4 = md5gg(b4, c3, d8, a9, x4[i4 + 4], 20, -405537848);
    a9 = md5gg(a9, b4, c3, d8, x4[i4 + 9], 5, 568446438);
    d8 = md5gg(d8, a9, b4, c3, x4[i4 + 14], 9, -1019803690);
    c3 = md5gg(c3, d8, a9, b4, x4[i4 + 3], 14, -187363961);
    b4 = md5gg(b4, c3, d8, a9, x4[i4 + 8], 20, 1163531501);
    a9 = md5gg(a9, b4, c3, d8, x4[i4 + 13], 5, -1444681467);
    d8 = md5gg(d8, a9, b4, c3, x4[i4 + 2], 9, -51403784);
    c3 = md5gg(c3, d8, a9, b4, x4[i4 + 7], 14, 1735328473);
    b4 = md5gg(b4, c3, d8, a9, x4[i4 + 12], 20, -1926607734);
    a9 = md5hh(a9, b4, c3, d8, x4[i4 + 5], 4, -378558);
    d8 = md5hh(d8, a9, b4, c3, x4[i4 + 8], 11, -2022574463);
    c3 = md5hh(c3, d8, a9, b4, x4[i4 + 11], 16, 1839030562);
    b4 = md5hh(b4, c3, d8, a9, x4[i4 + 14], 23, -35309556);
    a9 = md5hh(a9, b4, c3, d8, x4[i4 + 1], 4, -1530992060);
    d8 = md5hh(d8, a9, b4, c3, x4[i4 + 4], 11, 1272893353);
    c3 = md5hh(c3, d8, a9, b4, x4[i4 + 7], 16, -155497632);
    b4 = md5hh(b4, c3, d8, a9, x4[i4 + 10], 23, -1094730640);
    a9 = md5hh(a9, b4, c3, d8, x4[i4 + 13], 4, 681279174);
    d8 = md5hh(d8, a9, b4, c3, x4[i4], 11, -358537222);
    c3 = md5hh(c3, d8, a9, b4, x4[i4 + 3], 16, -722521979);
    b4 = md5hh(b4, c3, d8, a9, x4[i4 + 6], 23, 76029189);
    a9 = md5hh(a9, b4, c3, d8, x4[i4 + 9], 4, -640364487);
    d8 = md5hh(d8, a9, b4, c3, x4[i4 + 12], 11, -421815835);
    c3 = md5hh(c3, d8, a9, b4, x4[i4 + 15], 16, 530742520);
    b4 = md5hh(b4, c3, d8, a9, x4[i4 + 2], 23, -995338651);
    a9 = md5ii(a9, b4, c3, d8, x4[i4], 6, -198630844);
    d8 = md5ii(d8, a9, b4, c3, x4[i4 + 7], 10, 1126891415);
    c3 = md5ii(c3, d8, a9, b4, x4[i4 + 14], 15, -1416354905);
    b4 = md5ii(b4, c3, d8, a9, x4[i4 + 5], 21, -57434055);
    a9 = md5ii(a9, b4, c3, d8, x4[i4 + 12], 6, 1700485571);
    d8 = md5ii(d8, a9, b4, c3, x4[i4 + 3], 10, -1894986606);
    c3 = md5ii(c3, d8, a9, b4, x4[i4 + 10], 15, -1051523);
    b4 = md5ii(b4, c3, d8, a9, x4[i4 + 1], 21, -2054922799);
    a9 = md5ii(a9, b4, c3, d8, x4[i4 + 8], 6, 1873313359);
    d8 = md5ii(d8, a9, b4, c3, x4[i4 + 15], 10, -30611744);
    c3 = md5ii(c3, d8, a9, b4, x4[i4 + 6], 15, -1560198380);
    b4 = md5ii(b4, c3, d8, a9, x4[i4 + 13], 21, 1309151649);
    a9 = md5ii(a9, b4, c3, d8, x4[i4 + 4], 6, -145523070);
    d8 = md5ii(d8, a9, b4, c3, x4[i4 + 11], 10, -1120210379);
    c3 = md5ii(c3, d8, a9, b4, x4[i4 + 2], 15, 718787259);
    b4 = md5ii(b4, c3, d8, a9, x4[i4 + 9], 21, -343485551);
    a9 = safeAdd(a9, olda);
    b4 = safeAdd(b4, oldb);
    c3 = safeAdd(c3, oldc);
    d8 = safeAdd(d8, oldd);
  }
  return [a9, b4, c3, d8];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i4 = 0; i4 < length8; i4 += 8) {
    output[i4 >> 5] |= (input[i4 / 8] & 255) << i4 % 32;
  }
  return output;
}
function safeAdd(x4, y2) {
  const lsw = (x4 & 65535) + (y2 & 65535);
  const msw = (x4 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q3, a9, b4, x4, s4, t11) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a9, q3), safeAdd(x4, t11)), s4), b4);
}
function md5ff(a9, b4, c3, d8, x4, s4, t11) {
  return md5cmn(b4 & c3 | ~b4 & d8, a9, b4, x4, s4, t11);
}
function md5gg(a9, b4, c3, d8, x4, s4, t11) {
  return md5cmn(b4 & d8 | c3 & ~d8, a9, b4, x4, s4, t11);
}
function md5hh(a9, b4, c3, d8, x4, s4, t11) {
  return md5cmn(b4 ^ c3 ^ d8, a9, b4, x4, s4, t11);
}
function md5ii(a9, b4, c3, d8, x4, s4, t11) {
  return md5cmn(c3 ^ (b4 | ~d8), a9, b4, x4, s4, t11);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v32 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i4 = 0; i4 < 16; ++i4) {
      buf[offset + i4] = rnds[i4];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f5(s4, x4, y2, z3) {
  switch (s4) {
    case 0:
      return x4 & y2 ^ ~x4 & z3;
    case 1:
      return x4 ^ y2 ^ z3;
    case 2:
      return x4 & y2 ^ x4 & z3 ^ y2 & z3;
    case 3:
      return x4 ^ y2 ^ z3;
  }
}
function ROTL(x4, n16) {
  return x4 << n16 | x4 >>> 32 - n16;
}
function sha1(bytes) {
  const K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i4 = 0; i4 < msg.length; ++i4) {
      bytes.push(msg.charCodeAt(i4));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l4 = bytes.length / 4 + 2;
  const N3 = Math.ceil(l4 / 16);
  const M3 = new Array(N3);
  for (let i4 = 0; i4 < N3; ++i4) {
    const arr = new Uint32Array(16);
    for (let j3 = 0; j3 < 16; ++j3) {
      arr[j3] = bytes[i4 * 64 + j3 * 4] << 24 | bytes[i4 * 64 + j3 * 4 + 1] << 16 | bytes[i4 * 64 + j3 * 4 + 2] << 8 | bytes[i4 * 64 + j3 * 4 + 3];
    }
    M3[i4] = arr;
  }
  M3[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M3[N3 - 1][14] = Math.floor(M3[N3 - 1][14]);
  M3[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i4 = 0; i4 < N3; ++i4) {
    const W5 = new Uint32Array(80);
    for (let t11 = 0; t11 < 16; ++t11) {
      W5[t11] = M3[i4][t11];
    }
    for (let t11 = 16; t11 < 80; ++t11) {
      W5[t11] = ROTL(W5[t11 - 3] ^ W5[t11 - 8] ^ W5[t11 - 14] ^ W5[t11 - 16], 1);
    }
    let a9 = H4[0];
    let b4 = H4[1];
    let c3 = H4[2];
    let d8 = H4[3];
    let e14 = H4[4];
    for (let t11 = 0; t11 < 80; ++t11) {
      const s4 = Math.floor(t11 / 20);
      const T6 = ROTL(a9, 5) + f5(s4, b4, c3, d8) + e14 + K3[s4] + W5[t11] >>> 0;
      e14 = d8;
      d8 = c3;
      c3 = ROTL(b4, 30) >>> 0;
      b4 = a9;
      a9 = T6;
    }
    H4[0] = H4[0] + a9 >>> 0;
    H4[1] = H4[1] + b4 >>> 0;
    H4[2] = H4[2] + c3 >>> 0;
    H4[3] = H4[3] + d8 >>> 0;
    H4[4] = H4[4] + e14 >>> 0;
  }
  return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@aptos-connect/web-transport/dist/index.mjs
var DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };
var PROMPT_POLLER_INTERVAL = 500;
var dismissalSerializedResponse = ConnectResponse.serialize({
  status: "dismissed"
});
var PromptUnauthorizedError = class extends Error {
  constructor() {
    super("Unauthorized");
  }
};
function openPrompt(url, size = DEFAULT_PROMPT_SIZE) {
  const { height, width } = size;
  const options = {
    height,
    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),
    popup: true,
    top: window.screenTop + Math.round((window.outerHeight - height) / 2),
    width
  };
  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);
  const href = url instanceof URL ? url.href : url;
  const promptWindow = window.open(href, void 0, strOptions);
  if (promptWindow === null) {
    throw new Error("Couldn't open prompt");
  }
  return promptWindow;
}
async function waitForPromptResponse(baseUrl, promptWindow, request) {
  return new Promise((resolve, reject) => {
    const listeners2 = {
      onMessage: (message) => {
        if (message.source !== promptWindow || message.origin !== baseUrl) {
          return;
        }
        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {
          window.removeEventListener("message", listeners2.onMessage);
          clearTimeout(listeners2.promptPollerId);
          reject(new PromptUnauthorizedError());
          return;
        }
        if (isTypedMessage(PromptConnectionRequestMessage, message.data)) {
          promptWindow.postMessage(
            new PromptConnectionResponseMessage(request),
            baseUrl
          );
          return;
        }
        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {
          window.removeEventListener("message", listeners2.onMessage);
          clearTimeout(listeners2.promptPollerId);
          resolve(message.data.serializedValue);
        }
      },
      promptPollerId: setInterval(() => {
        if (promptWindow.closed) {
          window.removeEventListener("message", listeners2.onMessage);
          clearTimeout(listeners2.promptPollerId);
          resolve(dismissalSerializedResponse);
        }
      }, PROMPT_POLLER_INTERVAL)
    };
    window.addEventListener("message", listeners2.onMessage);
  });
}
var localDappStateKey = "@aptos-connect/dapp-local-state";
function serializeLocalDappState(state) {
  const serializer = new n();
  serializer.serializeU32AsUleb128(state.connectedAccounts.length);
  for (const account of state.connectedAccounts) {
    serializeAccountInfo(serializer, account);
  }
  return serializer.toUint8Array();
}
function deserializeLocalDappState(serializedValue) {
  const deserializer = new a2(serializedValue);
  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();
  const connectedAccounts = [];
  for (let i4 = 0; i4 < connectedAccountsLength; i4 += 1) {
    connectedAccounts.push(deserializeAccountInfo(deserializer));
  }
  return { connectedAccounts };
}
function getState() {
  const encodedValue = window.localStorage.getItem(localDappStateKey);
  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : { connectedAccounts: [] };
}
function setState(state) {
  const serializedValue = serializeLocalDappState(state);
  const encodedValue = bytesToBase64(serializedValue);
  window.localStorage.setItem(localDappStateKey, encodedValue);
}
function getConnectedAccounts() {
  const state = getState();
  return state.connectedAccounts;
}
function addConnectedAccount(account) {
  const { connectedAccounts, ...state } = getState();
  connectedAccounts.push(account);
  setState({ ...state, connectedAccounts });
}
function removeConnectedAccount(address) {
  const { connectedAccounts, ...state } = getState();
  const index = connectedAccounts.findIndex((a9) => a9.address.equals(address));
  if (index >= 0) {
    connectedAccounts.splice(index, 1);
  }
  setState({ ...state, connectedAccounts });
}
async function createWalletRequest(baseUrl, request) {
  const encodedClientIdentityKey = bytesToBase64url(
    request.clientIdentityKey.toUint8Array()
  );
  const response = await fetch(
    `${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/`,
    {
      body: JSON.stringify({
        body: encodeWalletRequestBody(request.body),
        id: request.id,
        signature: bytesToBase64(request.signature.toUint8Array()),
        timestamp: request.timestamp
      }),
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      method: "post"
    }
  );
  if (!response.ok) {
    throw new Error("Failed creating the wallet request");
  }
}
var identityKeyStorageKey = "@aptos-connect/client-identity-key";
function getClientIdentityKey() {
  const serialized = window.localStorage.getItem(identityKeyStorageKey);
  if (serialized) {
    return new L(serialized);
  }
  const identityKey = L.generate();
  window.localStorage.setItem(identityKeyStorageKey, identityKey.toString());
  return identityKey;
}
var ON_RESUME_DELAY = 300;
var FG_RESPONSE_POLLING_INTERVAL = 2e3;
var BG_RESPONSE_POLLING_INTERVAL = 3e3;
var POLLING_TIMEOUT = 5 * 6e4;
function waitFor(milliseconds) {
  let timeoutId;
  let cancel = () => {
  };
  const timer = new Promise((resolve) => {
    timeoutId = setTimeout(resolve, milliseconds);
    cancel = () => {
      clearTimeout(timeoutId);
      resolve();
    };
  });
  timer.cancel = cancel;
  return timer;
}
async function smartPolling(callback) {
  let timer;
  let justResumed = false;
  let pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  const onWindowFocus = () => {
    justResumed = true;
    pollingInterval = FG_RESPONSE_POLLING_INTERVAL;
    timer == null ? void 0 : timer.cancel();
  };
  const onWindowBlur = () => {
    pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  };
  window.addEventListener("focus", onWindowFocus);
  window.addEventListener("blur", onWindowBlur);
  try {
    const startTime = Date.now();
    while (Date.now() - startTime < POLLING_TIMEOUT) {
      timer = waitFor(pollingInterval);
      await timer;
      if (justResumed) {
        timer = waitFor(ON_RESUME_DELAY);
        await timer;
      }
      const response = await callback();
      if (response.status === 200) {
        return response;
      }
      justResumed = false;
    }
    throw new Error("Timeout");
  } finally {
    window.removeEventListener("focus", onWindowFocus);
    window.removeEventListener("blur", onWindowFocus);
  }
}
async function getWalletResponse(baseUrl, clientIdentityKey, requestId) {
  const encodedClientIdentityKey = bytesToBase64url(
    clientIdentityKey.toUint8Array()
  );
  const url = new URL(
    `${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/${requestId}/response/`
  );
  const response = await smartPolling(
    () => fetch(url, {
      headers: { Accept: "application/json" },
      method: "get"
    })
  );
  const responseBody = await response.json();
  const data = base64ToBytes(responseBody.data.body);
  return { data };
}
async function openTelegramPrompt(args) {
  const {
    baseUrl,
    provider,
    request: body,
    tgWebAppUrl = "/AptosConnectBot/AptosConnect"
  } = args;
  const identityKey = getClientIdentityKey();
  const clientIdentityKey = identityKey.publicKey();
  const requestId = v4_default();
  const timestamp = Date.now();
  const challenge = makePopupWalletRequestChallenge({
    body,
    id: requestId,
    timestamp
  });
  const signature = identityKey.sign(challenge);
  const signedWalletRequest = {
    body,
    clientIdentityKey,
    id: requestId,
    signature,
    timestamp
  };
  let encodedRequest = encodePopupWalletRequest(signedWalletRequest);
  if (encodedRequest.length > 1024) {
    void createWalletRequest(baseUrl, signedWalletRequest);
    encodedRequest = encodePopupWalletRequest({
      clientIdentityKey,
      id: requestId,
      signature,
      timestamp
    });
  }
  const startParam = `prompt_${provider ?? ""}${encodedRequest}`;
  Z2("web_app_open_tg_link", {
    path_full: `${tgWebAppUrl}?startapp=${startParam}`
  });
  return getWalletResponse(baseUrl, clientIdentityKey, requestId);
}
function isTelegramMiniApp() {
  return window.TelegramWebviewProxy !== void 0;
}
var WebWalletTransport = class {
  constructor(baseUrl, provider = "google", tgWebAppUrl) {
    this.baseUrl = baseUrl;
    this.provider = provider;
    this.tgWebAppUrl = tgWebAppUrl;
    this.baseUrl = baseUrl;
  }
  async sendPromptRequest(request) {
    if (isTelegramMiniApp()) {
      return openTelegramPrompt({
        baseUrl: this.baseUrl,
        provider: this.provider,
        request,
        tgWebAppUrl: this.tgWebAppUrl
      });
    }
    const url = new URL(`${this.baseUrl}/prompt/`);
    url.searchParams.set("provider", this.provider);
    const prompt = openPrompt(url);
    return waitForPromptResponse(this.baseUrl, prompt, request);
  }
  async sendRequest(request) {
    switch (request.name) {
      case IsConnectedRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return IsConnectedResponse.serialize(connectedAccounts.length > 0);
      }
      case GetConnectedAccountsRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return GetConnectedAccountsResponse.serialize(connectedAccounts);
      }
      case ConnectRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request);
        const response = ConnectResponse.deserialize(serializedResponse);
        if (response.args.status === "approved") {
          const { account, pairing } = response.args.args;
          if (pairing === void 0) {
            addConnectedAccount(account);
          }
        }
        return serializedResponse;
      }
      case SignInRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request);
        const response = SignInResponse.deserialize(
          serializedResponse,
          request.version === 1 ? 1 : 2
        );
        if (response.args.status === "approved") {
          const { account } = response.args.args;
          addConnectedAccount(account);
        }
        return serializedResponse;
      }
      case DisconnectRequest.name: {
        const [activeAccount] = getConnectedAccounts();
        if (activeAccount) {
          removeConnectedAccount(activeAccount.address);
        }
        return DisconnectResponse.serialize({});
      }
      case SignMessageRequest.name:
      case SignTransactionRequest.name:
      case SignAndSubmitTransactionRequest.name: {
        return this.sendPromptRequest(request);
      }
      default: {
        throw new Error("Unexpected request");
      }
    }
  }
};

// node_modules/@identity-connect/api/dist/index.mjs
var AuthError = {
  missing_client: "missing_client",
  redirect_mismatch: "redirect_mismatch",
  state_mismatch: "state_mismatch"
};
var AuthErrorMessages = {
  [AuthError.state_mismatch]: {
    code: 0,
    description: "State mismatch",
    shortMessage: "An error occurred while logging in, please try again."
  },
  [AuthError.redirect_mismatch]: {
    code: 1,
    description: "Redirect mismatch",
    shortMessage: "An error occurred while logging in, please try again."
  },
  [AuthError.missing_client]: {
    code: 2,
    description: "Missing client",
    shortMessage: "An error occurred while logging in, please try again."
  }
};
var NetworkName = ((NetworkName22) => {
  NetworkName22["DEVNET"] = "devnet";
  NetworkName22["MAINNET"] = "mainnet";
  NetworkName22["TESTNET"] = "testnet";
  return NetworkName22;
})(NetworkName || {});
var PairingStatus = ((PairingStatus2) => {
  PairingStatus2["Finalized"] = "FINALIZED";
  PairingStatus2["Pending"] = "PENDING";
  return PairingStatus2;
})(PairingStatus || {});
var SigningRequestTypes = ((SigningRequestTypes2) => {
  SigningRequestTypes2["SIGN_AND_SUBMIT_TRANSACTION"] = "SIGN_AND_SUBMIT_TRANSACTION";
  SigningRequestTypes2["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  SigningRequestTypes2["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  return SigningRequestTypes2;
})(SigningRequestTypes || {});
var SigningRequestStatus = ((SigningRequestStatus2) => {
  SigningRequestStatus2["APPROVED"] = "APPROVED";
  SigningRequestStatus2["CANCELLED"] = "CANCELLED";
  SigningRequestStatus2["INVALID"] = "INVALID";
  SigningRequestStatus2["PENDING"] = "PENDING";
  SigningRequestStatus2["REJECTED"] = "REJECTED";
  return SigningRequestStatus2;
})(SigningRequestStatus || {});
var WalletOSEnum = ((WalletOSEnum2) => {
  WalletOSEnum2["Android"] = "android";
  WalletOSEnum2["IdentityConnect"] = "ic";
  WalletOSEnum2["Linux"] = "linux";
  WalletOSEnum2["Macos"] = "osx";
  WalletOSEnum2["Windows"] = "win";
  WalletOSEnum2["iOS"] = "ios";
  return WalletOSEnum2;
})(WalletOSEnum || {});
var WalletPlatformEnum = ((WalletPlatformEnum2) => {
  WalletPlatformEnum2["BraveExtension"] = "brave-extension";
  WalletPlatformEnum2["ChromeExtension"] = "chrome-extension";
  WalletPlatformEnum2["FirefoxExtension"] = "firefox-extension";
  WalletPlatformEnum2["IcDappWallet"] = "ic-dapp-wallet";
  WalletPlatformEnum2["KiwiExtension"] = "kiwi-extension";
  WalletPlatformEnum2["NativeApp"] = "native-app";
  WalletPlatformEnum2["OperaExtension"] = "opera-extension";
  WalletPlatformEnum2["SafariExtension"] = "safari-extension";
  return WalletPlatformEnum2;
})(WalletPlatformEnum || {});

// node_modules/@identity-connect/wallet-api/dist/index.mjs
function isBcsSerializable(value) {
  return (value == null ? void 0 : value.serialize) !== void 0 && (value == null ? void 0 : value.bcsToBytes) !== void 0 && (value == null ? void 0 : value.bcsToHex) !== void 0;
}
function bcsSerialize(serializable) {
  return serializable.bcsToHex().toString();
}
function bcsDeserialize(deserializableClass, serializedValue) {
  const serializedValueBytes = a.fromHexString(serializedValue).toUint8Array();
  const deserializer = new a2(serializedValueBytes);
  return deserializableClass.deserialize(deserializer);
}
var UnexpectedValueError = class _UnexpectedValueError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnexpectedValueError";
    Object.setPrototypeOf(this, _UnexpectedValueError.prototype);
  }
};
function serializeEntryFunctionArg(arg) {
  if (arg instanceof Uint8Array) {
    return {
      type: "Uint8Array",
      value: a.fromHexInput(arg).toString()
    };
  }
  if (Array.isArray(arg)) {
    return arg.map(serializeEntryFunctionArg);
  }
  return arg;
}
function serializeEntryFunctionPayload(payload) {
  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);
  return {
    ...payload,
    arguments: normalizedArgs,
    type: "entry_function_payload"
  };
}
function serializeJsonTransactionPayload(payload) {
  if (payload.type === "entry_function_payload" || payload.type === void 0) {
    return serializeEntryFunctionPayload(payload);
  }
  if (payload.type === "multisig_payload") {
    const innerPayload = payload.transaction_payload !== void 0 ? serializeEntryFunctionPayload(payload.transaction_payload) : void 0;
    return { ...payload, transaction_payload: innerPayload };
  }
  throw new UnexpectedValueError();
}
function serializeRawTransaction(rawTxn) {
  const value = bcsSerialize(rawTxn);
  if ("fee_payer_address" in rawTxn) {
    return { type: "fee_payer_raw_txn", value };
  }
  if ("secondary_signer_addresses" in rawTxn) {
    return { type: "multi_agent_raw_txn", value };
  }
  if ("chain_id" in rawTxn) {
    return { type: "raw_txn", value };
  }
  throw new UnexpectedValueError("Invalid raw transaction type");
}
function serializeSignAndSubmitTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("feePayerAuthenticator" in args) {
    return {
      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),
      rawTxn: serializeRawTransaction(args.rawTxn)
    };
  }
  if ("rawTxn" in args) {
    return { rawTxn: serializeRawTransaction(args.rawTxn) };
  }
  throw new UnexpectedValueError();
}
function serializeSignTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("rawTxn" in args) {
    const serializedRawTxn = serializeRawTransaction(args.rawTxn);
    return { rawTxn: serializedRawTxn };
  }
  throw new UnexpectedValueError();
}
function deserializeSignTransactionResponseArgs(args) {
  const accountAuthenticator = bcsDeserialize(
    W2,
    args.accountAuthenticator
  );
  if ("rawTxn" in args) {
    const rawTxn = bcsDeserialize(he, args.rawTxn);
    return { accountAuthenticator, rawTxn };
  }
  return { accountAuthenticator };
}

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e14) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = [
  "ReadableStream",
  "Request",
  "Response",
  "Headers"
].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i4;
  let l4;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i4 = 0, l4 = obj.length; i4 < l4; i4++) {
      fn.call(null, obj[i4], i4, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i4 = 0; i4 < len; i4++) {
      key = keys[i4];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i4 = keys.length;
  let _key;
  while (i4-- > 0) {
    _key = keys[i4];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i4 = 0, l4 = arguments.length; i4 < l4; i4++) {
    arguments[i4] && forEach(arguments[i4], assignValue);
  }
  return result;
}
var extend = (a9, b4, thisArg, { allOwnKeys } = {}) => {
  forEach(
    b4,
    (val, key) => {
      if (thisArg && isFunction(val)) {
        Object.defineProperty(a9, key, {
          value: bind(val, thisArg),
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else {
        Object.defineProperty(a9, key, {
          value: val,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    },
    { allOwnKeys }
  );
  return a9;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(
    superConstructor.prototype,
    descriptors
  );
  Object.defineProperty(constructor.prototype, "constructor", {
    value: constructor,
    writable: true,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i4;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i4 = props.length;
    while (i4-- > 0) {
      prop = props[i4];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i4 = thing.length;
  if (!isNumber(i4)) return null;
  const arr = new Array(i4);
  while (i4-- > 0) {
    arr[i4] = thing[i4];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m2, p1, p22) {
    return p1.toUpperCase() + p22;
  });
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i4) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i4] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i4 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i4] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener(
      "message",
      ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      },
      false
    );
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(typeof setImmediate === "function", isFunction(_global.postMessage));
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
var AxiosError = class _AxiosError extends Error {
  static from(error, code, config, request, response, customProps) {
    const axiosError = new _AxiosError(error.message, code || error.code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  }
  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [config] The config.
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   *
   * @returns {Error} The created error.
   */
  constructor(message, code, config, request, response) {
    super(message);
    this.name = "AxiosError";
    this.isAxiosError = true;
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status;
    }
  }
  toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
};
AxiosError.ERR_BAD_OPTION_VALUE = "ERR_BAD_OPTION_VALUE";
AxiosError.ERR_BAD_OPTION = "ERR_BAD_OPTION";
AxiosError.ECONNABORTED = "ECONNABORTED";
AxiosError.ETIMEDOUT = "ETIMEDOUT";
AxiosError.ERR_NETWORK = "ERR_NETWORK";
AxiosError.ERR_FR_TOO_MANY_REDIRECTS = "ERR_FR_TOO_MANY_REDIRECTS";
AxiosError.ERR_DEPRECATED = "ERR_DEPRECATED";
AxiosError.ERR_BAD_RESPONSE = "ERR_BAD_RESPONSE";
AxiosError.ERR_BAD_REQUEST = "ERR_BAD_REQUEST";
AxiosError.ERR_CANCELED = "ERR_CANCELED";
AxiosError.ERR_NOT_SUPPORT = "ERR_NOT_SUPPORT";
AxiosError.ERR_INVALID_URL = "ERR_INVALID_URL";
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i4) {
    token = removeBrackets(token);
    return !dots && i4 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const _options = utils_default.isFunction(options) ? {
    serialize: options
  } : options;
  const serializeFn = _options && _options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, _options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, _options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   * @param {Object} options The options for the interceptor, synchronous and runWhen
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h3) {
      if (h3 !== null) {
        fn(h3);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false,
  legacyInterceptorReqResOrdering: true
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i4;
  const len = keys.length;
  let key;
  for (i4 = 0; i4 < len; i4++) {
    key = keys[i4];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e14) {
      if (e14.name !== "SyntaxError") {
        throw e14;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e14) {
        if (strictJSONParsing) {
          if (e14.name === "SyntaxError") {
            throw AxiosError_default.from(e14, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e14;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i4;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i4 = line.indexOf(":");
    key = line.substring(0, i4).trim().toLowerCase();
    val = line.substring(i4 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w3, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i4 = keys.length;
    let deleted = false;
    while (i4--) {
      const key = keys[i4];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
var CanceledError = class extends AxiosError_default {
  /**
   * A `CanceledError` is an object that is thrown when an operation is canceled.
   *
   * @param {string=} message The message.
   * @param {Object=} config The config.
   * @param {Object=} request The request.
   *
   * @returns {CanceledError} The created error.
   */
  constructor(message, config, request) {
    super(message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
    this.name = "CanceledError";
    this.__CANCEL__ = true;
  }
};
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i4 = tail;
    let bytesCount = 0;
    while (i4 !== head) {
      bytesCount += bytes[i4++];
      i4 = i4 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e14) => {
    const loaded = e14.loaded;
    const total = e14.lengthComputable ? e14.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e14,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure, sameSite) {
      if (typeof document === "undefined") return;
      const cookie = [`${name}=${encodeURIComponent(value)}`];
      if (utils_default.isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils_default.isString(path)) {
        cookie.push(`path=${path}`);
      }
      if (utils_default.isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      if (utils_default.isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie.join("; ");
    },
    read(name) {
      if (typeof document === "undefined") return null;
      const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
      return match ? decodeURIComponent(match[1]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  if (typeof url !== "string") {
    return false;
  }
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a9, b4, prop, caseless) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(a9, b4, prop, caseless);
    } else if (!utils_default.isUndefined(a9)) {
      return getMergedValue(void 0, a9, prop, caseless);
    }
  }
  function valueFromConfig2(a9, b4) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    }
  }
  function defaultToConfig2(a9, b4) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    } else if (!utils_default.isUndefined(a9)) {
      return getMergedValue(void 0, a9);
    }
  }
  function mergeDirectKeys(a9, b4, prop) {
    if (prop in config2) {
      return getMergedValue(a9, b4);
    } else if (prop in config1) {
      return getMergedValue(void 0, a9);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a9, b4, prop) => mergeDeepProperties(headersToObject(a9), headersToObject(b4), prop, true)
  };
  utils_default.forEach(
    Object.keys({ ...config1, ...config2 }),
    function computeConfigValue(prop) {
      if (prop === "__proto__" || prop === "constructor" || prop === "prototype")
        return;
      const merge2 = utils_default.hasOwnProp(mergeMap, prop) ? mergeMap[prop] : mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    }
  );
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout of ${timeout}ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e14) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e14);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder: TextEncoder2
} = utils_default.global;
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e14) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request, Response } = env;
  const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request);
  const isResponseSupported = isFunction2(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request, err && err.response),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request, err && err.response);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config) => {
  let env = config && config.env || {};
  const { fetch: fetch2, Request, Response } = env;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i4 = len, seed, target, map = seedCache;
  while (i4--) {
    seed = seeds[i4];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i4 ? /* @__PURE__ */ new Map() : factory(env));
    map = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e14) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
function getAdapter(adapters, config) {
  adapters = utils_default.isArray(adapters) ? adapters : [adapters];
  const { length } = adapters;
  let nameOrAdapter;
  let adapter2;
  const rejectedReasons = {};
  for (let i4 = 0; i4 < length; i4++) {
    nameOrAdapter = adapters[i4];
    let id;
    adapter2 = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter2 === void 0) {
        throw new AxiosError_default(`Unknown adapter '${id}'`);
      }
    }
    if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
      break;
    }
    rejectedReasons[id || "#" + i4] = adapter2;
  }
  if (!adapter2) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s4 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError_default(
      `There is no suitable adapter to dispatch the request ` + s4,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter2;
}
var adapters_default = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.13.5";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i4) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i4 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i4 = keys.length;
  while (i4-- > 0) {
    const opt = keys[i4];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e14) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean),
        legacyInterceptorReqResOrdering: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      const transitional3 = config.transitional || transitional_default;
      const legacyInterceptorReqResOrdering = transitional3 && transitional3.legacyInterceptorReqResOrdering;
      if (legacyInterceptorReqResOrdering) {
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      } else {
        requestInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      }
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i4 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i4 < len) {
        promise = promise.then(chain[i4++], chain[i4++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i4 < len) {
      const onFulfilled = requestInterceptorChain[i4++];
      const onRejected = requestInterceptorChain[i4++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i4 = 0;
    len = responseInterceptorChain.length;
    while (i4 < len) {
      promise = promise.then(responseInterceptorChain[i4++], responseInterceptorChain[i4++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i4 = token._listeners.length;
      while (i4-- > 0) {
        token._listeners[i4](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c3) {
      cancel = c3;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter: getAdapter2,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@identity-connect/dapp-sdk/dist/index.mjs
var DEFAULT_FRONTEND_URL = "https://web.petra.app";
function convertToSerializableArgument(argument) {
  if (argument === void 0 || argument === null) {
    return argument;
  }
  if (Array.isArray(argument)) {
    return argument.map(
      (subArgument) => convertToSerializableArgument(subArgument)
    );
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || argument instanceof Uint8Array) {
    return argument;
  }
  if (typeof argument === "bigint") {
    return argument.toString();
  }
  if (argument instanceof ArrayBuffer) {
    return new Uint8Array(argument);
  }
  if ("values" in argument) {
    return argument.values.map(
      (subArgument) => convertToSerializableArgument(subArgument)
    );
  }
  if ("data" in argument) {
    return l.from(argument.data).toString();
  }
  if (argument.value === void 0) {
    return void 0;
  }
  if (typeof argument.value === "string" || typeof argument.value === "number" || typeof argument.value === "boolean" || argument.value instanceof Uint8Array) {
    return argument.value;
  }
  if (typeof argument.value === "bigint") {
    return argument.value.toString();
  }
  throw new Error("Unexpected argument");
}
function normalizePayloadForIC(payload, aptosConfig) {
  if ("bcsToBytes" in payload) {
    return payload;
  }
  if ("bytecode" in payload) {
    return Sr(payload);
  }
  if (aptosConfig) {
    return payload.abi !== void 0 ? lc({ ...payload, abi: payload.abi }) : Sr({ aptosConfig, ...payload });
  }
  const entryFunctionPayload = {
    arguments: payload.functionArguments.map(convertToSerializableArgument),
    function: payload.function,
    type: "entry_function_payload",
    type_arguments: (payload.typeArguments ?? []).map((ta) => ta.toString())
  };
  return "multisigAddress" in payload ? {
    multisig_address: l.from(
      payload.multisigAddress
    ).toString(),
    transaction_payload: entryFunctionPayload,
    type: "multisig_payload"
  } : entryFunctionPayload;
}
var SignatureRequestError = class _SignatureRequestError extends Error {
  constructor(status) {
    super(status);
    this.name = "SignatureRequestError";
    Object.setPrototypeOf(this, _SignatureRequestError.prototype);
  }
};
var UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {
  constructor(missingFields) {
    const message = `Missing the following fields: ${missingFields.join(", ")}`;
    super(message);
    this.name = "UnexpectedSignatureResponseError";
    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);
  }
};
var PairingExpiredError = class _PairingExpiredError extends Error {
  constructor() {
    super();
    this.name = "PairingExpiredError";
    Object.setPrototypeOf(this, _PairingExpiredError.prototype);
  }
};
var DAPP_PAIRINGS_WINDOW_STORAGE_KEY = "icDappPairings";
var windowStateAccessors = {
  async get(address) {
    const pairings = await this.getAll();
    return pairings[address];
  },
  async getAll() {
    const serialized = window.localStorage.getItem(
      DAPP_PAIRINGS_WINDOW_STORAGE_KEY
    );
    return serialized ? JSON.parse(serialized) : {};
  },
  async update(address, pairing) {
    const pairings = await this.getAll();
    if (pairing === void 0) {
      delete pairings[address];
    } else {
      pairings[address] = pairing;
    }
    const newSerialized = JSON.stringify(pairings);
    window.localStorage.setItem(
      DAPP_PAIRINGS_WINDOW_STORAGE_KEY,
      newSerialized
    );
  }
};
var SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [
  "address",
  "application",
  "chainId",
  "fullMessage",
  "message",
  "nonce",
  "prefix",
  "signature"
];
function validateSignMessageResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = ["hash"];
function validateSignAndSubmitTransactionResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var API_VERSION = "0.2.0";
var SIGNING_REQUEST_POLLING_INTERVAL = 2500;
var SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\S+ to be )?(\d+)/;
async function waitFor2(milliseconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
}
async function withRetries(requestFn, onError, retries = 1) {
  for (let i4 = 0; i4 < retries; i4 += 1) {
    try {
      return await requestFn();
    } catch (err) {
      onError(err);
    }
  }
  return requestFn();
}
var ACPairingClient = class {
  constructor({
    accessors = windowStateAccessors,
    axiosConfig,
    defaultNetworkName = NetworkName.MAINNET
  } = {}) {
    this.onDisconnectListeners = /* @__PURE__ */ new Set();
    this.accessors = accessors;
    this.defaultNetworkName = defaultNetworkName;
    this.axiosInstance = axios_default.create({
      baseURL: DEFAULT_FRONTEND_URL,
      ...axiosConfig
    });
    const isClientSideRendering = typeof window !== "undefined";
    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;
  }
  async getPairing(id) {
    const response = await this.axiosInstance.get(
      `v1/pairing/${id}/`
    );
    return response.data.data.pairing;
  }
  async syncFirstPairing() {
    const pairings = await this.accessors.getAll();
    const firstPairing = Object.values(pairings)[0];
    if (firstPairing === void 0) {
      return;
    }
    try {
      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);
      await this.accessors.update(firstPairing.accountAddress, {
        ...firstPairing,
        currSequenceNumber: maxDappSequenceNumber,
        dappWalletId: dappSpecificWallet == null ? void 0 : dappSpecificWallet.id
      });
    } catch (_err) {
      await this.accessors.update(firstPairing.accountAddress, void 0);
    }
  }
  async createSigningRequest(pairing, type, networkName, requestBody) {
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(
      pairing.accountTransportEd25519PublicKeyB64
    );
    let sequenceNumber = pairing.currSequenceNumber + 1;
    return withRetries(
      async () => {
        const requestEnvelope = await encryptAndSignEnvelope(
          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          sequenceNumber,
          { apiVersion: API_VERSION, networkName, requestType: type },
          requestBody
        );
        const response = await this.axiosInstance.post(
          `v1/pairing/${pairing.pairingId}/signing-request/`,
          requestEnvelope
        );
        await this.accessors.update(pairing.accountAddress, {
          ...pairing,
          currSequenceNumber: sequenceNumber
        });
        return response.data.data.signingRequest;
      },
      (err) => {
        var _a, _b, _c;
        if (isAxiosError2(err)) {
          const errorMessage = (_b = (_a = err.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message;
          const expectedSequenceNumber = (_c = errorMessage == null ? void 0 : errorMessage.match(
            SEQUENCE_NUMBER_MISMATCH_PATTERN
          )) == null ? void 0 : _c[1];
          if (expectedSequenceNumber !== void 0) {
            sequenceNumber = Number(expectedSequenceNumber);
            return;
          }
        }
        throw err;
      }
    );
  }
  async getSigningRequest(id) {
    var _a, _b;
    const response = await this.axiosInstance.get(`v1/signing-request/${id}/`, {
      validateStatus: (status) => status === 200 || status === 404
    });
    return (_b = (_a = response.data) == null ? void 0 : _a.data) == null ? void 0 : _b.signingRequest;
  }
  async deletePairing(pairingId, secretKey, publicKey) {
    const requestEnvelope = await encryptAndSignEnvelope(
      secretKey,
      publicKey,
      publicKey,
      0,
      // ignored
      {},
      {}
    );
    await this.axiosInstance.post(
      `v1/pairing/${pairingId}/delete/`,
      requestEnvelope,
      { validateStatus: (status) => status === 204 || status === 404 }
    );
  }
  async cancelSigningRequest(pairing, id) {
    const sequenceNumber = pairing.currSequenceNumber;
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(
      pairing.accountTransportEd25519PublicKeyB64
    );
    const requestEnvelope = await encryptAndSignEnvelope(
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      sequenceNumber + 1,
      {},
      {}
    );
    const response = await this.axiosInstance.patch(
      `v1/signing-request/${id}/cancel/`,
      requestEnvelope
    );
    await this.accessors.update(pairing.accountAddress, {
      ...pairing,
      currSequenceNumber: sequenceNumber + 1
    });
    return response.data.data.signingRequest;
  }
  async signRequest(address, type, requestBody, { cancelToken, networkName } = {}) {
    await this.initPromise;
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The requested account is not paired");
    }
    let signingRequest;
    try {
      signingRequest = await this.createSigningRequest(
        pairing,
        type,
        networkName || this.defaultNetworkName,
        requestBody
      );
      while (signingRequest.status === "PENDING") {
        await waitFor2(SIGNING_REQUEST_POLLING_INTERVAL);
        if (cancelToken == null ? void 0 : cancelToken.cancelled) {
          signingRequest.status = SigningRequestStatus.CANCELLED;
          break;
        }
        signingRequest = await this.getSigningRequest(signingRequest.id) ?? signingRequest;
      }
    } catch (err) {
      if (isAxiosError2(err) && err.code === "404") {
        await this.accessors.update(address, void 0);
        for (const listener of this.onDisconnectListeners) {
          listener(address);
        }
        throw new PairingExpiredError();
      }
      throw err;
    }
    if (signingRequest.status !== "APPROVED") {
      throw new SignatureRequestError(signingRequest.status);
    }
    const decrypted = decryptEnvelope(
      toKey(
        decodeBase64(pairing.accountTransportEd25519PublicKeyB64),
        KeyTypes.Ed25519PublicKey
      ),
      toKey(
        decodeBase64(pairing.dappEd25519SecretKeyB64),
        KeyTypes.Ed25519SecretKey
      ),
      signingRequest.responseEnvelope
    );
    return decrypted.privateMessage;
  }
  // region Public API
  /**
   * Requests a connection to an account (internally known as pairing).
   * @returns either the address of the connected account, or undefined if the
   * connection was cancelled.
   */
  async addPairing({ publicKey, secretKey }, finalizedPairing) {
    await this.accessors.update(finalizedPairing.account.accountAddress, {
      accountAddress: finalizedPairing.account.accountAddress,
      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,
      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,
      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,
      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,
      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),
      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),
      dappWalletId: finalizedPairing.dappSpecificWalletId,
      pairingId: finalizedPairing.id
    });
  }
  async disconnect(address) {
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The specified account is not paired");
    }
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    await this.deletePairing(
      pairing.pairingId,
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey)
    );
    await this.accessors.update(address, void 0);
    for (const listener of this.onDisconnectListeners) {
      listener(address);
    }
  }
  async signMessage(address, args, options) {
    const response = await this.signRequest(address, SigningRequestTypes.SIGN_MESSAGE, args, options);
    validateSignMessageResponse(response);
    return response;
  }
  async signTransaction(address, args, options) {
    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);
    const serializedResponseArgs = await this.signRequest(
      address,
      SigningRequestTypes.SIGN_TRANSACTION,
      serializedRequestArgs,
      options
    );
    return deserializeSignTransactionResponseArgs(serializedResponseArgs);
  }
  // endregion
  async signAndSubmitTransaction(address, args, options) {
    var _a, _b, _c, _d;
    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);
    try {
      const responseArgs = await this.signRequest(
        address,
        SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION,
        serializedRequestArgs,
        options
      );
      validateSignAndSubmitTransactionResponse(responseArgs);
      return responseArgs;
    } catch (e14) {
      if (e14 instanceof AxiosError2 && ((_b = (_a = e14.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message)) {
        throw new Error((_d = (_c = e14.response) == null ? void 0 : _c.data) == null ? void 0 : _d.message);
      }
      throw e14;
    }
  }
  async getConnectedAccounts() {
    await this.initPromise;
    const pairings = await this.accessors.getAll();
    return Object.values(pairings).map(
      ({
        accountAddress,
        accountEd25519PublicKeyB64,
        accountPublicKeyB64
      }) => ({
        address: l.from(accountAddress),
        publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)
      })
    );
  }
  onDisconnect(listener) {
    this.onDisconnectListeners.add(listener);
    return () => this.onDisconnectListeners.delete(listener);
  }
};
var ACDappClient = class {
  constructor({
    backendBaseURL,
    dappId,
    dappImageURI,
    dappName,
    defaultNetworkName = NetworkName.MAINNET,
    frontendBaseURL = DEFAULT_FRONTEND_URL,
    provider = "google",
    tgWebAppURL
  } = {}) {
    this.dappInfo = {
      domain: window.location.origin,
      imageURI: dappImageURI,
      name: dappName ?? document.title
    };
    this.transport = new WebWalletTransport(
      frontendBaseURL,
      provider,
      tgWebAppURL
    );
    this.dappId = dappId;
    this.pairingClient = new ACPairingClient({
      axiosConfig: {
        baseURL: backendBaseURL ?? frontendBaseURL
      },
      defaultNetworkName
    });
  }
  // region Public API
  async getKeylessAccounts() {
    const serializedRequest = GetConnectedAccountsRequest.serialize(
      this.dappInfo
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);
    return response.args;
  }
  async getIcAccounts() {
    return await this.pairingClient.getConnectedAccounts() ?? [];
  }
  async isIcAccount(address) {
    const icAccounts = await this.getIcAccounts();
    return icAccounts.find(
      (account) => account.address.equals(l.from(address))
    ) !== void 0;
  }
  async getConnectedAccounts() {
    const keylessAccounts = await this.getKeylessAccounts();
    const icAccounts = await this.getIcAccounts();
    return [...keylessAccounts, ...icAccounts];
  }
  async disconnect(address) {
    if (await this.isIcAccount(address)) {
      const stringAddress = l.from(address).toString();
      await this.pairingClient.disconnect(stringAddress);
    } else {
      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);
      await this.transport.sendRequest(serializedRequest);
    }
  }
  async connect({
    claimOptions,
    preferredWalletName
  } = {}) {
    const dappKeypair = createEd25519KeyPair();
    const injectedPreferredWalletName = typeof window !== "undefined" ? window.AC_PREFERRED_WALLET_NAME : void 0;
    const requestArgs = {
      claimOptions,
      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),
      dappId: this.dappId,
      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName
    };
    const serializedRequest = ConnectRequest.serialize(
      this.dappInfo,
      requestArgs
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = ConnectResponse.deserialize(serializedResponse);
    if (response.args.status === "approved") {
      const { account, pairing } = response.args.args;
      if (pairing) {
        await this.pairingClient.addPairing(dappKeypair, pairing);
      }
      return makeUserApproval({ account });
    }
    return response.args;
  }
  async signIn(args) {
    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignInResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signMessage(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { chainId } = args;
      const network = chainIdToNetwork(chainId);
      let message;
      let nonce;
      try {
        message = new TextDecoder().decode(args.message);
        nonce = new TextDecoder().decode(args.nonce);
      } catch (_err) {
        throw new Error("Only UTF-8 encoded text is supported when using IC");
      }
      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(
        signerAddress.toString(),
        {
          address: true,
          application: true,
          chainId: true,
          message,
          nonce
        },
        { networkName: network }
      );
      const signatureBytes = a.fromHexInput(hexSignature).toUint8Array();
      const signature = signatureBytes.length === v.LENGTH ? new v(signatureBytes) : O.deserialize(new a2(signatureBytes));
      return makeUserApproval({
        fullMessage,
        signature
      });
    }
    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignMessageResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signTransaction(args) {
    const normalizedArgs = "transaction" in args ? SignTransactionRequest.normalizeArgs(args) : args;
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationSecondsFromNow,
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network,
        payload,
        secondarySigners,
        sender,
        sequenceNumber
      } = normalizedArgs;
      if (feePayer !== void 0) {
        throw new Error("Sponsored transaction not currently supported");
      }
      if (secondarySigners && secondarySigners.length > 0) {
        throw new Error("Multi-agent transactions not currently supported");
      }
      if (!("bcsToBytes" in payload)) {
        throw new Error(
          "Payload input format is only supported with Keyless accounts."
        );
      }
      const responseArgs = await this.pairingClient.signTransaction(
        signerAddress.toString(),
        {
          options: {
            expirationSecondsFromNow,
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount,
            sender: sender == null ? void 0 : sender.address.toString(),
            sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0
          },
          payload
        },
        {
          networkName: network
        }
      );
      return makeUserApproval({
        authenticator: responseArgs.accountAuthenticator,
        rawTransaction: responseArgs.rawTxn
      });
    }
    const serializedRequest = SignTransactionRequest.serialize(
      this.dappInfo,
      normalizedArgs
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signAndSubmitTransaction(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network
      } = args;
      if (network === shelbynet.name) {
        throw new Error("Shelbynet not supported");
      }
      const aptosConfig = new a3({ network });
      let convertedArgs;
      if (feePayer !== void 0) {
        const payload = await normalizePayloadForIC(args.payload, aptosConfig);
        const rawTxn = await mc({
          aptosConfig,
          feePayerAddress: feePayer.address,
          options: {
            gasUnitPrice,
            maxGasAmount
          },
          payload,
          sender: signerAddress
        });
        convertedArgs = {
          feePayerAuthenticator: feePayer.authenticator,
          rawTxn: new Kt(rawTxn, [], feePayer.address)
        };
      } else {
        const payload = normalizePayloadForIC(args.payload);
        convertedArgs = {
          options: {
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount
          },
          payload
        };
      }
      const { hash } = await this.pairingClient.signAndSubmitTransaction(
        signerAddress.toString(),
        convertedArgs,
        {
          networkName: network
        }
      );
      return makeUserApproval({
        txnHash: hash
      });
    }
    const serializedRequest = SignAndSubmitTransactionRequest.serialize(
      this.dappInfo,
      args
    );
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  // endregion
};

// node_modules/@aptos-connect/wallet-adapter-plugin/dist/index.mjs
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _address;
var _publicKey;
var AptosConnectAccount = class {
  constructor({ address, ansName, publicKey }) {
    this.chains = e8;
    this.features = [];
    __privateAdd(this, _address, void 0);
    __privateAdd(this, _publicKey, void 0);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _address, address);
    this.label = ansName;
  }
  get address() {
    return __privateGet(this, _address).toString();
  }
  get publicKey() {
    return __privateGet(this, _publicKey).toUint8Array();
  }
  get signingScheme() {
    if (__privateGet(this, _publicKey) instanceof b) {
      return W.Ed25519;
    }
    if (__privateGet(this, _publicKey) instanceof Y) {
      return W.MultiEd25519;
    }
    if (__privateGet(this, _publicKey) instanceof I) {
      return W.SingleKey;
    }
    if (__privateGet(this, _publicKey) instanceof G) {
      return W.MultiKey;
    }
    throw new Error("Unsupported public key type");
  }
  // endregion
};
_address = /* @__PURE__ */ new WeakMap();
_publicKey = /* @__PURE__ */ new WeakMap();
function customAccountToStandardAccount({
  address,
  name,
  publicKey
}) {
  return new d3({
    address,
    ansName: name,
    publicKey
  });
}
function unwrapUserResponse(response, callback) {
  if (response.status === "dismissed") {
    return { status: r4.REJECTED };
  }
  return { args: callback(response.args), status: r4.APPROVED };
}
function networkToChainId(network) {
  switch (network) {
    case e.MAINNET:
      return l2.mainnet;
    case e.TESTNET:
      return l2.testnet;
    default:
      return void 0;
  }
}
var _AptosConnectWallet = class _AptosConnectWallet2 {
  constructor({
    aptosClientConfig,
    claimSecretKey,
    network = e.MAINNET,
    preferredWalletName,
    ...clientConfig
  }) {
    this.version = "1.0.0";
    this.chains = e8;
    this.client = new ACDappClient(clientConfig);
    if (!p[network] && network !== shelbynet.name) {
      throw new Error("Network not supported");
    }
    this.network = network;
    const aptosSettings = network !== shelbynet.name ? { network } : {
      fullnode: shelbynet.nodeUrl,
      indexer: shelbynet.indexerUrl,
      network: e.CUSTOM
    };
    const aptosConfig = new a3({
      ...aptosSettings,
      ...aptosClientConfig
    });
    this.aptosClient = new ee(aptosConfig);
    this.preferredWalletName = preferredWalletName;
    if (claimSecretKey) {
      if (network === shelbynet.name) {
        throw new Error("Shelbynet not supported");
      }
      this.claimOptions = {
        network,
        secretKey: new L(claimSecretKey)
      };
    }
    this.chainIdPromise = this.aptosClient.getChainId();
    this.chainIdPromise.then((chainId) => {
      this.chainId = chainId;
    });
  }
  static get connectedAccount() {
    const serialized = localStorage.getItem(
      _AptosConnectWallet2.connectedAccountStorageKey
    );
    if (!serialized) {
      return void 0;
    }
    try {
      const { address, publicKey } = JSON.parse(
        serialized
      );
      return new d3({
        address: l.from(address),
        publicKey: deserializePublicKeyB64(publicKey)
      });
    } catch (_err) {
      this.connectedAccount = void 0;
      return void 0;
    }
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      const serialized = {
        address: value.address.toString(),
        publicKey: serializePublicKeyB64(value.publicKey)
      };
      localStorage.setItem(
        _AptosConnectWallet2.connectedAccountStorageKey,
        JSON.stringify(serialized)
      );
    } else {
      localStorage.removeItem(_AptosConnectWallet2.connectedAccountStorageKey);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount } = _AptosConnectWallet2;
    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];
  }
  async connect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount !== void 0) {
      return { args: connectedAccount, status: r4.APPROVED };
    }
    const response = await this.client.connect({
      claimOptions: this.claimOptions,
      preferredWalletName: this.preferredWalletName
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const newConnectedAccount = customAccountToStandardAccount(
      response.args.account
    );
    _AptosConnectWallet2.connectedAccount = newConnectedAccount;
    return {
      args: newConnectedAccount,
      status: r4.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWallet2.connectedAccount = void 0;
    }
  }
  async signIn(input) {
    const response = await this.client.signIn({
      network: this.network,
      ...input
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const output = response.args;
    _AptosConnectWallet2.connectedAccount = output.account;
    return { args: output, status: r4.APPROVED };
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s2(a5.Unauthorized);
    }
    return customAccountToStandardAccount(connectedAccount);
  }
  async getNetwork() {
    const chainId = await this.chainIdPromise;
    const isShelbynet = this.network === shelbynet.name;
    return {
      chainId,
      name: isShelbynet ? e.CUSTOM : this.network,
      url: isShelbynet ? shelbynet.nodeUrl : p[this.network]
    };
  }
  async signMessage(input) {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s2(a5.Unauthorized);
    }
    const chainId = networkToChainId(this.network) ?? this.chainId ?? await this.chainIdPromise;
    const { message, nonce } = input;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const { fullMessage, signature } = response.args;
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: this.client.dappInfo.domain,
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage,
        signature,
        ...extraResponseArgs
      },
      status: r4.APPROVED
    };
  }
  async signTransaction(txnOrArgs, _asFeePayer) {
    var _a;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s2(a5.Unauthorized);
    }
    if ("bcsToBytes" in txnOrArgs) {
      const transaction = txnOrArgs;
      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
      const secondarySigners = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map(
        (address) => ({ address })
      );
      const response2 = await this.client.signTransaction({
        feePayer,
        network: this.network,
        secondarySigners,
        signerAddress: connectedAccount.address,
        transaction: transaction.rawTransaction
      });
      return unwrapUserResponse(response2, (args) => args.authenticator);
    }
    const requestArgs = txnOrArgs;
    const response = await this.client.signTransaction({
      network: this.network,
      ...requestArgs,
      signerAddress: connectedAccount.address
    });
    return unwrapUserResponse(response, (responseArgs) => {
      var _a2, _b;
      const { authenticator, rawTransaction } = responseArgs;
      if (!rawTransaction) {
        throw new Error("Expected raw transaction in response args");
      }
      const secondarySigners = requestArgs.secondarySigners ?? [];
      let transaction;
      if (secondarySigners.length > 0) {
        transaction = new yr(
          rawTransaction,
          secondarySigners.map((s4) => s4.address),
          (_a2 = requestArgs.feePayer) == null ? void 0 : _a2.address
        );
      } else {
        transaction = new gr(
          rawTransaction,
          (_b = requestArgs.feePayer) == null ? void 0 : _b.address
        );
      }
      return {
        authenticator,
        rawTransaction: transaction
      };
    });
  }
  async signAndSubmitTransaction(args) {
    const { gasUnitPrice, maxGasAmount, payload } = args;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s2(a5.Unauthorized);
    }
    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,
      maxGasAmount,
      network: this.network,
      payload,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    return {
      args: { hash: response.args.txnHash },
      status: r4.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // endregion
};
_AptosConnectWallet.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var AptosConnectWallet = _AptosConnectWallet;
var walletMetadata = {
  apple: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxzdHlsZT4KICAgICAgICBwYXRoIHsKICAgICAgICAgICAgZmlsbDogYmxhY2s7CiAgICAgICAgfQoKICAgICAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgICAgICAgIHBhdGggewogICAgICAgICAgICAgICAgZmlsbDogd2hpdGU7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICA8L3N0eWxlPgogICAgPHBhdGgKICAgICAgICBkPSJNMjAuMzkzMiA4LjE4MjQyQzIwLjI1NzggOC4yOTA0MyAxNy44NjggOS42NzUzNyAxNy44NjggMTIuNzU0OUMxNy44NjggMTYuMzE2OCAyMC45MDkgMTcuNTc3IDIxIDE3LjYwODJDMjAuOTg2IDE3LjY4NSAyMC41MTY5IDE5LjMzMzkgMTkuMzk2NiAyMS4wMTQxQzE4LjM5NzcgMjIuNDkyNiAxNy4zNTQ1IDIzLjk2ODggMTUuNzY3NSAyMy45Njg4QzE0LjE4MDQgMjMuOTY4OCAxMy43NzIgMjMuMDIwNyAxMS45Mzk5IDIzLjAyMDdDMTAuMTU0NSAyMy4wMjA3IDkuNTE5NzIgMjQgOC4wNjgwNSAyNEM2LjYxNjM5IDI0IDUuNjAzNDkgMjIuNjMxOSA0LjQzODg5IDIwLjk1MTdDMy4wODk5MiAxOC45Nzg3IDIgMTUuOTEzNiAyIDEzLjAwNDVDMiA4LjMzODQzIDQuOTUwMDEgNS44NjM3OSA3Ljg1MzM0IDUuODYzNzlDOS4zOTYwMiA1Ljg2Mzc5IDEwLjY4MiA2LjkwNTQ5IDExLjY1MDUgNi45MDU0OUMxMi41NzI0IDYuOTA1NDkgMTQuMDEwMSA1LjgwMTM4IDE1Ljc2NTEgNS44MDEzOEMxNi40MzAzIDUuODAxMzggMTguODIwMiA1Ljg2Mzc5IDIwLjM5MzIgOC4xODI0MlpNMTQuOTMxOSAzLjgyNTk4QzE1LjY1NzggMi45NDAyOSAxNi4xNzEyIDEuNzExMzcgMTYuMTcxMiAwLjQ4MjQ0OEMxNi4xNzEyIDAuMzEyMDMxIDE2LjE1NzIgMC4xMzkyMTQgMTYuMTI2OSAwQzE0Ljk0NiAwLjA0NTYwNDYgMTMuNTQxIDAuODA4ODgxIDEyLjY5MzggMS44MTkzOEMxMi4wMjg2IDIuNTk3MDYgMTEuNDA3OCAzLjgyNTk4IDExLjQwNzggNS4wNzE3MUMxMS40MDc4IDUuMjU4OTMgMTEuNDM4MiA1LjQ0NjE0IDExLjQ1MjIgNS41MDYxNUMxMS41MjY4IDUuNTIwNTUgMTEuNjQ4MiA1LjUzNzM1IDExLjc2OTYgNS41MzczNUMxMi44MjkxIDUuNTM3MzUgMTQuMTYxOCA0LjgwNzY4IDE0LjkzMTkgMy44MjU5OFoiIC8+Cjwvc3ZnPg=="
    ),
    name: "Continue with Apple",
    url: "https://web.petra.app"
  },
  generic: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAeMSURBVHgB7Z09bFNXFMfPtQKVUgZXAomJGokFFlK1Iw1mKkyFlqENVKRTOyARNqRWIkhU6ghSl051pZZ26EeYyoZBjK1wF7og1emEVIYMEKkBcnv+tl9iHMf2s9+979x3z0+K7Dh2JL///3zcj/eeoQyYr9ryGtFJQ3TYWqrwSzP8vGz5h5SsaPIxbZKhxjrRnVeIGrW6adKEGBoTiP6MH8jSuyx0lZQ8aLCC13cS1cc1Q2oDtKJ9nS4YQwsa4XJgIWs7DF1Ja4RUBpibtZdVeOFYWrxx11wZ9e0jGYCjvrJm6Vd+OkNKCDR3Gjo2SjYoDXvDmVl77pml+6TihwQC9v6HVXty2BsHGgAp3xqqacoPkrLhrA0NB71p2xLQ+qChRVLCZ0Bf0NcASB2mXfOVgsB6zn9/13y75fXeF9DwoeZr2i8cK9wYvtHbGG7pAbh5uK3iF5LyWp+s/pIBOg1DhZSiMjNXtYvdL2yUgM5Y/29Sig5KwX4uBSv4ZSMD8Lz+ZVJiAAt3C8kvrQyg0R8dG1mglQHWdDUvNsr/YSWXOiWAx4gXSImKEi/j49Fo+o8XLgOvlZ7rIk+0YBdXaV3rf8zMlLj+HyYlVipTvNxb4dWiaNm9l+jVXUTT/LNn79a///to8/HxIyoWHPxTZOOY+oXI+w4Qvd71A8EhfBqWH7aN8KDRfv5Xg0KmbOaO2sLG/0Fubw/NtB8POmp1V58Q/X6vbYS7tyg4CmeARPTjp9NH96QkZviltlk6pFMYA7x5hOjEaXeRnhZkhJ9r8ktE0AZAXUekv328fwMnAZQFyRkhWAPMsujvzcsVvheYABlBGsEZACn+/Xk5qT4NyAJfLMjKBsEYAOkeEY+UHzrffUX0208kgikKAIzZL14NJ90P4+z59ghFQkkQbwBE/EfnqXAgm8HYX39J9PQJ5cbQU8PyAin/00vFFD8BQ9fPrrW/a16INABSPQ4MhndFB1kA3zUvxBkgER8HJhbwXT+5RLkgygCJ+EVp9tKAeQ0Mb30jxgAxi5+AxvCtI+QVEQZQ8TdBKfB5HHI3ADrgIo3xJwXzAz77gdwNkIyHlU0wzX3C04xnrgZA01OEqV0XIDB8zA/kZgCkfHxJpT/Tu/wcn1wMAGfnOfkRCsiOrnujXAwQ0jp+3rjOAt4NAOG17o8O5gVc9gLeDaCpPx3oBd5xGDBeDTAreO+eZE4UxQDa9Y8HsoCrLXDeDKDRPxmu1gi8GUCjfzJmHe2N8GIAjf7JcVUGvOwJ9BX9ODWr+ZBEUjkw+alqWDPJ+kwj5waAa31FP87LwyZLaSADHspghQ/nPN7KeDu58xIwG8G+vkFkud1rn4NVU+cGCPEMnqyA+J9nOPG1Z2/2s4JODeAz/UsjET/rU9R3Z3w8nRog1vTvSnyQdRlwaoB9Ee70cSk+CKYEIPVXIjOAa/HBdCgGiC36fYjvAmcGiKn7D1V84MwAsaT/kMUHzgwQw1bv0MUHTgwwvSvsgzIKRRAfODFA0Sd/8hQ/6+sLOcsARSXvyH8cggGKmgEkpP3VjC8noxlgRKSIv5zxfgc1wAhIafhcbHYRe5EoKUjq9v9RA/hF2lAPO56yRg2wDRLH+ZoBPCFR/D/uubmgpBqgB6kzfC7SP1ADdCFVfEz+uLodjRqgg+S5/QcO7zqiBiD5Czu42YQrojeAdPGR+l3eYCJqA4SwpOsy+kG0BghBfNfRD6I0QAjio/N3Hf0gOgOEspMHt5PxcXOp6AyAJdXVHG/RMgpI/b5uQxudARBVVxfk3gncV+pPiLIHkGoCZKarnu8rGO0oQKIJfNX9bqKeB5BkAoif9dU/RiH6mUAJJoD4Put+N7oWQPmaIE/xgRqgQx4myFt8oAbowqcJJIgP1AA9+DCBFPGBGqAPLk0gSXygBtgGFyaQJj5QAwwgSxNIFB+oAYaQhQmkig/UACMwiQkkiw/UACMyjgmkiw/UAClIY4IQxAdqgJSMYoJQxAdqgDEYZIKQxAdqgDHpZ4LQxAdm7qi1lDHYeJnHdQIhSta3VBkGroeETaZ3boUnPnBigNjAFbyfCt9ouh1aAjIgVPFByRCtkBItJWvUABHTRAnw3DYpUjCmbYBlUqKEu/8/NQNEDItfL+0kWiIlSp5z8JdqdbPCI4E6KVHBmjd+rJtmqfPbTVKigkd/1/HYMsAOoprOB8TFeifrtwyAMpA4QomCGtI/nmxMBXMzeE2zQBysG7qSPN8wgGaBSGDxk+hv/9rDmaP2Pk8QzJBSRJo37pj93S9sWQ18YeiUloLiAU059R/rfX2LAZAeuBRcJKVQsPgfd6f+hL77AW7UTY26GgUlcFjLH+pmqf+fBjBXtYu8YnCZlHBh8TmgF7f/8xDOVu1Ja+kbbgzLpAQDaj5KeSubD37fcD6o2krJ0m1+WiElBBpc80/1q/m9jGSABC0JsulE/fVBKb/PZ9KBbMAfWjSWzpEigkT4VZ7NXeIJvZSfHY9WWSCq8j+4wD2CThzlgDGtBZ2bT3kiN63wG/+DMgBmmOLZwxdsCDbFYYtewWq/kBWdCIfADT62y1jL52hfGlf0bv4H4emQh2jTz1sAAAAASUVORK5CYII="
    ),
    name: "Petra Web",
    url: "https://web.petra.app"
  },
  google: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
    ),
    name: "Continue with Google",
    url: "https://web.petra.app"
  }
};
var AptosConnectAppleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "apple" });
    this.name = walletMetadata.apple.name;
    this.icon = walletMetadata.apple.icon;
    this.url = walletMetadata.apple.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o4]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o5]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n10]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n8]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1.0"
      }
    };
  }
  // endregion
};
var AptosConnectGenericWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "generic" });
    this.name = walletMetadata.generic.name;
    this.icon = walletMetadata.generic.icon;
    this.url = walletMetadata.generic.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o4]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o5]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n10]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n8]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1.0"
      }
    };
  }
  // endregion
};
var AptosConnectGoogleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "google" });
    this.name = walletMetadata.google.name;
    this.icon = walletMetadata.google.icon;
    this.url = walletMetadata.google.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o4]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o5]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n10]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e7]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n8]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e6]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n9]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1.0"
      }
    };
  }
  // endregion
};

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++) arr2[i4] = arr[i4];
  return arr2;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _async_to_generator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _call_super(_this, derived, args) {
  derived = _get_prototype_of(derived);
  return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _construct(Parent, args, Class) {
  if (_is_native_reflect_construct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function construct(Parent2, args2, Class2) {
      var a9 = [
        null
      ];
      a9.push.apply(a9, args2);
      var Constructor = Function.bind.apply(Parent2, a9);
      var instance = new Constructor();
      if (Class2) _set_prototype_of(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
  for (var i4 = 0; i4 < props.length; i4++) {
    var descriptor = props[i4];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _get_prototype_of(o12) {
  _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf2(o13) {
    return o13.__proto__ || Object.getPrototypeOf(o13);
  };
  return _get_prototype_of(o12);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _set_prototype_of(subClass, superClass);
}
function _is_native_function(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _iterable_to_array(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  source = source != null ? source : {};
  if (Object.getOwnPropertyDescriptors) {
    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
  } else {
    ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _possible_constructor_return(self2, call) {
  if (call && (_type_of(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assert_this_initialized(self2);
}
function _set_prototype_of(o12, p6) {
  _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o13, p7) {
    o13.__proto__ = p7;
    return o13;
  };
  return _set_prototype_of(o12, p6);
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o12, minLen) {
  if (!o12) return;
  if (typeof o12 === "string") return _array_like_to_array(o12, minLen);
  var n16 = Object.prototype.toString.call(o12).slice(8, -1);
  if (n16 === "Object" && o12.constructor) n16 = o12.constructor.name;
  if (n16 === "Map" || n16 === "Set") return Array.from(n16);
  if (n16 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n16)) return _array_like_to_array(o12, minLen);
}
function _wrap_native_super(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrap_native_super = function wrapNativeSuper(Class2) {
    if (Class2 === null || !_is_native_function(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _get_prototype_of(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _set_prototype_of(Wrapper, Class2);
  };
  return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
  try {
    var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (_3) {
  }
  return (_is_native_reflect_construct = function() {
    return !!result;
  })();
}
function _ts_generator(thisArg, body) {
  var f6, y2, t11, g2, _3 = {
    label: 0,
    sent: function() {
      if (t11[0] & 1) throw t11[1];
      return t11[1];
    },
    trys: [],
    ops: []
  };
  return g2 = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n16) {
    return function(v6) {
      return step([
        n16,
        v6
      ]);
    };
  }
  function step(op) {
    if (f6) throw new TypeError("Generator is already executing.");
    while (_3) try {
      if (f6 = 1, y2 && (t11 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t11 = y2["return"]) && t11.call(y2), 0) : y2.next) && !(t11 = t11.call(y2, op[1])).done) return t11;
      if (y2 = 0, t11) op = [
        op[0] & 2,
        t11.value
      ];
      switch (op[0]) {
        case 0:
        case 1:
          t11 = op;
          break;
        case 4:
          _3.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _3.label++;
          y2 = op[1];
          op = [
            0
          ];
          continue;
        case 7:
          op = _3.ops.pop();
          _3.trys.pop();
          continue;
        default:
          if (!(t11 = _3.trys, t11 = t11.length > 0 && t11[t11.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _3 = 0;
            continue;
          }
          if (op[0] === 3 && (!t11 || op[1] > t11[0] && op[1] < t11[3])) {
            _3.label = op[1];
            break;
          }
          if (op[0] === 6 && _3.label < t11[1]) {
            _3.label = t11[1];
            t11 = op;
            break;
          }
          if (t11 && _3.label < t11[2]) {
            _3.label = t11[2];
            _3.ops.push(op);
            break;
          }
          if (t11[2]) _3.ops.pop();
          _3.trys.pop();
          continue;
      }
      op = body.call(thisArg, _3);
    } catch (e14) {
      op = [
        6,
        e14
      ];
      y2 = 0;
    } finally {
      f6 = t11 = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var WALLET_ADAPTER_CORE_VERSION = "8.2.0";
var GA4 = function() {
  "use strict";
  function GA42() {
    _class_call_check(this, GA42);
    this.aptosGAID = "G-GNVVWBL3J9";
    this.injectGA(this.aptosGAID);
  }
  _create_class(GA42, [
    {
      key: "gtag",
      value: function gtag(a9, b4, c3) {
        var dataLayer = window.dataLayer || [];
        dataLayer.push(arguments);
      }
    },
    {
      key: "injectGA",
      value: function injectGA(gaID) {
        if (typeof window === "undefined") return;
        if (!gaID) return;
        var head = document.getElementsByTagName("head")[0];
        var myScript = document.createElement("script");
        myScript.setAttribute("src", "https://www.googletagmanager.com/gtag/js?id=".concat(gaID));
        var that = this;
        myScript.onload = function() {
          that.gtag("js", /* @__PURE__ */ new Date());
          that.gtag("config", "".concat(gaID), {
            send_page_view: false
          });
        };
        head.insertBefore(myScript, head.children[1]);
      }
    }
  ]);
  return GA42;
}();
var WalletError = function(Error1) {
  "use strict";
  _inherits(WalletError2, Error1);
  function WalletError2(message, error) {
    _class_call_check(this, WalletError2);
    var _this;
    _this = _call_super(this, WalletError2, [
      message
    ]);
    _this.error = error;
    return _this;
  }
  return WalletError2;
}(_wrap_native_super(Error));
var WalletNotSelectedError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotSelectedError2, WalletError2);
  function WalletNotSelectedError2() {
    _class_call_check(this, WalletNotSelectedError2);
    var _this;
    _this = _call_super(this, WalletNotSelectedError2, arguments);
    _this.name = "WalletNotSelectedError";
    return _this;
  }
  return WalletNotSelectedError2;
}(WalletError);
var WalletNotReadyError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotReadyError2, WalletError2);
  function WalletNotReadyError2() {
    _class_call_check(this, WalletNotReadyError2);
    var _this;
    _this = _call_super(this, WalletNotReadyError2, arguments);
    _this.name = "WalletNotReadyError";
    return _this;
  }
  return WalletNotReadyError2;
}(WalletError);
var WalletConnectionError = function(WalletError2) {
  "use strict";
  _inherits(WalletConnectionError2, WalletError2);
  function WalletConnectionError2() {
    _class_call_check(this, WalletConnectionError2);
    var _this;
    _this = _call_super(this, WalletConnectionError2, arguments);
    _this.name = "WalletConnectionError";
    return _this;
  }
  return WalletConnectionError2;
}(WalletError);
var WalletDisconnectionError = function(WalletError2) {
  "use strict";
  _inherits(WalletDisconnectionError2, WalletError2);
  function WalletDisconnectionError2() {
    _class_call_check(this, WalletDisconnectionError2);
    var _this;
    _this = _call_super(this, WalletDisconnectionError2, arguments);
    _this.name = "WalletDisconnectionError";
    return _this;
  }
  return WalletDisconnectionError2;
}(WalletError);
var WalletAccountError = function(WalletError2) {
  "use strict";
  _inherits(WalletAccountError2, WalletError2);
  function WalletAccountError2() {
    _class_call_check(this, WalletAccountError2);
    var _this;
    _this = _call_super(this, WalletAccountError2, arguments);
    _this.name = "WalletAccountError";
    return _this;
  }
  return WalletAccountError2;
}(WalletError);
var WalletGetNetworkError = function(WalletError2) {
  "use strict";
  _inherits(WalletGetNetworkError2, WalletError2);
  function WalletGetNetworkError2() {
    _class_call_check(this, WalletGetNetworkError2);
    var _this;
    _this = _call_super(this, WalletGetNetworkError2, arguments);
    _this.name = "WalletGetNetworkError";
    return _this;
  }
  return WalletGetNetworkError2;
}(WalletError);
var WalletAccountChangeError = function(WalletError2) {
  "use strict";
  _inherits(WalletAccountChangeError2, WalletError2);
  function WalletAccountChangeError2() {
    _class_call_check(this, WalletAccountChangeError2);
    var _this;
    _this = _call_super(this, WalletAccountChangeError2, arguments);
    _this.name = "WalletAccountChangeError";
    return _this;
  }
  return WalletAccountChangeError2;
}(WalletError);
var WalletNetworkChangeError = function(WalletError2) {
  "use strict";
  _inherits(WalletNetworkChangeError2, WalletError2);
  function WalletNetworkChangeError2() {
    _class_call_check(this, WalletNetworkChangeError2);
    var _this;
    _this = _call_super(this, WalletNetworkChangeError2, arguments);
    _this.name = "WalletNetworkChangeError";
    return _this;
  }
  return WalletNetworkChangeError2;
}(WalletError);
var WalletNotConnectedError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotConnectedError2, WalletError2);
  function WalletNotConnectedError2() {
    _class_call_check(this, WalletNotConnectedError2);
    var _this;
    _this = _call_super(this, WalletNotConnectedError2, arguments);
    _this.name = "WalletNotConnectedError";
    return _this;
  }
  return WalletNotConnectedError2;
}(WalletError);
var WalletSignMessageError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignMessageError2, WalletError2);
  function WalletSignMessageError2() {
    _class_call_check(this, WalletSignMessageError2);
    var _this;
    _this = _call_super(this, WalletSignMessageError2, arguments);
    _this.name = "WalletSignMessageError";
    return _this;
  }
  return WalletSignMessageError2;
}(WalletError);
var WalletSignMessageAndVerifyError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignMessageAndVerifyError2, WalletError2);
  function WalletSignMessageAndVerifyError2() {
    _class_call_check(this, WalletSignMessageAndVerifyError2);
    var _this;
    _this = _call_super(this, WalletSignMessageAndVerifyError2, arguments);
    _this.name = "WalletSignMessageAndVerifyError";
    return _this;
  }
  return WalletSignMessageAndVerifyError2;
}(WalletError);
var WalletSignAndSubmitMessageError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignAndSubmitMessageError2, WalletError2);
  function WalletSignAndSubmitMessageError2() {
    _class_call_check(this, WalletSignAndSubmitMessageError2);
    var _this;
    _this = _call_super(this, WalletSignAndSubmitMessageError2, arguments);
    _this.name = "WalletSignAndSubmitMessageError";
    return _this;
  }
  return WalletSignAndSubmitMessageError2;
}(WalletError);
var WalletSignTransactionError = function(WalletError2) {
  "use strict";
  _inherits(WalletSignTransactionError2, WalletError2);
  function WalletSignTransactionError2() {
    _class_call_check(this, WalletSignTransactionError2);
    var _this;
    _this = _call_super(this, WalletSignTransactionError2, arguments);
    _this.name = "WalletSignTransactionError";
    return _this;
  }
  return WalletSignTransactionError2;
}(WalletError);
var WalletNotSupportedMethod = function(WalletError2) {
  "use strict";
  _inherits(WalletNotSupportedMethod2, WalletError2);
  function WalletNotSupportedMethod2() {
    _class_call_check(this, WalletNotSupportedMethod2);
    var _this;
    _this = _call_super(this, WalletNotSupportedMethod2, arguments);
    _this.name = "WalletNotSupportedMethod";
    return _this;
  }
  return WalletNotSupportedMethod2;
}(WalletError);
var WalletChangeNetworkError = function(WalletError2) {
  "use strict";
  _inherits(WalletChangeNetworkError2, WalletError2);
  function WalletChangeNetworkError2() {
    _class_call_check(this, WalletChangeNetworkError2);
    var _this;
    _this = _call_super(this, WalletChangeNetworkError2, arguments);
    _this.name = "WalletChangeNetworkError";
    return _this;
  }
  return WalletChangeNetworkError2;
}(WalletError);
var WalletSubmitTransactionError = function(WalletError2) {
  "use strict";
  _inherits(WalletSubmitTransactionError2, WalletError2);
  function WalletSubmitTransactionError2() {
    _class_call_check(this, WalletSubmitTransactionError2);
    var _this;
    _this = _call_super(this, WalletSubmitTransactionError2, arguments);
    _this.name = "WalletSubmitTransactionError";
    return _this;
  }
  return WalletSubmitTransactionError2;
}(WalletError);
var WalletNotFoundError = function(WalletError2) {
  "use strict";
  _inherits(WalletNotFoundError2, WalletError2);
  function WalletNotFoundError2() {
    _class_call_check(this, WalletNotFoundError2);
    var _this;
    _this = _call_super(this, WalletNotFoundError2, arguments);
    _this.name = "WalletNotFoundError";
    return _this;
  }
  return WalletNotFoundError2;
}(WalletError);
var WalletReadyState = function(WalletReadyState2) {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  return WalletReadyState2;
}(WalletReadyState || {});
var NetworkName2 = function(NetworkName22) {
  NetworkName22["Mainnet"] = "mainnet";
  NetworkName22["Testnet"] = "testnet";
  NetworkName22["Devnet"] = "devnet";
  return NetworkName22;
}(NetworkName2 || {});
var ChainIdToAnsSupportedNetworkMap = {
  "1": "mainnet",
  // mainnet
  "2": "testnet"
};
var APTOS_CONNECT_BASE_URL = "https://aptosconnect.app";
var PETRA_WEB_BASE_URL = "https://web.petra.app";
var PETRA_WEB_GENERIC_WALLET_NAME = "Petra Web";
var PETRA_WALLET_NAME = "Petra";
var DEFAULT_WALLET_CONNECTION_FALLBACKS = _define_property({}, PETRA_WALLET_NAME, PETRA_WEB_GENERIC_WALLET_NAME);
var APTOS_CONNECT_ACCOUNT_URL = "https://aptosconnect.app/dashboard/main-account";
var PETRA_WEB_ACCOUNT_URL = "https://web.petra.app/dashboard/main-account";
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(navigator.userAgent);
}
function isInAppBrowser() {
  var isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
  var isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(navigator.userAgent);
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator) return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return (typeof error === "undefined" ? "undefined" : _type_of(error)) === "object" && "message" in error ? error.message : error;
}
var getAptosConfig = function(networkInfo, dappConfig) {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  var pluginSettings = {
    TRANSACTION_SUBMITTER: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.transactionSubmitter
  };
  if (isAptosNetwork(networkInfo)) {
    var currentNetwork = convertNetwork(networkInfo);
    if (isAptosLiveNetwork(currentNetwork)) {
      var apiKey = dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosApiKeys;
      return new a3({
        network: currentNetwork,
        clientConfig: {
          API_KEY: apiKey ? apiKey[currentNetwork] : void 0
        },
        pluginSettings
      });
    }
    return new a3({
      network: currentNetwork,
      pluginSettings
    });
  }
  var knownNetworks = {
    okx: "https://wallet.okx.com/fullnode/aptos/discover/rpc"
  };
  if (networkInfo.url) {
    var isKnownNetwork = Object.values(knownNetworks).includes(networkInfo.url);
    if (isKnownNetwork) {
      return new a3({
        network: e.CUSTOM,
        fullnode: networkInfo.url,
        pluginSettings
      });
    }
  }
  throw new Error("Invalid network, network ".concat(networkInfo.name, " not supported with Aptos wallet adapter to prevent user from using an unexpected network."));
};
var isAptosNetwork = function(networkInfo) {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  return p[networkInfo.name] !== void 0;
};
var isAptosLiveNetwork = function(networkInfo) {
  return networkInfo === "devnet" || networkInfo === "testnet" || networkInfo === "mainnet";
};
var fetchDevnetChainId = function() {
  var _ref = _async_to_generator(function() {
    var aptos;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          aptos = new ee();
          return [
            4,
            aptos.getChainId()
          ];
        case 1:
          return [
            2,
            _state.sent()
          ];
      }
    });
  });
  return function fetchDevnetChainId2() {
    return _ref.apply(this, arguments);
  };
}();
var handlePublishPackageTransaction = function(transactionInput) {
  var metadataBytes = transactionInput.data.functionArguments[0];
  if (typeof metadataBytes === "string") {
    metadataBytes = a.fromHexInput(metadataBytes).toUint8Array();
  }
  var byteCode = transactionInput.data.functionArguments[1];
  if (Array.isArray(byteCode)) {
    byteCode = byteCode.map(function(byte) {
      if (typeof byte === "string") {
        return a.fromHexInput(byte).toUint8Array();
      }
      return byte;
    });
  } else {
    throw new WalletSignAndSubmitMessageError("The bytecode argument must be an array.").message;
  }
  return {
    metadataBytes,
    byteCode
  };
};
function convertNetwork(networkInfo) {
  switch (networkInfo === null || networkInfo === void 0 ? void 0 : networkInfo.name) {
    case "mainnet":
      return e.MAINNET;
    case "testnet":
      return e.TESTNET;
    case "devnet":
      return e.DEVNET;
    case "local":
      return e.LOCAL;
    case "shelbynet":
      return e.SHELBYNET;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
function partitionWallets(wallets2) {
  var partitionFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInstalledOrLoadable;
  var defaultWallets = [];
  var moreWallets = [];
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = wallets2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var wallet = _step.value;
      if (partitionFunction(wallet)) {
        defaultWallets.push(wallet);
      } else {
        moreWallets.push(wallet);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return {
    defaultWallets,
    moreWallets
  };
}
function isInstalledOrLoadable(wallet) {
  return wallet.readyState === "Installed";
}
function isInstallRequired(wallet) {
  var isWalletReady = isInstalledOrLoadable(wallet);
  var isMobile2 = !isWalletReady && isRedirectable();
  return !isMobile2 && !isWalletReady;
}
function shouldUseFallbackWallet(wallet) {
  return !!wallet.fallbackWallet && isInstallRequired(wallet) && isInstalledOrLoadable(wallet.fallbackWallet);
}
function truncateAddress(address) {
  if (!address) return;
  return "".concat(address.slice(0, 6), "...").concat(address.slice(-5));
}
function isAptosConnectWallet(wallet) {
  return isPetraWebWallet(wallet);
}
function isPetraWebWallet(wallet) {
  var ignoreGenericWallet = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (!wallet.url) return false;
  if (ignoreGenericWallet && isPetraWebGenericWallet(wallet)) {
    return false;
  }
  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL) || wallet.url.startsWith(PETRA_WEB_BASE_URL);
}
function isPetraWebGenericWallet(wallet) {
  return wallet.name === PETRA_WEB_GENERIC_WALLET_NAME;
}
function getAptosConnectWallets(wallets2) {
  var _partitionWallets = partitionWallets(wallets2, isAptosConnectWallet), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  return {
    aptosConnectWallets: defaultWallets,
    otherWallets: moreWallets
  };
}
function getPetraWebWallets(wallets2) {
  var _partitionWallets = partitionWallets(wallets2, isPetraWebWallet), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  return {
    petraWebWallets: defaultWallets,
    otherWallets: moreWallets
  };
}
function groupAndSortWallets(wallets2, options) {
  var _ref = options !== null && options !== void 0 ? options : {}, tmp = _ref.fallbacks, _ref1 = tmp === void 0 ? {} : tmp, fallbackConnections = _ref1.connections, additionalFallbackWallets = _ref1.additionalFallbackWallets;
  var aptosConnectWallets = getAptosConnectWallets(wallets2).aptosConnectWallets;
  var _getPetraWebWallets = getPetraWebWallets(wallets2), otherWallets = _getPetraWebWallets.otherWallets, petraWebWallets = _getPetraWebWallets.petraWebWallets;
  var _partitionWallets = partitionWallets(otherWallets), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  var availableWalletsWithFallbacks = [];
  if (fallbackConnections && Object.keys(fallbackConnections).length > 0) {
    var _loop = function(i5) {
      var wallet = moreWallets[i5];
      var fallbackName = fallbackConnections[wallet.name];
      if (fallbackName) {
        var fallbackWallet = _to_consumable_array(wallets2).concat(_to_consumable_array(additionalFallbackWallets !== null && additionalFallbackWallets !== void 0 ? additionalFallbackWallets : [])).find(function(w3) {
          return w3.name === fallbackName && isInstalledOrLoadable(w3);
        });
        if (fallbackWallet) {
          var walletWithFallback = _object_spread_props(_object_spread({}, wallet), {
            fallbackWallet
          });
          moreWallets.splice(i5, 1);
          availableWalletsWithFallbacks.push(walletWithFallback);
        }
      }
    };
    for (var i4 = moreWallets.length - 1; i4 >= 0; i4--) _loop(i4);
  }
  if (options === null || options === void 0 ? void 0 : options.sortAptosConnectWallets) {
    aptosConnectWallets.sort(options.sortAptosConnectWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortPetraWebWallets) {
    petraWebWallets.sort(options.sortPetraWebWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortAvailableWallets) {
    defaultWallets.sort(options.sortAvailableWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortInstallableWallets) {
    moreWallets.sort(options.sortInstallableWallets);
  }
  return {
    /** @deprecated Use {@link petraWebWallets} instead. */
    aptosConnectWallets,
    /** Wallets that use social login to create an account on the blockchain */
    petraWebWallets,
    /** Wallets that are currently installed or loadable. */
    availableWallets: defaultWallets,
    /** Wallets that are currently uninstalled that have a fallback wallet. */
    availableWalletsWithFallbacks,
    /** Wallets that are NOT currently installed or loadable. */
    installableWallets: moreWallets
  };
}
var aptosStandardSupportedWalletList = [
  {
    name: "OKX Wallet",
    url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAeMSURBVHgB7Z09bFNXFMfPtQKVUgZXAomJGokFFlK1Iw1mKkyFlqENVKRTOyARNqRWIkhU6ghSl051pZZ26EeYyoZBjK1wF7og1emEVIYMEKkBcnv+tl9iHMf2s9+979x3z0+K7Dh2JL///3zcj/eeoQyYr9ryGtFJQ3TYWqrwSzP8vGz5h5SsaPIxbZKhxjrRnVeIGrW6adKEGBoTiP6MH8jSuyx0lZQ8aLCC13cS1cc1Q2oDtKJ9nS4YQwsa4XJgIWs7DF1Ja4RUBpibtZdVeOFYWrxx11wZ9e0jGYCjvrJm6Vd+OkNKCDR3Gjo2SjYoDXvDmVl77pml+6TihwQC9v6HVXty2BsHGgAp3xqqacoPkrLhrA0NB71p2xLQ+qChRVLCZ0Bf0NcASB2mXfOVgsB6zn9/13y75fXeF9DwoeZr2i8cK9wYvtHbGG7pAbh5uK3iF5LyWp+s/pIBOg1DhZSiMjNXtYvdL2yUgM5Y/29Sig5KwX4uBSv4ZSMD8Lz+ZVJiAAt3C8kvrQyg0R8dG1mglQHWdDUvNsr/YSWXOiWAx4gXSImKEi/j49Fo+o8XLgOvlZ7rIk+0YBdXaV3rf8zMlLj+HyYlVipTvNxb4dWiaNm9l+jVXUTT/LNn79a///to8/HxIyoWHPxTZOOY+oXI+w4Qvd71A8EhfBqWH7aN8KDRfv5Xg0KmbOaO2sLG/0Fubw/NtB8POmp1V58Q/X6vbYS7tyg4CmeARPTjp9NH96QkZviltlk6pFMYA7x5hOjEaXeRnhZkhJ9r8ktE0AZAXUekv328fwMnAZQFyRkhWAPMsujvzcsVvheYABlBGsEZACn+/Xk5qT4NyAJfLMjKBsEYAOkeEY+UHzrffUX0208kgikKAIzZL14NJ90P4+z59ghFQkkQbwBE/EfnqXAgm8HYX39J9PQJ5cbQU8PyAin/00vFFD8BQ9fPrrW/a16INABSPQ4MhndFB1kA3zUvxBkgER8HJhbwXT+5RLkgygCJ+EVp9tKAeQ0Mb30jxgAxi5+AxvCtI+QVEQZQ8TdBKfB5HHI3ADrgIo3xJwXzAz77gdwNkIyHlU0wzX3C04xnrgZA01OEqV0XIDB8zA/kZgCkfHxJpT/Tu/wcn1wMAGfnOfkRCsiOrnujXAwQ0jp+3rjOAt4NAOG17o8O5gVc9gLeDaCpPx3oBd5xGDBeDTAreO+eZE4UxQDa9Y8HsoCrLXDeDKDRPxmu1gi8GUCjfzJmHe2N8GIAjf7JcVUGvOwJ9BX9ODWr+ZBEUjkw+alqWDPJ+kwj5waAa31FP87LwyZLaSADHspghQ/nPN7KeDu58xIwG8G+vkFkud1rn4NVU+cGCPEMnqyA+J9nOPG1Z2/2s4JODeAz/UsjET/rU9R3Z3w8nRog1vTvSnyQdRlwaoB9Ee70cSk+CKYEIPVXIjOAa/HBdCgGiC36fYjvAmcGiKn7D1V84MwAsaT/kMUHzgwQw1bv0MUHTgwwvSvsgzIKRRAfODFA0Sd/8hQ/6+sLOcsARSXvyH8cggGKmgEkpP3VjC8noxlgRKSIv5zxfgc1wAhIafhcbHYRe5EoKUjq9v9RA/hF2lAPO56yRg2wDRLH+ZoBPCFR/D/uubmgpBqgB6kzfC7SP1ADdCFVfEz+uLodjRqgg+S5/QcO7zqiBiD5Czu42YQrojeAdPGR+l3eYCJqA4SwpOsy+kG0BghBfNfRD6I0QAjio/N3Hf0gOgOEspMHt5PxcXOp6AyAJdXVHG/RMgpI/b5uQxudARBVVxfk3gncV+pPiLIHkGoCZKarnu8rGO0oQKIJfNX9bqKeB5BkAoif9dU/RiH6mUAJJoD4Put+N7oWQPmaIE/xgRqgQx4myFt8oAbowqcJJIgP1AA9+DCBFPGBGqAPLk0gSXygBtgGFyaQJj5QAwwgSxNIFB+oAYaQhQmkig/UACMwiQkkiw/UACMyjgmkiw/UAClIY4IQxAdqgJSMYoJQxAdqgDEYZIKQxAdqgDHpZ4LQxAdm7qi1lDHYeJnHdQIhSta3VBkGroeETaZ3boUnPnBigNjAFbyfCt9ouh1aAjIgVPFByRCtkBItJWvUABHTRAnw3DYpUjCmbYBlUqKEu/8/NQNEDItfL+0kWiIlSp5z8JdqdbPCI4E6KVHBmjd+rJtmqfPbTVKigkd/1/HYMsAOoprOB8TFeifrtwyAMpA4QomCGtI/nmxMBXMzeE2zQBysG7qSPN8wgGaBSGDxk+hv/9rDmaP2Pk8QzJBSRJo37pj93S9sWQ18YeiUloLiAU059R/rfX2LAZAeuBRcJKVQsPgfd6f+hL77AW7UTY26GgUlcFjLH+pmqf+fBjBXtYu8YnCZlHBh8TmgF7f/8xDOVu1Ja+kbbgzLpAQDaj5KeSubD37fcD6o2krJ0m1+WiElBBpc80/1q/m9jGSABC0JsulE/fVBKb/PZ9KBbMAfWjSWzpEigkT4VZ7NXeIJvZSfHY9WWSCq8j+4wD2CThzlgDGtBZ2bT3kiN63wG/+DMgBmmOLZwxdsCDbFYYtewWq/kBWdCIfADT62y1jL52hfGlf0bv4H4emQh2jTz1sAAAAASUVORK5CYII=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://petra.app/explore?link="
  },
  {
    name: "Nightly",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Pontem Wallet",
    url: "https://pontem.network/pontem-wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Backpack",
    url: "https://chromewebstore.google.com/detail/backpack/aflkmfhebedbjioipglgcbcmnbpgliof",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CjxyZWN0IHg9IjEwIiB3aWR0aD0iNDQiIGhlaWdodD0iNjQiIGZpbGw9InVybCgjcGF0dGVybjBfMTdfNCkiLz4KPGRlZnM+CjxwYXR0ZXJuIGlkPSJwYXR0ZXJuMF8xN180IiBwYXR0ZXJuQ29udGVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgd2lkdGg9IjEiIGhlaWdodD0iMSI+Cjx1c2UgeGxpbms6aHJlZj0iI2ltYWdlMF8xN180IiB0cmFuc2Zvcm09InNjYWxlKDAuMDE4MTgxOCAwLjAxMjUpIi8+CjwvcGF0dGVybj4KPGltYWdlIGlkPSJpbWFnZTBfMTdfNCIgd2lkdGg9IjU1IiBoZWlnaHQ9IjgwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQURjQUFBQlFDQVlBQUFDOUt1MmtBQUFBQ1hCSVdYTUFBQXNUQUFBTEV3RUFtcHdZQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBUWpTVVJCVkhnQjdadlJjZHRHRUliL1BkTFBvUjh6SThsVUJXWUY1TG1DT0JWWXFzQmhCWllyaUZPQjVRcXNWT0FqWFlDWkNrUmJtc2xqK0I0U20xMlFZaUNKU2tqY3dpSXc5ODF3UUkxQTRIN2NZZkh2M29GUUFaZmVkOXBBanhib3dmRnpCanBZZnRZdzA4UXh2bklMa3prd09RNWhCbU1JaGx4NTc2WFZiOEFpNm82WUxWcHl3Um45ZnZRNW5NTUlFM0VxaXBqZk02T0xTS1JCMDh6UjhDaUVDMFRpRU1sVnYvOEdHWCt5RUtiSUVPNVN4aC96NDBZUzFYUExCdEFaS2lKakdqNzdITjZoSktYRlNkRG90ak8rUkxYTTVvNk95d2FiTmtvaVArenF5VUUwbFNzMGtXSDVsUml6ckFWdHlJeVFiM1cvNlVQSG1PUGZvYXpEMFMzUVlaSkFSSGdPRFVqTXZSYmc1WHYwL1pkSUpLckgxS0hjNVUrSnFMb3RCbzdDaVdjU0xHWS9oakJGUlVTTDIrQWplMWcrMEhleFh4SjFNZEV0WlRTeThwdWx4S21nSnd1Y3NPT2ZSSWhIVlJDQytNMFBUMW9JWlhwNEozRUZZK3p4blNIQ09STjlPQXdoYlAyYmJYYkszWWdZNDhjUWRRL0pIdHBFdzIxNjhuK05zL2pIMTduTjJnZGhDdVBsWE5xempiRitzT2Z5UU1IOGNXOUViVUo2Y1U1MCtsRGcyU2h1SmV6VEt1bTBhWWQ0VU4weTg3MnNQTzdBRWxtSlhtd1N1SEZZbWdtVEU1T2tMZUxzbng2TXdyRitEc2VqcCtyMDJkR3BCSWtwWXBGMmFudTFRKzZmL2c3Zit2MWZDZlFMSWxGUkIxdmtZbGQ5ZnlZdGpFNU1HZnp1YUR3ZTNtcEQ4WTl2M3A5SUZ2d2VrVWp4NTNTWFdvalZlZUhvUmZGUmNXdFlPbzYvZ25LOTN1NWE1SkY2aWV4UHZ5RVN2VURGNGJrV3AxY3Z0ZzZpeFozRGNUaERDZVlPWjFnbHVHWFJoTGVkWVgxTHJjV1o5QnFYdi9yTGFCZmZlOUtJMXpmZmNuRnFxMHlxVitJQkVRRTVrM0pDSjdlSldJbVQyc2NyR0hBUXdnUVIvQTJEUjRPUzRhVnVWc09TUGZZQXU1STY1NTFGMTk3M09PTXZNRUFmMWpFTnpKMVJ4bi9CZ0xZWUJaY3RiQ3JGK1FFUjUycGlmMTlrc1lCM1lvSE1Ebmd6MXN0aWRlOHJVdi9zdVZVQjFPcVFyMjdxSnJ1aU9hT1k2aE1ZUWNRL1NFQmhPNGN1WVhqTzVXeFVtdzNzVndHdDVUZ3h5VjFZSXZuZjlXQ3dVMFB6L1kzelJobmlIYm9lK0VzWkRsMFlvMWFzSlViMnY4b0JWZFprOVB4MDFSOHdxbVExWTBvdFRIVlNaS0dKcWtTeXlpdG5ldXJLeFQwaTBUT3IrMHdTVjFlU3VMcVN4TldWSks2dUpIRjFKWW1ySzFwbUNHZ2lSQmRPWnlaTjVzbjJDWmtYYkJPRzZ5bXNteEowM2RIRk83R1Y3MFFpa2JoSEhpMTFOUTRSblZndG4zOVVTTmRiYzlDVkRXUzFOR1Avb0xkYVR2ZG9JQ1NUTXVvdDdhYXc5b2g4S1Q4YVRCSlhWNUs0dXBMRTFaVWtycTQwWHB6NSs5bjdncE5VcDVIaWRLbUdrOXlua2VLWVNNU0Iva0FEa1pSbjZzamhIQTBreTJpMExETU1CbDhzWDIxNWJQUitPeGlQanZOSGdaVFVmMjVNU1YxcUtMcm1iUG0xZ0w1YmdBeGVoRDZUZjNTcldQQm16RXlqUFM5ZnVwOHc0ZGJMZy84QUhSZXNCMHpiQzQ0QUFBQUFTVVZPUks1Q1lJST0iLz4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://backpack.app/ul/v1?url="
  },
  {
    name: "Bitget Wallet",
    url: "https://web3.bitget.com",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjMDAxRjI5Ii8+CjxwYXRoIGQ9Ik0yMTkuOTQ4IDk1LjcwMjJDMjAxLjYyMyA5NS42OTI5IDE4My4zMyA5NS42ODM1IDE2NC45NDEgOTUuNzExNkMxNTMuODIyIDk1LjcxMTYgMTQ5LjY1MSAxMDkuNjcxIDE1Ny45MjEgMTE3LjkzOUwyODMuMDk4IDI0My4xMTdDMjg3LjAwNCAyNDYuNjkgMjg5LjQ0MSAyNTAuNTc0IDI4OS41MyAyNTUuNjkzQzI4OS40NDEgMjYwLjgxMiAyODcuMDA0IDI2NC42OTYgMjgzLjA5OCAyNjguMjY5TDE1Ny45MjEgMzkzLjQ0NkMxNDkuNjUxIDQwMS43MTUgMTUzLjgyMiA0MTUuNjc0IDE2NC45NDEgNDE1LjY3NEMxODMuMzMgNDE1LjcwMiAyMDEuNjIzIDQxNS42OTMgMjE5Ljk0OCA0MTUuNjgzQzIyOS4xMjIgNDE1LjY3OSAyMzguMzA1IDQxNS42NzQgMjQ3LjUxMSA0MTUuNjc0QzI1OS41NTUgNDE1LjY3NCAyNjYuNzIgNDA5LjI0IDI3My4xNTQgNDAyLjgwNUwzODYuMDQ3IDI4OS45MTJDMzk1LjA1NyAyODAuOTAyIDQwMy4xMTkgMjY4LjkzOSA0MDMuMDA5IDI1NS42OTNDNDAzLjExOSAyNDIuNDQ3IDM5NS4wNTcgMjMwLjQ4NCAzODYuMDQ3IDIyMS40NzRMMjczLjE1NCAxMDguNThDMjY2LjcyIDEwMi4xNDYgMjU5LjU1NSA5NS43MTE2IDI0Ny41MTEgOTUuNzExNkMyMzguMzA1IDk1LjcxMTYgMjI5LjEyMiA5NS43MDY5IDIxOS45NDggOTUuNzAyMloiIGZpbGw9IiMwMEYwRkYiLz4KPC9zdmc+Cg==",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Gate Wallet",
    url: "https://www.gate.com/zh/web3/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNjAwcHgiIGhlaWdodD0iNjAwcHgiIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPue8lue7hCA3PC90aXRsZT4KICAgIDxkZWZzPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTEiIHBvaW50cz0iMCAwIDYwMCAwIDYwMCA2MDAgMCA2MDAiPjwvcG9seWdvbj4KICAgIDwvZGVmcz4KICAgIDxnIGlkPSLmjaLoibIiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJTVkciIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNzU1LjAwMDAwMCwgLTU1MTguMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSLnvJbnu4QtNyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc1NS4wMDAwMDAsIDU1MTguMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyBpZD0i57yW57uEIj4KICAgICAgICAgICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+CiAgICAgICAgICAgICAgICAgICAgPC9tYXNrPgogICAgICAgICAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4KICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMzAwLDQ2NC45OTg0MjcgQzIwOC44NzMwNjksNDY0Ljk5ODQyNyAxMzQuOTk2NTA0LDM5MS4xMjI1NjYgMTM0Ljk5NjUwNCwyOTkuOTk2NTA0IEMxMzQuOTk2NTA0LDIwOC44NzA0NDIgMjA4Ljg3MzA2OSwxMzUuMDAwOTM4IDMwMCwxMzUuMDAwOTM4IEwzMDAsLTAuMDAwNjM1NjAwNjI0IEMxMzQuMzEwMDQ5LC0wLjAwMDYzNTYwMDYyNCAwLDEzNC4zMTQ0ODkgMCwyOTkuOTk2NTA0IEMwLDQ2NS42Nzg1MiAxMzQuMzEwMDQ5LDYwMCAzMDAsNjAwIEM0NjUuNjg5OTUxLDYwMCA2MDAsNDY1LjY3ODUyIDYwMCwyOTkuOTk2NTA0IEw0NjUuMDAzNDk2LDI5OS45OTY1MDQgQzQ2NS4wMDM0OTYsMzkxLjEyMjU2NiAzOTEuMTI2OTMxLDQ2NC45OTg0MjcgMzAwLDQ2NC45OTg0MjciIGlkPSJGaWxsLTEiIGZpbGw9IiMyMzU0RTYiIG1hc2s9InVybCgjbWFzay0yKSI+PC9wYXRoPgogICAgICAgICAgICAgICAgPC9nPgogICAgICAgICAgICAgICAgPHBvbHlnb24gaWQ9IkZpbGwtMyIgZmlsbD0iIzE3RTZBMSIgcG9pbnRzPSIyOTkuOTkyMzczIDI5OS45OTcxNCA0NjQuOTk1ODY5IDI5OS45OTcxNCA0NjQuOTk1ODY5IDEzNC45OTUyMTcgMjk5Ljk5MjM3MyAxMzQuOTk1MjE3Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Cosmostation Wallet",
    url: "https://www.cosmostation.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0wIDQwQzAgMTcuOTA4NiAxNy45MDg2IDAgNDAgMEg4OEMxMTAuMDkxIDAgMTI4IDE3LjkwODYgMTI4IDQwVjg4QzEyOCAxMTAuMDkxIDExMC4wOTEgMTI4IDg4IDEyOEg0MEMxNy45MDg2IDEyOCAwIDExMC4wOTEgMCA4OFY0MFoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl85MDg4XzE0OTgxKSIvPgo8cGF0aCBkPSJNNTEuMDI1MyA4Ni4xNTkxTDM1Ljg2NiA1OS45MDI1QzM1LjQ4ODEgNTkuMjQ3OSAzNS4yODkxIDU4LjUwNTUgMzUuMjg5MSA1Ny43NDk3QzM1LjI4OTEgNTYuOTkzOSAzNS40ODgxIDU2LjI1MTQgMzUuODY2IDU1LjU5NjlMNTEuMDI1MyAyOS4zNTNDNTEuNDAzMiAyOC42OTg0IDUxLjk0NjggMjguMTU0OSA1Mi42MDE0IDI3Ljc3N0M1My4yNTU5IDI3LjM5OTEgNTMuOTk4NSAyNy4yMDAyIDU0Ljc1NDMgMjcuMjAwMkg4NS4wNjAyQzg1LjgxNjEgMjcuMjAwMiA4Ni41NTg2IDI3LjM5OTEgODcuMjEzMiAyNy43NzdDODcuODY3OCAyOC4xNTQ5IDg4LjQxMTMgMjguNjk4NCA4OC43ODkyIDI5LjM1M0wxMDQgNTUuNjIyNEw5Ni41NDE5IDU5LjkyODFMODIuNjI1NSAzNS44MzcxSDU3LjI0MDNMNDQuNTY2OSA1Ny43NzUyTDU4LjQ4MzMgODEuODc5TDUxLjAyNTMgODYuMTU5MVoiIGZpbGw9IiM5QzZDRkYiLz4KPHBhdGggZD0iTTczLjI0NTYgMTAwLjQ0OEg0Mi44NzU1QzQyLjExOTcgMTAwLjQ0OCA0MS4zNzcyIDEwMC4yNDkgNDAuNzIyNiA5OS44NzExQzQwLjA2ODEgOTkuNDkzMiAzOS41MjQ1IDk4Ljk0OTYgMzkuMTQ2NiA5OC4yOTUxTDI0IDcyLjA2NDFMMzEuNDQ1MSA2Ny43NTg1TDQ1LjM2MTUgOTEuODYyM0g3MC42ODI3TDgzLjM0MzMgNjkuOTExM0w2OS40Mzk3IDQ1LjgyMDNMNzYuODg0OSA0MS41MTQ2TDkyLjA0NDIgNjcuNzU4NUM5Mi40MjIxIDY4LjQxMyA5Mi42MjExIDY5LjE1NTUgOTIuNjIxMSA2OS45MTEzQzkyLjYyMTEgNzAuNjY3MSA5Mi40MjIxIDcxLjQwOTYgOTIuMDQ0MiA3Mi4wNjQxTDc2Ljg4NDkgOTguMzIwN0M3Ni41MTM0IDk4Ljk1OTIgNzUuOTgzIDk5LjQ5MDYgNzUuMzQ1MyA5OS44NjM0Qzc0LjcwNzUgMTAwLjIzNiA3My45ODQyIDEwMC40MzggNzMuMjQ1NiAxMDAuNDQ4WiIgZmlsbD0iIzA1RDJERCIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzkwODhfMTQ5ODEiIHgxPSI2NCIgeTE9IjAiIHgyPSI2NCIgeTI9IjEyOCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMjEyMTIxIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzE3MTcxNyIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true
  }
];
var crossChainStandardSupportedWalletList = [
  {
    name: "Phantom (Solana)",
    url: "https://phantom.com/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://phantom.app/ul/browse/"
  },
  {
    name: "Phantom (Ethereum)",
    url: "https://phantom.com/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://phantom.app/ul/browse/"
  },
  {
    name: "Nightly (Solana)",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Nightly (Ethereum)",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Metamask (Solana)",
    url: "https://metamask.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiB2aWV3Qm94PSIwIDAgMjU2IDI0MCI+PHBhdGggZmlsbD0iI0UxNzcyNiIgZD0iTTI1MC4wNjYgMEwxNDAuMjE5IDgxLjI3OWwyMC40MjctNDcuOXoiLz48cGF0aCBmaWxsPSIjRTI3NjI1IiBkPSJtNi4xOTEuMDk2bDg5LjE4MSAzMy4yODlsMTkuMzk2IDQ4LjUyOHpNMjA1Ljg2IDE3Mi44NThsNDguNTUxLjkyNGwtMTYuOTY4IDU3LjY0MmwtNTkuMjQzLTE2LjMxMXptLTE1NS43MjEgMGwyNy41NTcgNDIuMjU1bC01OS4xNDMgMTYuMzEybC0xNi44NjUtNTcuNjQzeiIvPjxwYXRoIGZpbGw9IiNFMjc2MjUiIGQ9Im0xMTIuMTMxIDY5LjU1MmwxLjk4NCA2NC4wODNsLTU5LjM3MS0yLjcwMWwxNi44ODgtMjUuNDc4bC4yMTQtLjI0NXptMzEuMTIzLS43MTVsNDAuOSAzNi4zNzZsLjIxMi4yNDRsMTYuODg4IDI1LjQ3OGwtNTkuMzU4IDIuN3pNNzkuNDM1IDE3My4wNDRsMzIuNDE4IDI1LjI1OWwtMzcuNjU4IDE4LjE4MXptOTcuMTM2LS4wMDRsNS4xMzEgNDMuNDQ1bC0zNy41NTMtMTguMTg0eiIvPjxwYXRoIGZpbGw9IiNENUJGQjIiIGQ9Im0xNDQuOTc4IDE5NS45MjJsMzguMTA3IDE4LjQ1MmwtMzUuNDQ3IDE2Ljg0NmwuMzY4LTExLjEzNHptLTMzLjk2Ny4wMDhsLTIuOTA5IDIzLjk3NGwuMjM5IDExLjMwM2wtMzUuNTMtMTYuODMzeiIvPjxwYXRoIGZpbGw9IiMyMzM0NDciIGQ9Im0xMDAuMDA3IDE0MS45OTlsOS45NTggMjAuOTI4bC0zMy45MDMtOS45MzJ6bTU1Ljk4NS4wMDJsMjQuMDU4IDEwLjk5NGwtMzQuMDE0IDkuOTI5eiIvPjxwYXRoIGZpbGw9IiNDQzYyMjgiIGQ9Im04Mi4wMjYgMTcyLjgzbC01LjQ4IDQ1LjA0bC0yOS4zNzMtNDQuMDU1em05MS45NS4wMDFsMzQuODU0Ljk4NGwtMjkuNDgzIDQ0LjA1N3ptMjguMTM2LTQ0LjQ0NGwtMjUuMzY1IDI1Ljg1MWwtMTkuNTU3LTguOTM3bC05LjM2MyAxOS42ODRsLTYuMTM4LTMzLjg0OXptLTE0OC4yMzcgMGw2MC40MzUgMi43NDlsLTYuMTM5IDMzLjg0OWwtOS4zNjUtMTkuNjgxbC0xOS40NTMgOC45MzV6Ii8+PHBhdGggZmlsbD0iI0UyNzUyNSIgZD0ibTUyLjE2NiAxMjMuMDgybDI4LjY5OCAyOS4xMjFsLjk5NCAyOC43NDl6bTE1MS42OTctLjA1MmwtMjkuNzQ2IDU3Ljk3M2wxLjEyLTI4Ljh6bS05MC45NTYgMS44MjZsMS4xNTUgNy4yN2wyLjg1NCAxOC4xMTFsLTEuODM1IDU1LjYyNWwtOC42NzUtNDQuNjg1bC0uMDAzLS40NjJ6bTMwLjE3MS0uMTAxbDYuNTIxIDM1Ljk2bC0uMDAzLjQ2MmwtOC42OTcgNDQuNzk3bC0uMzQ0LTExLjIwNWwtMS4zNTctNDQuODYyeiIvPjxwYXRoIGZpbGw9IiNGNTg0MUYiIGQ9Im0xNzcuNzg4IDE1MS4wNDZsLS45NzEgMjQuOTc4bC0zMC4yNzQgMjMuNTg3bC02LjEyLTQuMzI0bDYuODYtMzUuMzM1em0tOTkuNDcxIDBsMzAuMzk5IDguOTA2bDYuODYgMzUuMzM1bC02LjEyIDQuMzI0bC0zMC4yNzUtMjMuNTg5eiIvPjxwYXRoIGZpbGw9IiNDMEFDOUQiIGQ9Im02Ny4wMTggMjA4Ljg1OGwzOC43MzIgMTguMzUybC0uMTY0LTcuODM3bDMuMjQxLTIuODQ1aDM4LjMzNGwzLjM1OCAyLjgzNWwtLjI0OCA3LjgzMWwzOC40ODctMTguMjlsLTE4LjcyOCAxNS40NzZsLTIyLjY0NSAxNS41NTNoLTM4Ljg2OWwtMjIuNjMtMTUuNjE3eiIvPjxwYXRoIGZpbGw9IiMxNjE2MTYiIGQ9Im0xNDIuMjA0IDE5My40NzlsNS40NzYgMy44NjlsMy4yMDkgMjUuNjA0bC00LjY0NC0zLjkyMWgtMzYuNDc2bC00LjU1NiA0bDMuMTA0LTI1LjY4MWw1LjQ3OC0zLjg3MXoiLz48cGF0aCBmaWxsPSIjNzYzRTFBIiBkPSJNMjQyLjgxNCAyLjI1TDI1NiA0MS44MDdsLTguMjM1IDM5Ljk5N2w1Ljg2NCA0LjUyM2wtNy45MzUgNi4wNTRsNS45NjQgNC42MDZsLTcuODk3IDcuMTkxbDQuODQ4IDMuNTExbC0xMi44NjYgMTUuMDI2bC01Mi43Ny0xNS4zNjVsLS40NTctLjI0NWwtMzguMDI3LTMyLjA3OHptLTIyOS42MjggMGw5OC4zMjYgNzIuNzc3bC0zOC4wMjggMzIuMDc4bC0uNDU3LjI0NWwtNTIuNzcgMTUuMzY1bC0xMi44NjYtMTUuMDI2bDQuODQ0LTMuNTA4bC03Ljg5Mi03LjE5NGw1Ljk1Mi00LjYwMWwtOC4wNTQtNi4wNzFsNi4wODUtNC41MjZMMCA0MS44MDl6Ii8+PHBhdGggZmlsbD0iI0Y1ODQxRiIgZD0ibTE4MC4zOTIgMTAzLjk5bDU1LjkxMyAxNi4yNzlsMTguMTY1IDU1Ljk4NmgtNDcuOTI0bC0zMy4wMi40MTZsMjQuMDE0LTQ2LjgwOHptLTEwNC43ODQgMGwtMTcuMTUxIDI1Ljg3M2wyNC4wMTcgNDYuODA4bC0zMy4wMDUtLjQxNkgxLjYzMWwxOC4wNjMtNTUuOTg1em04Ny43NzYtNzAuODc4bC0xNS42MzkgNDIuMjM5bC0zLjMxOSA1Ny4wNmwtMS4yNyAxNy44ODVsLS4xMDEgNDUuNjg4aC0zMC4xMTFsLS4wOTgtNDUuNjAybC0xLjI3NC0xNy45ODZsLTMuMzItNTcuMDQ1bC0xNS42MzctNDIuMjM5eiIvPjwvc3ZnPg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://link.metamask.io/dapp/"
  },
  {
    name: "Metamask (Ethereum)",
    url: "https://metamask.io/",
    icon: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiB2aWV3Qm94PSIwIDAgMjU2IDI0MCI+PHBhdGggZmlsbD0iI0UxNzcyNiIgZD0iTTI1MC4wNjYgMEwxNDAuMjE5IDgxLjI3OWwyMC40MjctNDcuOXoiLz48cGF0aCBmaWxsPSIjRTI3NjI1IiBkPSJtNi4xOTEuMDk2bDg5LjE4MSAzMy4yODlsMTkuMzk2IDQ4LjUyOHpNMjA1Ljg2IDE3Mi44NThsNDguNTUxLjkyNGwtMTYuOTY4IDU3LjY0MmwtNTkuMjQzLTE2LjMxMXptLTE1NS43MjEgMGwyNy41NTcgNDIuMjU1bC01OS4xNDMgMTYuMzEybC0xNi44NjUtNTcuNjQzeiIvPjxwYXRoIGZpbGw9IiNFMjc2MjUiIGQ9Im0xMTIuMTMxIDY5LjU1MmwxLjk4NCA2NC4wODNsLTU5LjM3MS0yLjcwMWwxNi44ODgtMjUuNDc4bC4yMTQtLjI0NXptMzEuMTIzLS43MTVsNDAuOSAzNi4zNzZsLjIxMi4yNDRsMTYuODg4IDI1LjQ3OGwtNTkuMzU4IDIuN3pNNzkuNDM1IDE3My4wNDRsMzIuNDE4IDI1LjI1OWwtMzcuNjU4IDE4LjE4MXptOTcuMTM2LS4wMDRsNS4xMzEgNDMuNDQ1bC0zNy41NTMtMTguMTg0eiIvPjxwYXRoIGZpbGw9IiNENUJGQjIiIGQ9Im0xNDQuOTc4IDE5NS45MjJsMzguMTA3IDE4LjQ1MmwtMzUuNDQ3IDE2Ljg0NmwuMzY4LTExLjEzNHptLTMzLjk2Ny4wMDhsLTIuOTA5IDIzLjk3NGwuMjM5IDExLjMwM2wtMzUuNTMtMTYuODMzeiIvPjxwYXRoIGZpbGw9IiMyMzM0NDciIGQ9Im0xMDAuMDA3IDE0MS45OTlsOS45NTggMjAuOTI4bC0zMy45MDMtOS45MzJ6bTU1Ljk4NS4wMDJsMjQuMDU4IDEwLjk5NGwtMzQuMDE0IDkuOTI5eiIvPjxwYXRoIGZpbGw9IiNDQzYyMjgiIGQ9Im04Mi4wMjYgMTcyLjgzbC01LjQ4IDQ1LjA0bC0yOS4zNzMtNDQuMDU1em05MS45NS4wMDFsMzQuODU0Ljk4NGwtMjkuNDgzIDQ0LjA1N3ptMjguMTM2LTQ0LjQ0NGwtMjUuMzY1IDI1Ljg1MWwtMTkuNTU3LTguOTM3bC05LjM2MyAxOS42ODRsLTYuMTM4LTMzLjg0OXptLTE0OC4yMzcgMGw2MC40MzUgMi43NDlsLTYuMTM5IDMzLjg0OWwtOS4zNjUtMTkuNjgxbC0xOS40NTMgOC45MzV6Ii8+PHBhdGggZmlsbD0iI0UyNzUyNSIgZD0ibTUyLjE2NiAxMjMuMDgybDI4LjY5OCAyOS4xMjFsLjk5NCAyOC43NDl6bTE1MS42OTctLjA1MmwtMjkuNzQ2IDU3Ljk3M2wxLjEyLTI4Ljh6bS05MC45NTYgMS44MjZsMS4xNTUgNy4yN2wyLjg1NCAxOC4xMTFsLTEuODM1IDU1LjYyNWwtOC42NzUtNDQuNjg1bC0uMDAzLS40NjJ6bTMwLjE3MS0uMTAxbDYuNTIxIDM1Ljk2bC0uMDAzLjQ2MmwtOC42OTcgNDQuNzk3bC0uMzQ0LTExLjIwNWwtMS4zNTctNDQuODYyeiIvPjxwYXRoIGZpbGw9IiNGNTg0MUYiIGQ9Im0xNzcuNzg4IDE1MS4wNDZsLS45NzEgMjQuOTc4bC0zMC4yNzQgMjMuNTg3bC02LjEyLTQuMzI0bDYuODYtMzUuMzM1em0tOTkuNDcxIDBsMzAuMzk5IDguOTA2bDYuODYgMzUuMzM1bC02LjEyIDQuMzI0bC0zMC4yNzUtMjMuNTg5eiIvPjxwYXRoIGZpbGw9IiNDMEFDOUQiIGQ9Im02Ny4wMTggMjA4Ljg1OGwzOC43MzIgMTguMzUybC0uMTY0LTcuODM3bDMuMjQxLTIuODQ1aDM4LjMzNGwzLjM1OCAyLjgzNWwtLjI0OCA3LjgzMWwzOC40ODctMTguMjlsLTE4LjcyOCAxNS40NzZsLTIyLjY0NSAxNS41NTNoLTM4Ljg2OWwtMjIuNjMtMTUuNjE3eiIvPjxwYXRoIGZpbGw9IiMxNjE2MTYiIGQ9Im0xNDIuMjA0IDE5My40NzlsNS40NzYgMy44NjlsMy4yMDkgMjUuNjA0bC00LjY0NC0zLjkyMWgtMzYuNDc2bC00LjU1NiA0bDMuMTA0LTI1LjY4MWw1LjQ3OC0zLjg3MXoiLz48cGF0aCBmaWxsPSIjNzYzRTFBIiBkPSJNMjQyLjgxNCAyLjI1TDI1NiA0MS44MDdsLTguMjM1IDM5Ljk5N2w1Ljg2NCA0LjUyM2wtNy45MzUgNi4wNTRsNS45NjQgNC42MDZsLTcuODk3IDcuMTkxbDQuODQ4IDMuNTExbC0xMi44NjYgMTUuMDI2bC01Mi43Ny0xNS4zNjVsLS40NTctLjI0NWwtMzguMDI3LTMyLjA3OHptLTIyOS42MjggMGw5OC4zMjYgNzIuNzc3bC0zOC4wMjggMzIuMDc4bC0uNDU3LjI0NWwtNTIuNzcgMTUuMzY1bC0xMi44NjYtMTUuMDI2bDQuODQ0LTMuNTA4bC03Ljg5Mi03LjE5NGw1Ljk1Mi00LjYwMWwtOC4wNTQtNi4wNzFsNi4wODUtNC41MjZMMCA0MS44MDl6Ii8+PHBhdGggZmlsbD0iI0Y1ODQxRiIgZD0ibTE4MC4zOTIgMTAzLjk5bDU1LjkxMyAxNi4yNzlsMTguMTY1IDU1Ljk4NmgtNDcuOTI0bC0zMy4wMi40MTZsMjQuMDE0LTQ2LjgwOHptLTEwNC43ODQgMGwtMTcuMTUxIDI1Ljg3M2wyNC4wMTcgNDYuODA4bC0zMy4wMDUtLjQxNkgxLjYzMWwxOC4wNjMtNTUuOTg1em04Ny43NzYtNzAuODc4bC0xNS42MzkgNDIuMjM5bC0zLjMxOSA1Ny4wNmwtMS4yNyAxNy44ODVsLS4xMDEgNDUuNjg4aC0zMC4xMTFsLS4wOTgtNDUuNjAybC0xLjI3NC0xNy45ODZsLTMuMzItNTcuMDQ1bC0xNS42MzctNDIuMjM5eiIvPjwvc3ZnPg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://link.metamask.io/dapp/"
  }
];
function getSDKWallets(dappConfig) {
  var sdkWallets = [];
  if (typeof window !== "undefined") {
    sdkWallets.push(new AptosConnectGoogleWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)), new AptosConnectAppleWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)), new AptosConnectGenericWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)));
  }
  return sdkWallets;
}
var WalletCore = function(EventEmitter2) {
  "use strict";
  _inherits(WalletCore2, EventEmitter2);
  function WalletCore2(optInWallets, dappConfig, disableTelemetry) {
    var hideWallets = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [
      "Petra Web"
    ];
    _class_call_check(this, WalletCore2);
    var _this;
    _this = _call_super(this, WalletCore2);
    _this._wallet = null;
    _this._sdkWallets = [];
    _this._standard_wallets = [];
    _this._standard_not_detected_wallets = [];
    _this._standard_wallets_hidden = [];
    _this._network = null;
    _this._connected = false;
    _this._connecting = false;
    _this._account = null;
    _this._optInWallets = [];
    _this._hideWallets = [];
    _this._disableTelemetry = false;
    _this.ga4 = null;
    _this._optInWallets = optInWallets || [];
    _this._hideWallets = hideWallets;
    _this._dappConfig = dappConfig;
    _this._disableTelemetry = disableTelemetry !== null && disableTelemetry !== void 0 ? disableTelemetry : false;
    _this._sdkWallets = getSDKWallets(_this._dappConfig);
    if (!_this._disableTelemetry) {
      _this.ga4 = new GA4();
    }
    _this.fetchExtensionAIP62AptosWallets();
    _this.fetchSDKAIP62AptosWallets();
    _this.appendNotDetectedStandardSupportedWallets();
    return _this;
  }
  _create_class(WalletCore2, [
    {
      key: "fetchExtensionAIP62AptosWallets",
      value: function fetchExtensionAIP62AptosWallets() {
        var _getAptosWallets = d(), aptosWallets = _getAptosWallets.aptosWallets, on2 = _getAptosWallets.on;
        this.setExtensionAIP62Wallets(aptosWallets);
        if (typeof window === "undefined") return;
        var that = this;
        var removeRegisterListener = on2("register", function() {
          var _getAptosWallets2 = d(), aptosWallets2 = _getAptosWallets2.aptosWallets;
          that.setExtensionAIP62Wallets(aptosWallets2);
        });
        var removeUnregisterListener = on2("unregister", function() {
          var _getAptosWallets2 = d(), aptosWallets2 = _getAptosWallets2.aptosWallets;
          that.setExtensionAIP62Wallets(aptosWallets2);
        });
      }
    },
    {
      /**
      * Set AIP-62 extension wallets
      *
      * @param extensionwWallets
      */
      key: "setExtensionAIP62Wallets",
      value: function setExtensionAIP62Wallets(extensionwWallets) {
        var _this = this;
        extensionwWallets.map(function(wallet) {
          if (_this.excludeWallet(wallet)) {
            return;
          }
          if (wallet.name === "Rimosafe") {
            return;
          }
          var isValid = i(wallet);
          if (isValid) {
            var index = _this._standard_not_detected_wallets.findIndex(function(notDetctedWallet) {
              return notDetctedWallet.name == wallet.name;
            });
            if (index !== -1) {
              _this._standard_not_detected_wallets.splice(index, 1);
            }
            var alreadyExists = _this._standard_wallets.some(function(w3) {
              return w3.name === wallet.name;
            }) || _this._standard_wallets_hidden.some(function(w3) {
              return w3.name === wallet.name;
            });
            if (!alreadyExists) {
              wallet.readyState = "Installed";
              wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
              if (!_this.hideWallet(wallet)) {
                _this._standard_wallets.push(wallet);
                _this.emit("standardWalletsAdded", wallet);
              } else {
                _this._standard_wallets_hidden.push(wallet);
                _this.emit("standardWalletsHiddenAdded", wallet);
              }
            }
          }
        });
      }
    },
    {
      /**
      * Set AIP-62 SDK wallets
      */
      key: "fetchSDKAIP62AptosWallets",
      value: function fetchSDKAIP62AptosWallets() {
        var _this = this;
        this._sdkWallets.map(function(wallet) {
          if (_this.excludeWallet(wallet)) {
            return;
          }
          var isValid = i(wallet);
          if (isValid) {
            wallet.readyState = "Installed";
            wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
            if (!_this.hideWallet(wallet)) {
              _this._standard_wallets.push(wallet);
            } else {
              _this._standard_wallets_hidden.push(wallet);
            }
          }
        });
      }
    },
    {
      // Aptos native wallets do not have an authenticationFunction property
      key: "isAptosNativeWallet",
      value: function isAptosNativeWallet(wallet) {
        return !("authenticationFunction" in wallet);
      }
    },
    {
      // Since we can't discover AIP-62 wallets that are not installed on the user machine,
      // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.
      // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array
      // when wallet is not installed on the user machine
      key: "appendNotDetectedStandardSupportedWallets",
      value: function appendNotDetectedStandardSupportedWallets() {
        var _this = this;
        var _this__dappConfig;
        var walletRegistry = ((_this__dappConfig = this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.crossChainWallets) ? _to_consumable_array(aptosStandardSupportedWalletList).concat(_to_consumable_array(crossChainStandardSupportedWalletList)) : aptosStandardSupportedWalletList;
        walletRegistry.map(function(supportedWallet) {
          var existingStandardWallet = _this._standard_wallets.find(function(wallet) {
            return wallet.name === supportedWallet.name;
          }) || _this._standard_wallets_hidden.find(function(wallet) {
            return wallet.name === supportedWallet.name;
          });
          if (existingStandardWallet) {
            return;
          }
          if (_this.excludeWallet(supportedWallet)) {
            return;
          }
          if (!existingStandardWallet) {
            supportedWallet.isAptosNativeWallet = !("authenticationFunction" in supportedWallet);
            _this._standard_not_detected_wallets.push(supportedWallet);
            _this.emit("standardNotDetectedWalletAdded", supportedWallet);
          }
        });
      }
    },
    {
      /**
      * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include
      *
      * @param wallet AdapterWallet | AdapterNotDetectedWallet
      * @returns boolean
      */
      key: "excludeWallet",
      value: function excludeWallet(wallet) {
        if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
          return true;
        }
        return false;
      }
    },
    {
      /**
      * A function that hides an AIP-62 compatible wallet from normal display.
      *
      * @param wallet AdapterWallet | AdapterNotDetectedWallet
      * @returns boolean
      */
      key: "hideWallet",
      value: function hideWallet(wallet) {
        return this._hideWallets.length > 0 && this._hideWallets.includes(wallet.name);
      }
    },
    {
      key: "recordEvent",
      value: function recordEvent(eventName, additionalInfo) {
        var _this__wallet, _this__network, _this__network1, _this_ga4;
        (_this_ga4 = this.ga4) === null || _this_ga4 === void 0 ? void 0 : _this_ga4.gtag("event", "wallet_adapter_".concat(eventName), _object_spread({
          wallet: (_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name,
          network: (_this__network = this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
          network_url: (_this__network1 = this._network) === null || _this__network1 === void 0 ? void 0 : _this__network1.url,
          adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
          send_to: "G-GNVVWBL3J9"
        }, additionalInfo));
      }
    },
    {
      /**
      * Helper function to ensure wallet exists
      *
      * @param wallet A wallet
      */
      key: "ensureWalletExists",
      value: function ensureWalletExists(wallet) {
        if (!wallet) {
          throw new WalletNotConnectedError().name;
        }
        if (!(wallet.readyState === "Installed")) throw new WalletNotReadyError("Wallet is not set").name;
      }
    },
    {
      /**
      * Helper function to ensure account exists
      *
      * @param account An account
      */
      key: "ensureAccountExists",
      value: function ensureAccountExists(account) {
        if (!account) {
          throw new WalletAccountError("Account is not set").name;
        }
      }
    },
    {
      key: "setAnsName",
      value: (
        /**
        * Queries and sets ANS name for the current connected wallet account
        */
        function setAnsName() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__network, aptosConfig, aptos, name, error;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (!(((_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.chainId) && _this._account)) return [
                    3,
                    4
                  ];
                  if (_this._account.ansName) return [
                    2
                  ];
                  if (!ChainIdToAnsSupportedNetworkMap[_this._network.chainId] || !isAptosNetwork(_this._network)) {
                    _this._account.ansName = void 0;
                    return [
                      2
                    ];
                  }
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new ee(aptosConfig);
                  _state.label = 1;
                case 1:
                  _state.trys.push([
                    1,
                    3,
                    ,
                    4
                  ]);
                  return [
                    4,
                    aptos.ans.getPrimaryName({
                      address: _this._account.address.toString()
                    })
                  ];
                case 2:
                  name = _state.sent();
                  _this._account.ansName = name;
                  return [
                    3,
                    4
                  ];
                case 3:
                  error = _state.sent();
                  console.log("Error setting ANS name ".concat(error));
                  return [
                    3,
                    4
                  ];
                case 4:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      /**
      * Function to cleat wallet adapter data.
      *
      * - Removes current connected wallet state
      * - Removes current connected account state
      * - Removes current connected network state
      * - Removes autoconnect local storage value
      */
      key: "clearData",
      value: function clearData() {
        this._connected = false;
        this.setWallet(null);
        this.setAccount(null);
        this.setNetwork(null);
        removeLocalStorage();
      }
    },
    {
      /**
      * Sets the connected wallet
      *
      * @param wallet A wallet
      */
      key: "setWallet",
      value: function setWallet(wallet) {
        this._wallet = wallet;
      }
    },
    {
      /**
      * Sets the connected account
      *
      * @param account An account
      */
      key: "setAccount",
      value: function setAccount(account) {
        this._account = account;
      }
    },
    {
      /**
      * Sets the connected network
      *
      * @param network A network
      */
      key: "setNetwork",
      value: function setNetwork(network) {
        this._network = network;
      }
    },
    {
      /**
      * Helper function to detect whether a wallet is connected
      *
      * @returns boolean
      */
      key: "isConnected",
      value: function isConnected() {
        return this._connected;
      }
    },
    {
      key: "wallets",
      get: (
        /**
        * Getter to fetch all detected wallets
        */
        function get2() {
          return this._standard_wallets;
        }
      )
    },
    {
      key: "hiddenWallets",
      get: (
        /**
        * Getter to fetch all hidden wallets
        */
        function get2() {
          return this._standard_wallets_hidden;
        }
      )
    },
    {
      key: "notDetectedWallets",
      get: function get2() {
        return this._standard_not_detected_wallets;
      }
    },
    {
      key: "wallet",
      get: (
        /**
        * Getter for the current connected wallet
        *
        * @return wallet info
        * @throws WalletNotSelectedError
        */
        function get2() {
          try {
            if (!this._wallet) return null;
            return this._wallet;
          } catch (error) {
            throw new WalletNotSelectedError(error).message;
          }
        }
      )
    },
    {
      key: "account",
      get: (
        /**
        * Getter for the current connected account
        *
        * @return account info
        * @throws WalletAccountError
        */
        function get2() {
          try {
            return this._account;
          } catch (error) {
            throw new WalletAccountError(error).message;
          }
        }
      )
    },
    {
      key: "network",
      get: (
        /**
        * Getter for the current wallet network
        *
        * @return network info
        * @throws WalletGetNetworkError
        */
        function get2() {
          try {
            return this._network;
          } catch (error) {
            throw new WalletGetNetworkError(error).message;
          }
        }
      )
    },
    {
      key: "connect",
      value: (
        /**
        * Helper function to run some checks before we connect with a wallet.
        *
        * @param walletName. The wallet name we want to connect with.
        */
        function connect(walletName) {
          var _this = this;
          return _async_to_generator(function() {
            var selectedWallet2, uninstalledWallet, parameter, url, ref, location, allDetectedWallets, selectedWallet, _this__wallet;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (isRedirectable()) {
                    selectedWallet2 = _this._standard_not_detected_wallets.find(function(wallet) {
                      return wallet.name === walletName;
                    });
                    if (selectedWallet2) {
                      uninstalledWallet = selectedWallet2;
                      if (uninstalledWallet.deeplinkProvider) {
                        parameter = "";
                        if (uninstalledWallet.name.includes("Phantom")) {
                          url = encodeURIComponent(window.location.href);
                          ref = encodeURIComponent(window.location.origin);
                          parameter = "".concat(url, "?ref=").concat(ref);
                        } else if (uninstalledWallet.name.includes("Metamask")) {
                          parameter = window.location.href;
                        } else {
                          parameter = encodeURIComponent(window.location.href);
                        }
                        location = uninstalledWallet.deeplinkProvider.concat(parameter);
                        window.location.href = location;
                        return [
                          2
                        ];
                      }
                    }
                  }
                  allDetectedWallets = _to_consumable_array(_this._standard_wallets).concat(_to_consumable_array(_this._standard_wallets_hidden));
                  selectedWallet = allDetectedWallets.find(function(wallet) {
                    return wallet.name === walletName;
                  });
                  if (!selectedWallet) return [
                    2
                  ];
                  if (_this._connected && _this._account) {
                    ;
                    if (((_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name) === walletName) throw new WalletConnectionError("".concat(walletName, " wallet is already connected")).message;
                  }
                  return [
                    4,
                    _this.connectWallet(selectedWallet, _async_to_generator(function() {
                      var response;
                      return _ts_generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            return [
                              4,
                              selectedWallet.features["aptos:connect"].connect()
                            ];
                          case 1:
                            response = _state2.sent();
                            if (response.status === r2.REJECTED) {
                              throw new WalletConnectionError("User has rejected the request").message;
                            }
                            return [
                              2,
                              {
                                account: response.args,
                                output: void 0
                              }
                            ];
                        }
                      });
                    }))
                  ];
                case 1:
                  _state.sent();
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signIn",
      value: (
        /**
        * Signs into the wallet by connecting and signing an authentication messages.
        *
        * For more information, visit: https://siwa.aptos.dev
        *
        * @param args
        * @param args.input The AptosSignInInput which defines how the SIWA Message should be constructed
        * @param args.walletName The name of the wallet to sign into
        * @returns The AptosSignInOutput which contains the account and signature information
        */
        function signIn(args) {
          var _this = this;
          return _async_to_generator(function() {
            var input, walletName, allDetectedWallets, selectedWallet;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  input = args.input, walletName = args.walletName;
                  allDetectedWallets = _this._standard_wallets;
                  selectedWallet = allDetectedWallets.find(function(wallet) {
                    return wallet.name === walletName;
                  });
                  if (!selectedWallet) {
                    throw new WalletNotFoundError("Wallet ".concat(walletName, " not found")).message;
                  }
                  if (!selectedWallet.features["aptos:signIn"]) {
                    throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(walletName)).message;
                  }
                  return [
                    4,
                    _this.connectWallet(selectedWallet, _async_to_generator(function() {
                      var response;
                      return _ts_generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            if (!selectedWallet.features["aptos:signIn"]) {
                              throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(selectedWallet.name)).message;
                            }
                            return [
                              4,
                              selectedWallet.features["aptos:signIn"].signIn(input)
                            ];
                          case 1:
                            response = _state2.sent();
                            if (response.status === r2.REJECTED) {
                              throw new WalletConnectionError("User has rejected the request").message;
                            }
                            return [
                              2,
                              {
                                account: response.args.account,
                                output: response.args
                              }
                            ];
                        }
                      });
                    }))
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "connectWallet",
      value: (
        /**
        * Connects a wallet to the dapp.
        * On connect success, we set the current account and the network, and keeping the selected wallet
        * name in LocalStorage to support autoConnect function.
        *
        * @param selectedWallet. The wallet we want to connect.
        * @emit emits "connect" event
        * @throws WalletConnectionError
        */
        function connectWallet(selectedWallet, onConnect) {
          var _this = this;
          return _async_to_generator(function() {
            var _ref, account, output, network, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    4,
                    5,
                    6
                  ]);
                  _this._connecting = true;
                  _this.setWallet(selectedWallet);
                  return [
                    4,
                    onConnect()
                  ];
                case 1:
                  _ref = _state.sent(), account = _ref.account, output = _ref.output;
                  _this.setAccount(account);
                  return [
                    4,
                    selectedWallet.features["aptos:network"].network()
                  ];
                case 2:
                  network = _state.sent();
                  _this.setNetwork(network);
                  return [
                    4,
                    _this.setAnsName()
                  ];
                case 3:
                  _state.sent();
                  setLocalStorage(selectedWallet.name);
                  _this._connected = true;
                  _this.recordEvent("wallet_connect");
                  _this.emit("connect", account);
                  return [
                    2,
                    output
                  ];
                case 4:
                  error = _state.sent();
                  _this.clearData();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletConnectionError(errMsg).message;
                case 5:
                  _this._connecting = false;
                  return [
                    7
                  ];
                case 6:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "disconnect",
      value: (
        /**
        * Disconnect the current connected wallet. On success, we clear the
        * current account, current network and LocalStorage data.
        *
        * @emit emits "disconnect" event
        * @throws WalletDisconnectionError
        */
        function disconnect() {
          var _this = this;
          return _async_to_generator(function() {
            var error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    _this._wallet.features["aptos:disconnect"].disconnect()
                  ];
                case 1:
                  _state.sent();
                  _this.clearData();
                  _this.recordEvent("wallet_disconnect");
                  _this.emit("disconnect");
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletDisconnectionError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signAndSubmitTransaction",
      value: (
        /**
        * Signs and submits a transaction to chain
        *
        * @param transactionInput InputTransactionData
        * @returns AptosSignAndSubmitTransactionOutput
        */
        function signAndSubmitTransaction(transactionInput) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__dappConfig, ref, shouldUseTxnSubmitter, _transactionInput_options, _transactionInput_options1, aptosConfig2, aptos2, transaction2, signAndSubmitTransactionMethod, response3, response2, aptosConfig, aptos, transaction, signTransactionResponse, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    9,
                    ,
                    10
                  ]);
                  if ("function" in transactionInput.data) {
                    if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
                      throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
                    }
                    if (transactionInput.data.function === "0x1::code::publish_package_txn") {
                      ;
                      ref = handlePublishPackageTransaction(transactionInput), transactionInput.data.functionArguments[0] = ref.metadataBytes, transactionInput.data.functionArguments[1] = ref.byteCode, ref;
                    }
                  }
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_and_submit_transaction");
                  shouldUseTxnSubmitter = !!(((_this__dappConfig = _this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.transactionSubmitter) || transactionInput.transactionSubmitter);
                  if (!(_this._wallet.features["aptos:signAndSubmitTransaction"] && !shouldUseTxnSubmitter)) return [
                    3,
                    5
                  ];
                  if (!(_this._wallet.features["aptos:signAndSubmitTransaction"].version !== "1.1.0")) return [
                    3,
                    3
                  ];
                  aptosConfig2 = getAptosConfig(_this._network, _this._dappConfig);
                  aptos2 = new ee(aptosConfig2);
                  return [
                    4,
                    aptos2.transaction.build.simple({
                      sender: _this._account.address.toString(),
                      data: transactionInput.data,
                      options: transactionInput.options
                    })
                  ];
                case 1:
                  transaction2 = _state.sent();
                  signAndSubmitTransactionMethod = _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction;
                  return [
                    4,
                    signAndSubmitTransactionMethod(transaction2)
                  ];
                case 2:
                  response3 = _state.sent();
                  if (response3.status === r2.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response3.args
                  ];
                case 3:
                  return [
                    4,
                    _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction({
                      payload: transactionInput.data,
                      gasUnitPrice: (_transactionInput_options = transactionInput.options) === null || _transactionInput_options === void 0 ? void 0 : _transactionInput_options.gasUnitPrice,
                      maxGasAmount: (_transactionInput_options1 = transactionInput.options) === null || _transactionInput_options1 === void 0 ? void 0 : _transactionInput_options1.maxGasAmount
                    })
                  ];
                case 4:
                  response2 = _state.sent();
                  if (response2.status === r2.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response2.args
                  ];
                case 5:
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new ee(aptosConfig);
                  return [
                    4,
                    aptos.transaction.build.simple({
                      sender: _this._account.address.toString(),
                      data: transactionInput.data,
                      options: transactionInput.options,
                      withFeePayer: shouldUseTxnSubmitter
                    })
                  ];
                case 6:
                  transaction = _state.sent();
                  return [
                    4,
                    _this.signTransaction({
                      transactionOrPayload: transaction
                    })
                  ];
                case 7:
                  signTransactionResponse = _state.sent();
                  return [
                    4,
                    _this.submitTransaction({
                      transaction,
                      senderAuthenticator: signTransactionResponse.authenticator,
                      transactionSubmitter: transactionInput.transactionSubmitter,
                      pluginParams: transactionInput.pluginParams
                    })
                  ];
                case 8:
                  response = _state.sent();
                  return [
                    2,
                    {
                      hash: response.hash
                    }
                  ];
                case 9:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignAndSubmitMessageError(errMsg).message;
                case 10:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signTransaction",
      value: (
        /**
        * Signs a transaction
        *
        * This method supports 2 input types -
        * 1. A raw transaction that was already built by the dapp,
        * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing
        *
        * @param transactionOrPayload AnyRawTransaction | InputTransactionData
        * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer
        * @param options optional. Transaction options
        *
        * @returns AccountAuthenticator
        */
        function signTransaction(args) {
          var _this = this;
          return _async_to_generator(function() {
            var transactionOrPayload, asFeePayer, _this__wallet_features_aptossignTransaction, _this__wallet, response, _transactionOrPayload_options, _transactionOrPayload_options1, _transactionOrPayload_options2, _transactionOrPayload_options3, _transactionOrPayload_options4, _this__wallet1, signTransactionV1_1StandardInput, walletSignTransactionMethod, response1, _this__wallet2, aptosConfig, aptos, transaction, response2, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  transactionOrPayload = args.transactionOrPayload, asFeePayer = args.asFeePayer;
                  _state.label = 1;
                case 1:
                  _state.trys.push([
                    1,
                    9,
                    ,
                    10
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_transaction");
                  if (!("rawTransaction" in transactionOrPayload)) return [
                    3,
                    3
                  ];
                  return [
                    4,
                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.features["aptos:signTransaction"].signTransaction(transactionOrPayload, asFeePayer)
                  ];
                case 2:
                  response = _state.sent();
                  if (response.status === r2.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response.args,
                      rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()
                    }
                  ];
                case 3:
                  if (!(((_this__wallet_features_aptossignTransaction = _this._wallet.features["aptos:signTransaction"]) === null || _this__wallet_features_aptossignTransaction === void 0 ? void 0 : _this__wallet_features_aptossignTransaction.version) === "1.1.0")) return [
                    3,
                    5
                  ];
                  signTransactionV1_1StandardInput = {
                    payload: transactionOrPayload.data,
                    expirationTimestamp: (_transactionOrPayload_options = transactionOrPayload.options) === null || _transactionOrPayload_options === void 0 ? void 0 : _transactionOrPayload_options.expirationTimestamp,
                    expirationSecondsFromNow: (_transactionOrPayload_options1 = transactionOrPayload.options) === null || _transactionOrPayload_options1 === void 0 ? void 0 : _transactionOrPayload_options1.expirationSecondsFromNow,
                    gasUnitPrice: (_transactionOrPayload_options2 = transactionOrPayload.options) === null || _transactionOrPayload_options2 === void 0 ? void 0 : _transactionOrPayload_options2.gasUnitPrice,
                    maxGasAmount: (_transactionOrPayload_options3 = transactionOrPayload.options) === null || _transactionOrPayload_options3 === void 0 ? void 0 : _transactionOrPayload_options3.maxGasAmount,
                    sequenceNumber: (_transactionOrPayload_options4 = transactionOrPayload.options) === null || _transactionOrPayload_options4 === void 0 ? void 0 : _transactionOrPayload_options4.accountSequenceNumber,
                    sender: transactionOrPayload.sender ? {
                      address: l.from(transactionOrPayload.sender)
                    } : void 0
                  };
                  walletSignTransactionMethod = (_this__wallet1 = _this._wallet) === null || _this__wallet1 === void 0 ? void 0 : _this__wallet1.features["aptos:signTransaction"].signTransaction;
                  return [
                    4,
                    walletSignTransactionMethod(signTransactionV1_1StandardInput)
                  ];
                case 4:
                  response1 = _state.sent();
                  if (response1.status === r2.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response1.args.authenticator,
                      rawTransaction: response1.args.rawTransaction.bcsToBytes()
                    }
                  ];
                case 5:
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new ee(aptosConfig);
                  return [
                    4,
                    aptos.transaction.build.simple({
                      sender: _this._account.address,
                      data: transactionOrPayload.data,
                      options: transactionOrPayload.options,
                      withFeePayer: transactionOrPayload.withFeePayer
                    })
                  ];
                case 6:
                  transaction = _state.sent();
                  return [
                    4,
                    (_this__wallet2 = _this._wallet) === null || _this__wallet2 === void 0 ? void 0 : _this__wallet2.features["aptos:signTransaction"].signTransaction(transaction, asFeePayer)
                  ];
                case 7:
                  response2 = _state.sent();
                  if (response2.status === r2.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response2.args,
                      rawTransaction: transaction.bcsToBytes()
                    }
                  ];
                case 8:
                  return [
                    3,
                    10
                  ];
                case 9:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignTransactionError(errMsg).message;
                case 10:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signMessage",
      value: (
        /**
        * Sign a message (doesnt submit to chain).
        *
        * @param message - AptosSignMessageInput
        *
        * @return response from the wallet's signMessage function
        * @throws WalletSignMessageError
        */
        function signMessage(message) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptossignMessage, _this__wallet, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.recordEvent("sign_message");
                  return [
                    4,
                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : (_this__wallet_features_aptossignMessage = _this__wallet.features["aptos:signMessage"]) === null || _this__wallet_features_aptossignMessage === void 0 ? void 0 : _this__wallet_features_aptossignMessage.signMessage(message)
                  ];
                case 1:
                  response = _state.sent();
                  if (response.status === r2.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response.args
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignMessageError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "submitTransaction",
      value: (
        /**
        * Submits transaction to chain
        *
        * @param transaction - InputSubmitTransactionData
        * @returns PendingTransactionResponse
        */
        function submitTransaction(transaction) {
          var _this = this;
          return _async_to_generator(function() {
            var additionalSignersAuthenticators, transactionType, aptosConfig, aptos, multiAgentTxn, errMsg;
            return _ts_generator(this, function(_state) {
              try {
                _this.ensureWalletExists(_this._wallet);
                additionalSignersAuthenticators = transaction.additionalSignersAuthenticators;
                transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
                _this.recordEvent("submit_transaction", {
                  transaction_type: transactionType
                });
                aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                aptos = new ee(aptosConfig);
                if (additionalSignersAuthenticators !== void 0) {
                  multiAgentTxn = _object_spread_props(_object_spread({}, transaction), {
                    additionalSignersAuthenticators
                  });
                  return [
                    2,
                    aptos.transaction.submit.multiAgent(multiAgentTxn)
                  ];
                } else {
                  return [
                    2,
                    aptos.transaction.submit.simple(transaction)
                  ];
                }
              } catch (error) {
                errMsg = generalizedErrorMessage(error);
                throw new WalletSubmitTransactionError(errMsg).message;
              }
              return [
                2
              ];
            });
          })();
        }
      )
    },
    {
      key: "onAccountChange",
      value: (
        /**
        Event for when account has changed on the wallet
        @return the new account info
        @throws WalletAccountChangeError
        */
        function onAccountChange() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptosonAccountChange, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    (_this__wallet_features_aptosonAccountChange = _this._wallet.features["aptos:onAccountChange"]) === null || _this__wallet_features_aptosonAccountChange === void 0 ? void 0 : _this__wallet_features_aptosonAccountChange.onAccountChange(function() {
                      var _ref = _async_to_generator(function(data) {
                        return _ts_generator(this, function(_state2) {
                          switch (_state2.label) {
                            case 0:
                              _this.setAccount(data);
                              return [
                                4,
                                _this.setAnsName()
                              ];
                            case 1:
                              _state2.sent();
                              _this.recordEvent("account_change");
                              _this.emit("accountChange", _this._account);
                              return [
                                2
                              ];
                          }
                        });
                      });
                      return function(data) {
                        return _ref.apply(this, arguments);
                      };
                    }())
                  ];
                case 1:
                  _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletAccountChangeError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "onNetworkChange",
      value: (
        /**
        Event for when network has changed on the wallet
        @return the new network info
        @throws WalletNetworkChangeError
        */
        function onNetworkChange() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptosonNetworkChange, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    (_this__wallet_features_aptosonNetworkChange = _this._wallet.features["aptos:onNetworkChange"]) === null || _this__wallet_features_aptosonNetworkChange === void 0 ? void 0 : _this__wallet_features_aptosonNetworkChange.onNetworkChange(function() {
                      var _ref = _async_to_generator(function(data) {
                        return _ts_generator(this, function(_state2) {
                          switch (_state2.label) {
                            case 0:
                              _this.setNetwork(data);
                              return [
                                4,
                                _this.setAnsName()
                              ];
                            case 1:
                              _state2.sent();
                              _this.emit("networkChange", _this._network);
                              return [
                                2
                              ];
                          }
                        });
                      });
                      return function(data) {
                        return _ref.apply(this, arguments);
                      };
                    }())
                  ];
                case 1:
                  _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletNetworkChangeError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "changeNetwork",
      value: (
        /**
        * Sends a change network request to the wallet to change the connected network
        *
        * @param network - Network
        * @returns AptosChangeNetworkOutput
        */
        function changeNetwork(network) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__network, chainId, _tmp, networkInfo, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    6,
                    ,
                    7
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.recordEvent("change_network_request", {
                    from: (_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
                    to: network
                  });
                  if (!(network === e.DEVNET)) return [
                    3,
                    2
                  ];
                  return [
                    4,
                    fetchDevnetChainId()
                  ];
                case 1:
                  _tmp = _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  _tmp = l2[network];
                  _state.label = 3;
                case 3:
                  chainId = _tmp;
                  networkInfo = {
                    name: network,
                    chainId
                  };
                  if (!_this._wallet.features["aptos:changeNetwork"]) return [
                    3,
                    5
                  ];
                  return [
                    4,
                    _this._wallet.features["aptos:changeNetwork"].changeNetwork(networkInfo)
                  ];
                case 4:
                  response = _state.sent();
                  if (response.status === r2.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response.args
                  ];
                case 5:
                  throw new WalletChangeNetworkError("".concat(_this._wallet.name, " does not support changing network request")).message;
                case 6:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletChangeNetworkError(errMsg).message;
                case 7:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signMessageAndVerify",
      value: (
        /**
        * Signs a message and verifies the signer
        * @param message - AptosSignMessageInput
        * @returns boolean
        */
        function signMessageAndVerify(message) {
          var _this = this;
          return _async_to_generator(function() {
            var response, aptosConfig, signingMessage, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    4,
                    ,
                    5
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_message_and_verify");
                  return [
                    4,
                    _this._wallet.features["aptos:signMessage"].signMessage(message)
                  ];
                case 1:
                  response = _state.sent();
                  if (response.status === r2.REJECTED) {
                    throw new WalletConnectionError("Failed to sign a message").message;
                  }
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  signingMessage = new TextEncoder().encode(response.args.fullMessage);
                  if (!("verifySignatureAsync" in _this._account.publicKey)) return [
                    3,
                    3
                  ];
                  return [
                    4,
                    _this._account.publicKey.verifySignatureAsync({
                      aptosConfig,
                      message: signingMessage,
                      signature: response.args.signature,
                      options: {
                        throwErrorWithReason: true
                      }
                    })
                  ];
                case 2:
                  return [
                    2,
                    _state.sent()
                  ];
                case 3:
                  return [
                    2,
                    _this._account.publicKey.verifySignature({
                      message: signingMessage,
                      signature: response.args.signature
                    })
                  ];
                case 4:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignMessageAndVerifyError(errMsg).message;
                case 5:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    }
  ]);
  return WalletCore2;
}(import_eventemitter3.default);
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i4 = 0; i4 < cleanups.length; i4++) {
          const cleanup = cleanups[i4];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i4], null);
          }
        }
      };
    }
  };
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use = React2[" use ".trim().toString()];
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
  return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React2.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React2.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props2);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a9, b4) => {
  for (var prop in b4 || (b4 = {}))
    if (__hasOwnProp.call(b4, prop))
      __defNormalProp(a9, prop, b4[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b4)) {
      if (__propIsEnum.call(b4, prop))
        __defNormalProp(a9, prop, b4[prop]);
    }
  return a9;
};
var __spreadProps = (a9, b4) => __defProps(a9, __getOwnPropDescs(b4));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e14) {
        reject(e14);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e14) {
        reject(e14);
      }
    };
    var step = (x4) => x4.done ? resolve(x4.value) : Promise.resolve(x4.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var DEFAULT_CONTEXT = {
  connected: false
};
var WalletContext = (0, import_react2.createContext)(
  DEFAULT_CONTEXT
);
function useWallet() {
  const context = (0, import_react2.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  optInWallets,
  hideWallets,
  autoConnect = false,
  dappConfig,
  disableTelemetry = false,
  onError
}) => {
  const didAttemptAutoConnectRef = (0, import_react.useRef)(false);
  const initialLoadCompletedRef = (0, import_react.useRef)(false);
  const [{ account, network, connected, wallet }, setState2] = (0, import_react.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [walletCore, setWalletCore] = (0, import_react.useState)();
  const [wallets2, setWallets] = (0, import_react.useState)([]);
  const [hiddenWallets, setHiddenWallets] = (0, import_react.useState)([]);
  const [notDetectedWallets, setNotDetectedWallets] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    const walletCore2 = new WalletCore(
      optInWallets,
      dappConfig,
      disableTelemetry,
      hideWallets ? hideWallets : ["Petra Web"]
    );
    setWalletCore(walletCore2);
  }, []);
  (0, import_react.useEffect)(() => {
    var _a, _b, _c;
    setWallets((_a = walletCore == null ? void 0 : walletCore.wallets) != null ? _a : []);
    setHiddenWallets((_b = walletCore == null ? void 0 : walletCore.hiddenWallets) != null ? _b : []);
    setNotDetectedWallets((_c = walletCore == null ? void 0 : walletCore.notDetectedWallets) != null ? _c : []);
  }, [walletCore]);
  (0, import_react.useEffect)(() => {
    if (didAttemptAutoConnectRef.current || !(walletCore == null ? void 0 : walletCore.wallets.length)) {
      return;
    }
    if (!autoConnect) {
      if (!initialLoadCompletedRef.current) {
        initialLoadCompletedRef.current = true;
        setIsLoading(false);
      }
      return;
    }
    const walletName = localStorage.getItem("AptosWalletName");
    if (!walletName) {
      didAttemptAutoConnectRef.current = true;
      if (!initialLoadCompletedRef.current) {
        initialLoadCompletedRef.current = true;
        setIsLoading(false);
      }
      return;
    }
    const selectedWallet = walletCore.wallets.find(
      (e14) => e14.name === walletName
    );
    if (!selectedWallet || selectedWallet.readyState !== WalletReadyState.Installed) {
      if (!initialLoadCompletedRef.current) {
        initialLoadCompletedRef.current = true;
        setIsLoading(false);
      }
      return;
    }
    didAttemptAutoConnectRef.current = true;
    if (!connected) {
      (() => __async(void 0, null, function* () {
        try {
          let shouldConnect = true;
          if (typeof autoConnect === "function") {
            shouldConnect = yield autoConnect(walletCore, selectedWallet);
          } else {
            shouldConnect = autoConnect;
          }
          if (shouldConnect) yield connect(walletName);
        } catch (error) {
          if (onError) onError(error);
          return Promise.reject(error);
        } finally {
          initialLoadCompletedRef.current = true;
          setIsLoading(false);
        }
      }))();
    } else {
      initialLoadCompletedRef.current = true;
      setIsLoading(false);
    }
  }, [autoConnect, wallets2]);
  const connect = (walletName) => __async(void 0, null, function* () {
    try {
      setIsLoading(true);
      yield walletCore == null ? void 0 : walletCore.connect(walletName);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  });
  const signIn = (args) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      setIsLoading(true);
      return yield walletCore == null ? void 0 : walletCore.signIn(args);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  });
  const disconnect = () => __async(void 0, null, function* () {
    try {
      yield walletCore == null ? void 0 : walletCore.disconnect();
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signAndSubmitTransaction = (transaction) => __async(void 0, null, function* () {
    try {
      if (!walletCore) {
        throw new Error("WalletCore is not initialized");
      }
      return yield walletCore.signAndSubmitTransaction(transaction);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signTransaction = (args) => __async(void 0, null, function* () {
    const { transactionOrPayload, asFeePayer, options } = args;
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore.signTransaction({
        transactionOrPayload,
        asFeePayer
      });
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const submitTransaction = (transaction) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.submitTransaction(transaction);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signMessage = (message) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.signMessage(message);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signMessageAndVerify = (message) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.signMessageAndVerify(message);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const changeNetwork = (network2) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.changeNetwork(network2);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const handleConnect = () => {
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        connected: true,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: (walletCore == null ? void 0 : walletCore.wallet) || null
      });
    });
  };
  const handleAccountChange = (0, import_react.useCallback)(() => {
    if (!connected) return;
    if (!(walletCore == null ? void 0 : walletCore.wallet)) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        account: (walletCore == null ? void 0 : walletCore.account) || null
      });
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react.useCallback)(() => {
    if (!connected) return;
    if (!(walletCore == null ? void 0 : walletCore.wallet)) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        network: (walletCore == null ? void 0 : walletCore.network) || null
      });
    });
  }, [connected]);
  (0, import_react.useEffect)(() => {
    if (connected) {
      walletCore == null ? void 0 : walletCore.onAccountChange();
      walletCore == null ? void 0 : walletCore.onNetworkChange();
    }
  }, [connected]);
  const handleDisconnect = () => {
    if (!connected) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        connected: false,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: null
      });
    });
  };
  const handleStandardWalletsAdded = (standardWallet) => {
    const existingWalletIndex = wallets2.findIndex(
      (wallet2) => wallet2.name == standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setWallets((wallets22) => [
        ...wallets22.slice(0, existingWalletIndex),
        standardWallet,
        ...wallets22.slice(existingWalletIndex + 1)
      ]);
    } else {
      setWallets((wallets22) => [...wallets22, standardWallet]);
    }
  };
  const handleStandardWalletsHiddenAdded = (standardWallet) => {
    const existingWalletIndex = hiddenWallets.findIndex(
      (wallet2) => wallet2.name === standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setHiddenWallets((hiddenWallets2) => [
        ...hiddenWallets2.slice(0, existingWalletIndex),
        standardWallet,
        ...hiddenWallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setHiddenWallets((hiddenWallets2) => [...hiddenWallets2, standardWallet]);
    }
  };
  const handleStandardNotDetectedWalletsAdded = (notDetectedWallet) => {
    const existingWalletIndex = wallets2.findIndex(
      (wallet2) => wallet2.name == notDetectedWallet.name
    );
    if (existingWalletIndex !== -1) {
      setNotDetectedWallets((wallets22) => [
        ...wallets22.slice(0, existingWalletIndex),
        notDetectedWallet,
        ...wallets22.slice(existingWalletIndex + 1)
      ]);
    } else {
      setNotDetectedWallets((wallets22) => [...wallets22, notDetectedWallet]);
    }
  };
  (0, import_react.useEffect)(() => {
    walletCore == null ? void 0 : walletCore.on("connect", handleConnect);
    walletCore == null ? void 0 : walletCore.on("accountChange", handleAccountChange);
    walletCore == null ? void 0 : walletCore.on("networkChange", handleNetworkChange);
    walletCore == null ? void 0 : walletCore.on("disconnect", handleDisconnect);
    walletCore == null ? void 0 : walletCore.on("standardWalletsAdded", handleStandardWalletsAdded);
    walletCore == null ? void 0 : walletCore.on(
      "standardWalletsHiddenAdded",
      handleStandardWalletsHiddenAdded
    );
    walletCore == null ? void 0 : walletCore.on(
      "standardNotDetectedWalletAdded",
      handleStandardNotDetectedWalletsAdded
    );
    return () => {
      walletCore == null ? void 0 : walletCore.off("connect", handleConnect);
      walletCore == null ? void 0 : walletCore.off("accountChange", handleAccountChange);
      walletCore == null ? void 0 : walletCore.off("networkChange", handleNetworkChange);
      walletCore == null ? void 0 : walletCore.off("disconnect", handleDisconnect);
      walletCore == null ? void 0 : walletCore.off("standardWalletsAdded", handleStandardWalletsAdded);
      walletCore == null ? void 0 : walletCore.off(
        "standardWalletsHiddenAdded",
        handleStandardWalletsHiddenAdded
      );
      walletCore == null ? void 0 : walletCore.off(
        "standardNotDetectedWalletAdded",
        handleStandardNotDetectedWalletsAdded
      );
    };
  }, [wallets2, account]);
  return (0, import_jsx_runtime2.jsx)(
    WalletContext.Provider,
    {
      value: {
        connect,
        signIn,
        disconnect,
        signAndSubmitTransaction,
        signTransaction,
        signMessage,
        signMessageAndVerify,
        changeNetwork,
        submitTransaction,
        account,
        network,
        connected,
        wallet,
        wallets: wallets2,
        notDetectedWallets,
        hiddenWallets,
        isLoading
      },
      children
    }
  );
};
var LinkGraphic = (0, import_react4.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime3.jsx)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "102",
        height: "132",
        viewBox: "0 0 102 132",
        fill: "none"
      }, props), {
        children: (0, import_jsx_runtime3.jsxs)("g", { stroke: "currentColor", strokeMiterlimit: "10", children: [
          (0, import_jsx_runtime3.jsx)("path", { d: "M59.633 80.66c11.742-2.814 17.48-7.018 20.925-13.254l17.518-31.69c6.257-11.317 2.142-25.55-9.189-31.798C82.737.53 75.723.188 69.593 2.398M60.7 69.565a14.09 14.09 0 0 1-6.907-1.767l-.228-.108" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "m52.365 41.075 12.507-22.627a14.146 14.146 0 0 1 4.727-5.062M32.407 118.619a14.139 14.139 0 0 1-7.034-1.768c-6.857-3.78-9.353-12.402-5.561-19.25l16.634-30.1a14.097 14.097 0 0 1 4.518-4.923" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M41.211 78.85c11.332 6.248 25.583 2.14 31.84-9.177l17.518-31.691c6.256-11.317 2.142-25.55-9.19-31.798-6.085-3.357-13.018-3.724-19.104-1.59A23.31 23.31 0 0 0 49.541 15.36L36.863 38.298l7.989 5.036 12.506-22.627c3.786-6.848 12.419-9.34 19.276-5.554 6.856 3.78 9.353 12.402 5.561 19.25l-16.634 30.1c-3.785 6.848-12.418 9.341-19.275 5.555l-5.075 8.791ZM29.5 130.447c12.361-1.37 19.2-6.994 22.966-13.804l12.678-22.936-8.305-5.239" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "m55.72 61.947-.442.764 5.511-9.55c-6.901-3.806-18.65-3.124-27.105.814M44.85 43.523l7.635-2.486m-4.221 23.264 7.217-1.723m-9.316 7.517 7.59-2.405m-.562-12.156 7.508-2.221m10.136-51.32L62.761 4.43M49.642 90.778l7.514-2.26m.474 7.448 7.514-2.26m-50.306-60.13c7.135 0 12.918-5.776 12.918-12.9 0-7.126-5.783-12.902-12.918-12.902-7.134 0-12.917 5.776-12.917 12.901s5.783 12.901 12.918 12.901Z" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M15.724 7.774h3.197c7.135 0 12.918 5.776 12.918 12.901 0 7.126-5.783 12.901-12.918 12.901h-3.425m65.112 66.935h3.198c7.135 0 12.918 5.775 12.918 12.901 0 7.125-5.783 12.9-12.918 12.9h-3.425" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M79.717 126.312c7.135 0 12.918-5.775 12.918-12.9s-5.783-12.901-12.918-12.901c-7.134 0-12.917 5.776-12.917 12.901s5.783 12.9 12.917 12.9ZM53.281 55.414c-11.33-6.248-25.582-2.14-31.839 9.177L3.924 96.281c-6.257 11.318-2.142 25.55 9.189 31.799 11.331 6.248 25.582 2.139 31.839-9.177l12.677-22.937-7.988-5.036-12.507 22.627c-3.785 6.848-12.418 9.341-19.275 5.554-6.857-3.781-9.353-12.402-5.561-19.25l16.633-30.1c3.786-6.848 12.419-9.341 19.276-5.555l5.074-8.792Z" })
        ] })
      })
    );
  }
);
LinkGraphic.displayName = "LinkGraphic";
var WalletGraphic = (0, import_react5.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime4.jsxs)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "128",
        height: "102",
        viewBox: "0 0 128 102",
        fill: "none"
      }, props), {
        children: [
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              fill: "currentColor",
              d: "m.96 25.93-.36-.35.36.85v-.5Zm7.79-7.81v-.5h-.21l-.15.15.36.35ZM1.3 26.28l7.79-7.8-.7-.71-7.8 7.8.7.71Zm7.44-7.66H10v-1H8.75v1Zm29.22 6.8h-37v1h37.01v-1Z"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M82.25 26.08c0 12.25-9.92 22.2-22.14 22.2a22.17 22.17 0 0 1-22.14-22.2H1.1v74.82h118.02V26.08H82.25Zm44.33 67.02h.33V18.27h-5.7"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M74.52 42.92a22.4 22.4 0 0 1-11.43 3.3 22.5 22.5 0 0 1-22.46-22.53H9.52M119.22 101l7.78-7.82m-7.88-67.1 7.79-7.81m-44.78 7.72 2.73-2.3m-46.89 2.39 2.39-2.4"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M9.86 23.69V5.72h107.97v18.04H84.65"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M117.83 20.46h3.39V1H13.25v4.72M9.36 23.69h31.78"
            }
          )
        ]
      })
    );
  }
);
WalletGraphic.displayName = "WalletGraphic";
var Web3Graphic = (0, import_react6.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime5.jsx)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "142",
        height: "108",
        viewBox: "0 0 142 108",
        fill: "none"
      }, props), {
        children: (0, import_jsx_runtime5.jsxs)("g", { stroke: "currentColor", strokeLinejoin: "round", children: [
          (0, import_jsx_runtime5.jsx)("path", { d: "m91.26 35.8.06-10.46L71.3 1v10.53L87 30.5m-36.11 5.24-.06-10.45L71.3 1v10.53L55 30.5" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.55V49.17L50.83 25.3l.06 10.45L57 42.5m14 17.05V49.18l20.33-23.84-.07 10.45L86 42M1 59.68l.22-9.07 35.33-19.8-.1 9L9 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M36.55 30.8s-.08 5.92-.1 9l.1-9ZM71 59.51v-9.07L36.55 30.8l-.1 9L63.5 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07L36.44 70.78l-.1 9.14L55.5 68.5" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M1.22 50.6a77387.2 77387.2 0 0 0 35.22 20.18l-.1 9.14L1 59.68l.23-9.07h-.01ZM141 59.68l-.23-9.07-35.33-19.8.11 9L133 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "m105.44 30.8.11 9-.1-9Z" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07l34.44-19.64.11 9L78.5 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07l34.56 20.34.1 9.14L87 69" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M140.78 50.6a78487.3 78487.3 0 0 1-35.23 20.18l.11 9.14L141 59.68l-.23-9.07ZM50.83 80.15l.06-6.33 20.1-23.38H71v9.26L55 79" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71.3 97.6 50.89 73.81l-.06 9.33L71.3 107v-9.4Zm20.03-14.5-.07-9.33L71 50.44v9.26l16 18.8" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "m71.3 97.6 19.96-23.83.06 9.33L71.3 107v-9.4Z" })
        ] })
      })
    );
  }
);
Web3Graphic.displayName = "Web3Graphic";
function createHeadlessComponent(displayName, elementType, props) {
  const component = (0, import_react7.forwardRef)(({ className, asChild, children }, ref) => {
    const Component = asChild ? Slot : elementType;
    const _a = typeof props === "function" ? props(displayName) : props != null ? props : {}, { children: defaultChildren } = _a, resolvedProps = __objRest(_a, ["children"]);
    const resolvedChildren = (
      /**
       * Use props' default children if no children are set in the component element's children and when asChild is true.
       */
      asChild && (0, import_react7.isValidElement)(children) && !children.props.children ? (0, import_react7.cloneElement)(children, {}, defaultChildren) : children != null ? children : defaultChildren
    );
    return (
      /**
       * Due to the complexity of the types at play, TypeScript reports the
       * following error for our JSX below:
       *
       * `Expression produces a union type that is too complex to represent.`
       *
       * We can safely ignore this error and retain accurate return types for
       * consumers of this function. The only drawback is that type-checking is
       * ignored for the JSX block below.
       */
      // @ts-expect-error
      (0, import_jsx_runtime6.jsx)(Component, __spreadProps(__spreadValues({ ref, className }, resolvedProps), { children: resolvedChildren }))
    );
  });
  component.displayName = displayName;
  return component;
}
var EXPLORE_ECOSYSTEM_URL = "https://aptosnetwork.com/ecosystem/directory/category/defi";
var AboutAptosConnectContext = (0, import_react3.createContext)(null);
function useAboutAptosConnectContext(displayName) {
  const context = (0, import_react3.useContext)(AboutAptosConnectContext);
  if (!context) {
    throw new Error(
      `\`${displayName}\` must be used within \`AboutAptosConnect\``
    );
  }
  return context;
}
var educationScreens = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Petra Web is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
        "Petra Web lets you take one account across any application built on Aptos.",
        " ",
        (0, import_jsx_runtime7.jsx)(
          "a",
          {
            href: EXPLORE_ECOSYSTEM_URL,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }
        ),
        "."
      ] })
    })
  }
];
var educationScreenIndicators = Array(educationScreens.length).fill(null).map(
  (_3, index) => createHeadlessComponent(
    "AboutAptosConnect.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutAptosConnectContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react3.useState)(0);
  const currentEducationScreen = (0, import_react3.useMemo)(
    () => educationScreens.map((screen, i4) => __spreadProps(__spreadValues({}, screen), {
      screenIndex: i4,
      totalScreens: educationScreens.length,
      screenIndicators: educationScreenIndicators,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime7.jsx)(AboutAptosConnectContext.Provider, { value: { screenIndex, setScreenIndex }, children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen) });
};
Root.displayName = "AboutAptosConnect";
var Trigger = createHeadlessComponent(
  "AboutAptosConnect.Trigger",
  "button",
  (displayName) => {
    const context = useAboutAptosConnectContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutAptosConnect = Object.assign(Root, {
  Trigger
});
var EXPLORE_ECOSYSTEM_URL2 = "https://aptosnetwork.com/ecosystem/directory/category/defi";
var AboutPetraWebContext = (0, import_react8.createContext)(null);
function useAboutPetraWebContext(displayName) {
  const context = (0, import_react8.useContext)(AboutPetraWebContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`AboutPetraWeb\``);
  }
  return context;
}
var educationScreens2 = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Petra Web is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
        "Petra Web lets you take one account across any application built on Aptos.",
        " ",
        (0, import_jsx_runtime8.jsx)(
          "a",
          {
            href: EXPLORE_ECOSYSTEM_URL2,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }
        ),
        "."
      ] })
    })
  }
];
var educationScreenIndicators2 = Array(educationScreens2.length).fill(null).map(
  (_3, index) => createHeadlessComponent(
    "AboutPetraWeb.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutPetraWebContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root2 = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react8.useState)(0);
  const currentEducationScreen = (0, import_react8.useMemo)(
    () => educationScreens2.map((screen, i4) => __spreadProps(__spreadValues({}, screen), {
      screenIndex: i4,
      totalScreens: educationScreens2.length,
      screenIndicators: educationScreenIndicators2,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens2.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime8.jsx)(AboutPetraWebContext.Provider, { value: { screenIndex, setScreenIndex }, children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen) });
};
Root2.displayName = "AboutPetraWeb";
var Trigger2 = createHeadlessComponent(
  "AboutPetraWeb.Trigger",
  "button",
  (displayName) => {
    const context = useAboutPetraWebContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutPetraWeb = Object.assign(Root2, {
  Trigger: Trigger2
});
var SmallAptosLogo = (0, import_react10.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime9.jsx)(
    "svg",
    __spreadProps(__spreadValues({
      ref,
      width: "12",
      height: "12",
      viewBox: "0 0 12 12",
      fill: "none"
    }, props), {
      children: (0, import_jsx_runtime9.jsx)(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M6 12C9.31371 12 12 9.31371 12 6C12 2.68629 9.31371 0 6 0C2.68629 0 0 2.68629 0 6C0 9.31371 2.68629 12 6 12ZM7.17547 3.67976C7.13401 3.72309 7.07649 3.74757 7.01648 3.74757H3.00775C3.69185 2.83824 4.77995 2.25 6.00569 2.25C7.23142 2.25 8.31953 2.83824 9.00362 3.74757H8.28524C8.20824 3.74757 8.13498 3.71468 8.08401 3.65701L7.81608 3.35416C7.77618 3.30896 7.71882 3.28308 7.6585 3.28308H7.6454C7.58805 3.28308 7.53318 3.30646 7.49343 3.34792L7.17547 3.67976ZM8.05656 4.75897H7.39569C7.31869 4.75897 7.24543 4.72593 7.19447 4.66842L6.92638 4.36557C6.88647 4.32036 6.82896 4.29465 6.7688 4.29465C6.70863 4.29465 6.65112 4.32052 6.61121 4.36557L6.38131 4.6254C6.30603 4.71034 6.19801 4.75913 6.08454 4.75913H2.46703C2.36401 5.05278 2.29683 5.36296 2.27002 5.68467H5.68505C5.74506 5.68467 5.80258 5.66019 5.84404 5.61686L6.16201 5.28502C6.20175 5.24356 6.25662 5.22018 6.31398 5.22018H6.32707C6.38739 5.22018 6.44475 5.24606 6.48465 5.29126L6.75258 5.59411C6.80355 5.65178 6.87681 5.68467 6.95381 5.68467H9.74133C9.71452 5.3628 9.64734 5.05263 9.54431 4.75913H8.05641L8.05656 4.75897ZM4.33651 7.63095C4.39652 7.63095 4.45404 7.60648 4.4955 7.56315L4.81347 7.23131C4.85321 7.18985 4.90808 7.16647 4.96544 7.16647H4.97853C5.03885 7.16647 5.09621 7.19234 5.13611 7.23739L5.40404 7.54024C5.45501 7.59791 5.52827 7.6308 5.60527 7.6308H9.38285C9.52438 7.33839 9.62803 7.02463 9.68975 6.69591H6.06383C5.98683 6.69591 5.91357 6.66287 5.8626 6.60535L5.59467 6.3025C5.55477 6.2573 5.49725 6.23158 5.43709 6.23158C5.37692 6.23158 5.31941 6.25746 5.27951 6.3025L5.0496 6.56233C4.97432 6.64728 4.86631 6.69606 4.75268 6.69606H2.32147C2.3832 7.02479 2.487 7.33855 2.62837 7.63095H4.33651ZM5.57359 8.55745H4.59116C4.51417 8.55745 4.44091 8.52441 4.38994 8.46689L4.12201 8.16404C4.0821 8.11884 4.02459 8.09312 3.96442 8.09312C3.90426 8.09312 3.84675 8.119 3.80684 8.16404L3.57694 8.42387C3.50166 8.50882 3.39364 8.55761 3.28001 8.55761H3.26474C3.94915 9.29096 4.92378 9.74998 6.00596 9.74998C7.08815 9.74998 8.06262 9.29096 8.74719 8.55761H5.57359V8.55745Z",
          fill: "currentColor"
        }
      )
    })
  );
});
SmallAptosLogo.displayName = "SmallAptosLogo";
var APTOS_PRIVACY_POLICY_URL = "https://aptoslabs.com/privacy";
var Root3 = createHeadlessComponent("AptosPrivacyPolicy.Root", "div");
var Disclaimer = createHeadlessComponent(
  "AptosPrivacyPolicy.Disclaimer",
  "span",
  { children: "By continuing, you agree to Aptos Labs'" }
);
var Link = createHeadlessComponent("AptosPrivacyPolicy.Disclaimer", "a", {
  href: APTOS_PRIVACY_POLICY_URL,
  target: "_blank",
  rel: "noopener noreferrer",
  children: "Privacy Policy"
});
var PoweredBy = (0, import_react9.forwardRef)(({ className }, ref) => {
  return (0, import_jsx_runtime10.jsxs)("div", { ref, className, children: [
    (0, import_jsx_runtime10.jsx)("span", { children: "Powered by" }),
    (0, import_jsx_runtime10.jsx)(SmallAptosLogo, {}),
    (0, import_jsx_runtime10.jsx)("span", { children: "Aptos Labs" })
  ] });
});
PoweredBy.displayName = "AptosPrivacyPolicy.PoweredBy";
var AptosPrivacyPolicy = Object.assign(Root3, {
  Disclaimer,
  Link,
  PoweredBy
});
function useWalletItemContext(displayName) {
  const context = (0, import_react11.useContext)(WalletItemContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`WalletItem\``);
  }
  return context;
}
var WalletItemContext = (0, import_react11.createContext)(null);
var Root4 = (0, import_react11.forwardRef)(
  ({ wallet, onConnect, className, asChild, children }, ref) => {
    const { connect } = useWallet();
    const isWalletReady = wallet.readyState === WalletReadyState.Installed;
    const mobileSupport = "deeplinkProvider" in wallet && wallet.deeplinkProvider;
    const connectWallet = (0, import_react11.useCallback)(() => {
      const connectionWallet = shouldUseFallbackWallet(wallet) ? wallet.fallbackWallet : wallet;
      if (!connectionWallet) return;
      connect(connectionWallet.name);
      onConnect == null ? void 0 : onConnect();
    }, [wallet, connect, onConnect]);
    if (!isWalletReady && isRedirectable() && !mobileSupport) return null;
    const Component = asChild ? Slot : "div";
    return (0, import_jsx_runtime11.jsx)(WalletItemContext.Provider, { value: { wallet, connectWallet }, children: (0, import_jsx_runtime11.jsx)(Component, { ref, className, children }) });
  }
);
Root4.displayName = "WalletItem";
var Icon = createHeadlessComponent(
  "WalletItem.Icon",
  "img",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      src: context.wallet.icon,
      alt: `${context.wallet.name} icon`
    };
  }
);
var Name = createHeadlessComponent(
  "WalletItem.Name",
  "div",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      children: context.wallet.name
    };
  }
);
var ConnectButton = createHeadlessComponent(
  "WalletItem.ConnectButton",
  "button",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      onClick: context.connectWallet,
      children: "Connect"
    };
  }
);
var InstallLink = createHeadlessComponent(
  "WalletItem.InstallLink",
  "a",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      href: context.wallet.url,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Install"
    };
  }
);
var WalletItem = Object.assign(Root4, {
  Icon,
  Name,
  ConnectButton,
  InstallLink
});
export {
  APTOS_CONNECT_ACCOUNT_URL,
  APTOS_CONNECT_BASE_URL,
  APTOS_PRIVACY_POLICY_URL,
  AboutAptosConnect,
  AboutPetraWeb,
  AptosPrivacyPolicy,
  AptosWalletAdapterProvider,
  ChainIdToAnsSupportedNetworkMap,
  DEFAULT_WALLET_CONNECTION_FALLBACKS,
  EXPLORE_ECOSYSTEM_URL2 as EXPLORE_ECOSYSTEM_URL,
  NetworkName2 as NetworkName,
  PETRA_WALLET_NAME,
  PETRA_WEB_ACCOUNT_URL,
  PETRA_WEB_BASE_URL,
  PETRA_WEB_GENERIC_WALLET_NAME,
  WalletContext,
  WalletCore,
  WalletItem,
  WalletReadyState,
  aptosStandardSupportedWalletList,
  convertNetwork,
  crossChainStandardSupportedWalletList,
  fetchDevnetChainId,
  generalizedErrorMessage,
  getAptosConfig,
  getAptosConnectWallets,
  getLocalStorage,
  getPetraWebWallets,
  getSDKWallets,
  groupAndSortWallets,
  handlePublishPackageTransaction,
  isAptosConnectWallet,
  isAptosLiveNetwork,
  isAptosNetwork,
  isInAppBrowser,
  isInstallRequired,
  isInstalledOrLoadable,
  isMobile,
  isPetraWebGenericWallet,
  isPetraWebWallet,
  isRedirectable,
  partitionWallets,
  removeLocalStorage,
  setLocalStorage,
  shouldUseFallbackWallet,
  truncateAddress,
  useWallet
};
//# sourceMappingURL=@aptos-labs_wallet-adapter-react.js.map
